# pwm框架分析
文件
```shell
drivers/pwm/core.c
drivers/pwm/sysfs.c
drivers/pwm/驱动.c
include/linux/pwm.h
```

## 1、core.c文件分析
### 1.1 mutex互斥体
#### 1.1.1 互斥体简介
&emsp;&emsp;互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在我们编写Linux驱动的时候遇到需要互斥访问的地方建议使用mutex。Linux内核使用mutex结构体表示互斥体。  
##### 1.1.1.1 结构体定义
```c
//省略了编译条件
struct mutex {
	atomic_long_t		owner;
	spinlock_t		wait_lock;
	struct list_head	wait_list;
};
```
##### 1.1.1.2 mutex的API函数
|函数                                            |描述                                                |
|------------------------------------------------|---------------------------------------------------|
|DEFINE_MUTEX(name)                              |定义并初始化一个 mutex 变量。                        |
|void mutex_init(mutex *lock)                    |初始化mutex                                         |
|void mutex_lock(struct mutex *lock)             |获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。|
|void mutex_unlock(struct mutex *lock)           |释放 mutex，也就给 mutex 解锁。                      |
|int mutex_trylock(struct mutex *lock)           |尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。   |
|int mutex_is_locked(struct mutex *lock)         |判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。 |
|int mutex_lock_interruptible(struct mutex *lock)|使用此函数获取信号量失败进入休眠以后可以被信号打断。    |
##### 1.1.1.3 互斥体的使用如下
```c
struct mutex lock; /* 定义一个互斥体 */
mutex_init(&lock); /* 初始化互斥体 */

mutex_lock(&lock); /* 上锁 */
/* 临界区 */
mutex_unlock(&lock); /* 解锁 */
```

## 1.2 函数分析
* alloc_pwms
函数：`static int alloc_pwms(int pwm, unsigned int count)`
作用：为编号值为`pwm`的pwmchip申请`count`个pwm编号。
```c
static int alloc_pwms(int pwm, unsigned int count)
{
    ······
    start = bitmap_find_next_zero_area(allocated_pwms, MAX_PWMS, from,
                        count, 0);

    //申请成功的条件：申请的pwm编号值需要大于零，且申请到的count个连续为0
    //的地址的起始索引`start`需要等于申请的pwm编号。
    //例如：有两个pwmchip，每个pwmchip有三路pwm输出，即（npwm），那么，第一个
    //pwm编号是0，申请的count值是3，返回的start值是0，相等，申请成功；
    //第二个pwm编号是2，申请的count值是3，返回的count值是2，相等，申请成功。
    if (pwm >= 0 && start != pwm)
        return -EEXIST;
    ······
    return start;
}
```
* free_pwms
函数：`static void free_pwms(struct pwm_chip *chip)`
作用：释放pwmchip及其下面的pwm_device，还有pwmchip的pwm编号
```c
static void free_pwms(struct pwm_chip *chip)
{
    unsigned int i;

    //一个pwmchip下面可以有npwm个pwm_device
    for (i = 0; i < chip->npwm; i++) {
        struct pwm_device *pwm = &chip->pwms[i];
    
        //释放基数树中的pwmchip->pwms
        radix_tree_delete(&pwm_tree, pwm->pwm);
    }
    //清除pwmchip之前申请的npwm个pwm编号
    bitmap_clear(allocated_pwms, chip->base, chip->npwm);
    
    kfree(chip->pwms);
    chip->pwms = NULL;
}
```
* pwmchip_find_by_name
函数：`static struct pwm_chip *pwmchip_find_by_name(const char *name)`
作用：根据`name`来查找pwmchip

* pwm_device_request
函数：`static int pwm_device_request(struct pwm_device *pwm, const char *label)`
作用：

* of_pwm_xlate_with_flags
* of_pwm_simple_xlate
* of_pwmchip_add
* of_pwmchip_remove
* pwm_set_chip_data
函数：`int pwm_set_chip_data(struct pwm_device *pwm, void *data)`
作用：为pwm_device配置独有的数据
* pwm_get_chip_data
函数：`void *pwm_get_chip_data(struct pwm_device *pwm)`
作用：获取pwm_device中配置的独有的数据
* pwm_ops_check
函数：`static bool pwm_ops_check(const struct pwm_ops *ops)`
作用：检查驱动是否添加了操作函数，要么同时添加了`config`, `enable`, `disable`这三个传统的非原子操作的函数，要么添加了`apply`原子操作函数。否则返回false
* pwmchip_add_with_polarity
函数：`int pwmchip_add_with_polarity(struct pwm_chip *chip,
			      enum pwm_polarity polarity)`
作用：注册一个新的pwm chip。如果chip->base < 0，使用动态申请的base号。所有通道的极性被参数`polarity`指定。
* pwmchip_add
函数：`int pwmchip_add(struct pwm_chip *chip)`
作用：与上面的一样，只是没有添加默认的极性。
* pwmchip_remove
函数：`int pwmchip_remove(struct pwm_chip *chip)`
作用：移除pwm_chip
* pwm_apply_state
函数：`int pwm_apply_state(struct pwm_device *pwm, struct pwm_state *state)`
作用：将新的pwm状态设到pwm device中，如果driver中使用的新的apply函数，则使用apply函数，否则使用旧的enable, config等函数。
* pwm_capture
函数：`int pwm_capture(struct pwm_device *pwm, struct pwm_capture *result,
		unsigned long timeout)`
作用：捕获pwm_device的数据











