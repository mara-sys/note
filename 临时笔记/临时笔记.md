# pwm框架分析
文件
```shell
drivers/pwm/core.c
drivers/pwm/sysfs.c
drivers/pwm/驱动.c
include/linux/pwm.h
```

## 1、core.c文件分析
### 1.1 mutex互斥体
#### 1.1.1 互斥体简介
&emsp;&emsp;互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在我们编写Linux驱动的时候遇到需要互斥访问的地方建议使用mutex。Linux内核使用mutex结构体表示互斥体。  
##### 1.1.1.1 结构体定义
```c
//省略了编译条件
struct mutex {
	atomic_long_t		owner;
	spinlock_t		wait_lock;
	struct list_head	wait_list;
};
```
##### 1.1.1.2 mutex的API函数
|函数                                            |描述                                                |
|------------------------------------------------|---------------------------------------------------|
|DEFINE_MUTEX(name)                              |定义并初始化一个 mutex 变量。                        |
|void mutex_init(mutex *lock)                    |初始化mutex                                         |
|void mutex_lock(struct mutex *lock)             |获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。|
|void mutex_unlock(struct mutex *lock)           |释放 mutex，也就给 mutex 解锁。                      |
|int mutex_trylock(struct mutex *lock)           |尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。   |
|int mutex_is_locked(struct mutex *lock)         |判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。 |
|int mutex_lock_interruptible(struct mutex *lock)|使用此函数获取信号量失败进入休眠以后可以被信号打断。    |
##### 1.1.1.3 互斥体的使用如下
```c
struct mutex lock; /* 定义一个互斥体 */
mutex_init(&lock); /* 初始化互斥体 */

mutex_lock(&lock); /* 上锁 */
/* 临界区 */
mutex_unlock(&lock); /* 解锁 */
```


