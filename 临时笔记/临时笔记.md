# pwm框架分析
文件
```shell
drivers/pwm/core.c
drivers/pwm/sysfs.c
drivers/pwm/驱动.c
include/linux/pwm.h
```

## 1、core.c文件分析
### 1.1 mutex互斥体
#### 1.1.1 互斥体简介
&emsp;&emsp;互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。在我们编写Linux驱动的时候遇到需要互斥访问的地方建议使用mutex。Linux内核使用mutex结构体表示互斥体。  
##### 1.1.1.1 结构体定义
```c
//省略了编译条件
struct mutex {
	atomic_long_t		owner;
	spinlock_t		wait_lock;
	struct list_head	wait_list;
};
```
##### 1.1.1.2 mutex的API函数
|函数                                            |描述                                                |
|------------------------------------------------|---------------------------------------------------|
|DEFINE_MUTEX(name)                              |定义并初始化一个 mutex 变量。                        |
|void mutex_init(mutex *lock)                    |初始化mutex                                         |
|void mutex_lock(struct mutex *lock)             |获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。|
|void mutex_unlock(struct mutex *lock)           |释放 mutex，也就给 mutex 解锁。                      |
|int mutex_trylock(struct mutex *lock)           |尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。   |
|int mutex_is_locked(struct mutex *lock)         |判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。 |
|int mutex_lock_interruptible(struct mutex *lock)|使用此函数获取信号量失败进入休眠以后可以被信号打断。    |
##### 1.1.1.3 互斥体的使用如下
```c
struct mutex lock; /* 定义一个互斥体 */
mutex_init(&lock); /* 初始化互斥体 */

mutex_lock(&lock); /* 上锁 */
/* 临界区 */
mutex_unlock(&lock); /* 解锁 */
```

## 1.2 函数分析
### 1.2.1 alloc_pwms
函数：`static int alloc_pwms(int pwm, unsigned int count)`
作用：为编号值为`pwm`的pwmchip申请`count`个pwm编号。
```c
static int alloc_pwms(int pwm, unsigned int count)
{
    ······
    start = bitmap_find_next_zero_area(allocated_pwms, MAX_PWMS, from,
                        count, 0);

    //申请成功的条件：申请的pwm编号值需要大于零，且申请到的count个连续为0
    //的地址的起始索引`start`需要等于申请的pwm编号。
    //例如：有两个pwmchip，每个pwmchip有三路pwm输出，即（npwm），那么，第一个
    //pwm编号是0，申请的count值是3，返回的start值是0，相等，申请成功；
    //第二个pwm编号是2，申请的count值是3，返回的count值是2，相等，申请成功。
    if (pwm >= 0 && start != pwm)
        return -EEXIST;
    ······
    return start;
}
```
### 1.2.1 free_pwms
函数：`static void free_pwms(struct pwm_chip *chip)`
作用：释放pwmchip及其下面的pwm_device，还有pwmchip的pwm编号
```c
static void free_pwms(struct pwm_chip *chip)
{
    unsigned int i;

    //一个pwmchip下面可以有npwm个pwm_device
    for (i = 0; i < chip->npwm; i++) {
        struct pwm_device *pwm = &chip->pwms[i];
    
        //释放基数树中的pwmchip->pwms
        radix_tree_delete(&pwm_tree, pwm->pwm);
    }
    //清除pwmchip之前申请的npwm个pwm编号
    bitmap_clear(allocated_pwms, chip->base, chip->npwm);
    
    kfree(chip->pwms);
    chip->pwms = NULL;
}
```


