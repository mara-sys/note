### gpio.txt GPIO接口
&emsp;&emsp;此目录中的文档详细说明了如何访问驱动程序中的 GPIO，以及如何编写 GPIO 的设备驱动程序。  
&emsp;&emsp;由于内核中 GPIO 接口的历史，有两种不同的方式来获取和使用 GPIO：
* 基于描述符的接口是操作 GPIO 的首选方式，并且由该目录中除 gpio-legacy.txt 之外的所有文件进行描述。
* gpio-legacy.txt 中记录了被认为已弃用（但出于兼容性原因仍可使用）的旧式基于整数的接口。 
#### 1 什么是GPIO
&emsp;&emsp;“通用输入/输出”(GPIO) 是一种灵活的软件控制数字信号。许多芯片都提供GPIO，这对于使用嵌入式和定制硬件的 Linux 开发人员来说是很熟悉的。每个 GPIO 代表一个连接到特定引脚或球栅阵列 (BGA) 封装上的“球”的位。电路板原理图显示了哪些外部硬件连接到哪些 GPIO。可以编写通用驱动程序，以便板子设置代码将此类引脚的配置数据传递给驱动程序。  
&emsp;&emsp;片上系统 (SOC) 处理器严重依赖 GPIO。在某些情况下，每个非专用引脚都可以配置为 GPIO；大多数芯片至少有几十个GPIO。可编程逻辑器件（如 FPGA）可以轻松提供 GPIO；电源管理器和音频编解码器等多功能芯片通常有一些这样的引脚，以帮助解决 SOC 上的引脚稀缺问题；还有使用 I2C 或 SPI 串行总线连接的“GPIO 扩展器”芯片。大多数 PC 南桥都有几十个支持 GPIO 的引脚（只有 BIOS 固件知道它们是如何使用的）。     
&emsp;&emsp;GPIO 的确切功能因系统而异。常用选项：
* 输出值是可写的（高=1，低=0）。一些芯片还可以选择如何驱动该值，例如，可能只驱动一个值，支持“线或”和其他值的类似方案（特别是“开漏”信号）。
* 输入值同样可读 (1, 0)。一些芯片支持配置为“输出”的引脚回读，这在这种“线或”情况下非常有用（以支持双向信号）。 GPIO 控制器可能具有输入去毛刺/去抖动逻辑，有时带有软件控制。
* 输入通常可以用作 IRQ 信号，通常是边沿触发，但有时是电平触发。此类 IRQ 可配置为系统唤醒事件，以将系统从低功率状态唤醒。
* 通常，GPIO 可配置为输入或输出，根据不同产品板的需要；单向的也存在。
* 大多数 GPIO 可以在持有自旋锁时访问，但那些通过串行总线访问的通常不能。一些系统支持这两种类型。  

&emsp;&emsp;在给定的板上，每个 GPIO 都用于一个特定的目的，例如监控 MMC/SD 卡的插入/移除、检测卡写保护状态、驱动 LED、配置收发器、位冲击串行总线、戳硬件看门狗、感测一个开关，等等。
#### 2 GPIO的常用属性
&emsp;&emsp;这些属性都在GPIO接口的其他文档中实现，理解他们很有用，尤其是当您需要定义GPIO映射时。  
##### 2.1 高电平有效和低电平有效
将GPIO输出“1”（高电平）作为有效，输出“0”（低电平）作为无效是很自然的事情。然而，实际上，GPIO的输出信号可能在输出之前被反转，也可能由设备通过反转来决定“有效”的定义。这样的决定应该对驱动透明，因此无论GPIO是高有效还是低有效，驱动程序都只需要考虑逻辑信号，而不是线路级的事情。
##### 2.2 开漏和Open source
&emsp;&emsp;有时共享信号需要使用“开漏”（实际上只驱动低信号电平），或“开源”（仅驱动高信号平）信号。该术语适用于 CMOS 晶体管； “集电极开路”用于 TTL。上拉或下拉电阻导高或低信号电平。这有时被称为“线与”；或者更实际地，从否定逻辑（低=真）的角度看，这是一个“线或”。  
&emsp;&emsp;开漏信号的一个常见示例是共享的低电平有效 IRQ 线。此外，双向数据总线信号有时使用开漏信号。  
&emsp;&emsp;一些GPIO控制器直接支持开漏和开源输出；许多控制器不支持。当您需要开漏信号但您的硬件不直接支持它时，您可以使用一个常见的用法来使用任何可用作输入或输出的 GPIO 引脚来模拟它：
```
 LOW：gpiod_direction_output(gpio, 0) ...这会驱动信号并覆盖上拉。
 HIGH：gpiod_direction_input(gpio) ...这会关闭输出，因此上拉（或其他设备）控制信号。
```
&emsp;&emsp;可以应用相同的逻辑来模拟开源信号，通过驱动高电平信号并将 GPIO 配置为低电平输入来实现。这种开漏/开源仿真可以由 GPIO 框架透明地处理。  
&emsp;&emsp;如果您将信号“驱动”为高电平，但 gpiod_get_value(gpio) 报告一个低值（在适当的上升时间过去之后），您就知道某个其他组件正在将共享信号驱动为低电平。这不一定是错误。举一个常见的例子，这就是 I2C 时钟的延长方式：需要较慢时钟的从设备延迟 SCK 的上升沿，而 I2C 主设备相应地调整其信号速率。
### consumer.txt GPIO描述符消费者接口
&emsp;&emsp;本文档描述了 GPIO 框架的消费者接口。 请注意，它描述了新的基于描述符的接口。 有关已弃用的基于整数的 GPIO 接口的说明，请参阅 gpio-legacy.txt。  
#### 1 GPIO消费者指南
&emsp;&emsp;没有标准 GPIO 调用就无法工作的驱动程序应该具有依赖于 GPIOLIB 的 Kconfig 条目。 通过包含以下文件，来允许驱动程序获取和使用 GPIO 的函数：   
&emsp;&emsp;`#include <linux/gpio/consumer.h>`  
&emsp;&emsp;所有与基于描述符的 GPIO 接口一起使用的函数都以 gpiod_ 为前缀。 gpio_ 前缀用于旧接口。 内核中的任何其他函数都不应使用这些前缀。 
#### 2 获取和处理GPIO
&emsp;&emsp;使用基于描述符的接口，GPIO由不透明、不可伪造的handler来标识，该handler必须通过调用gpiod_get()系列函数中的一个来获得。像许多其他内核子系统一样， gpiod_get() 获取将使用 GPIO 的设备以及请求的 GPIO 应该完成的功能：  
```c
struct gpio_desc *gpiod_get(struct device *dev, const char *con_id, 
        enum gpiod_flags flags) 
```
&emsp;&emsp;如果一个功能是通过一起使用多个 GPIO 来实现的（例如一个显示数字的简单 LED 设备），则可以指定一个额外的索引参数： 
```c
struct gpio_desc *gpiod_get_index(struct device *dev, const char *con_id,
        unsigned int idx, enum gpiod_flags flags)
```
&emsp;&emsp;flags 参数用于选择性地指定 GPIO 的方向和初始值。值可以是：
* GPIOD_ASIS 或 0 不初始化GPIO. 稍后必须使用专用函数之一设置方向 .
* GPIOD_IN 初始化GPIO为输入.
* GPIOD_OUT_LOW 初始化GPIO为输出，输出0.
* GPIOD_OUT_HIGH 初始化GPIO为输出，输出1.  
  
&emsp;&emsp;这两个函数都返回一个有效的 GPIO 描述符，或者一个可通过 IS_ERR() 检查的错误代码（它们永远不会返回 NULL 指针）。 `-ENOENT`当且仅当没有 GPIO 分配给设备/功能/索引三元组时才会返回，其他错误代码用于已分配 GPIO 但在尝试获取它时发生错误的情况。 这对于区分纯错误和可选 GPIO 参数缺少 GPIO 很有用。 对于 GPIO 可选的常见模式，可以使用 `gpiod_get_optional()` 和 `gpiod_get_index_optional()` 函数。 如果未将 GPIO 分配给请求的函数，这些函数将返回 NULL 而不是 -ENOENT：
```c
struct gpio_desc *gpiod_get_optional(struct device *dev, 
        const char *con_id, enum gpiod_flags flags)
struct gpio_desc *gpiod_get_index_optional(struct device *dev, 
        const char *con_id, unsigned int index, enum gpiod_flags flags)
```
&emsp;&emsp;对于使用多个 GPIO 的函数，所有这些都可以通过一次调用获得： 
```c
struct gpio_descs *gpiod_get_array(struct device *dev, const char *con_id,
					   enum gpiod_flags flags)
```
&emsp;&emsp;此函数返回一个结构 gpio_descs，此结构包含一个描述符数组： 
```c
struct gpio_descs { 
    unsigned int ndescs;
	struct gpio_desc *desc[]; 
    }
```
&emsp;&emsp;如果没有 GPIO 分配给请求的函数，以下函数返回 NULL 而不是 -ENOENT： 
```c
struct gpio_descs *gpiod_get_array_optional(struct device *dev, 
        const char *con_id, enum gpiod_flags flags)
```
&emsp;&emsp;还定义了这些功能的设备管理变体：
```c
struct gpio_desc *devm_gpiod_get(struct device *dev, 
        const char *con_id, enum gpiod_flags flags)
struct gpio_desc *devm_gpiod_get_index(struct device *dev, 
        const char*con_id, unsigned int idx, enum gpiod_flags flags)
struct gpio_desc *devm_gpiod_get_optional(struct device *dev, 
        const char *con_id, enum gpiod_flags flags)
struct gpio_desc *devm_gpiod_get_index_optional(struct device *dev, 
        const char *con_id, unsigned int index, enum gpiod_flags flags)
struct gpio_descs *devm_gpiod_get_array(struct device *dev, 
        const char *con_id, enum gpiod_flags flags)
struct gpio_descs *devm_gpiod_get_array_optional(struct device *dev,
        const char *con_id, enum gpiod_flags flags)
```
&emsp;&emsp;可以使用 gpiod_put() 函数处理 GPIO 描述符： 
```c
void gpiod_put(struct gpio_desc *desc)
```
&emsp;&emsp;对于 GPIO 数组，可以使用此函数：
```c
void gpiod_put_array(struct gpio_descs *descs)
```
&emsp;&emsp;严禁在调用这些函数后使用描述符。 也不允许从使用 gpiod_get_array() 获取的数组中单独释放描述符（使用 gpiod_put()）。 
&emsp;&emsp;不出所料，设备管理的变体是： 
```c
void devm_gpiod_put(struct device *dev, struct gpio_desc *desc)
void devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)
```

#### 3 使用GPIOs
##### 3.1 设置方向
&emsp;&emsp;驱动程序必须对 GPIO 做的第一件事是设置其方向。 如果没有给 gpiod_get*() 提供方向设置标志，可以通过调用 gpiod_direction_*() 函数之一来完成： 
```c
int gpiod_direction_input(struct gpio_desc *desc) 
int gpiod_direction_output(struct gpio_desc *desc, int value) 
```
&emsp;&emsp;成功时返回值为零，否则为负 errno。 应该检查返回值，因为 get/set 调用不会返回错误，因此可能配置错误。 您通常应该从任务上下文发起这些调用。 但是，作为早期电路板设置的一部分，对于自旋锁安全的 GPIO，在使能任务之前调用它们也是可以的。   
&emsp;&emsp;对于输出 GPIO，提供的值成为初始输出值。 这有助于避免系统启动期间的信号故障。   
&emsp;&emsp;驱动程序还可以查询 GPIO 的当前方向：
```c
int gpiod_get_direction(const struct gpio_desc *desc)
```
&emsp;&emsp;此函数将返回 `GPIOF_DIR_IN` 或` GPIOF_DIR_OUT`。  
&emsp;&emsp;请注意，GPIO 没有默认方向。 因此，**使用 GPIO 而不先设置其方向是非法的，将导致未定义的行为！** 
##### 3.2 自旋锁安全 GPIO 访问 
&emsp;&emsp;大多数 GPIO 控制器都可以通过内存读/写指令进行访问。 那些不需要休眠，并且可以从硬（非线程）IRQ 处理程序和类似上下文中安全地完成。  
&emsp;&emsp;使用以下调用从原子上下文访问 GPIO： 
```c
int gpiod_get_value(const struct gpio_desc *desc);
void gpiod_set_value(struct gpio_desc *desc, int value);
```
&emsp;&emsp;值是布尔值，零表示低，非零表示高。 读取输出引脚的值时，返回的值应该是在引脚上看到的值。 由于开漏信号和输出延迟等问题，这并不总是与指定的输出值匹配。  
&emsp;&emsp;get/set 调用不会返回错误，因为应该更早从 gpiod_direction_*() 报告“无效的 GPIO”。 但是，请注意并非所有平台都可以读取输出引脚的值； 那些不能的应该总是返回零。 此外，将这些调用用于在不休眠的情况下无法安全访问的 GPIO（见下文）是一个错误。 
##### 3.3 GPIO访问时可能休眠
&emsp;&emsp;某些 GPIO 控制器必须使用基于消息的总线（如 I2C 或 SPI）进行访问。 读取或写入这些 GPIO 值的命令需要等待到达队列的头部以传输命令并获得其响应。 这需要休眠，而不能从 IRQ 处理程序内部完成。  
&emsp;&emsp;支持这种类型的 GPIO 的平台通过从这个调用中返回非零值来将它们与其他 GPIO 区分开来：
```c
int gpiod_cansleep(const struct gpio_desc *desc)
```
&emsp;&emsp;为了访问此类 GPIO，定义了一组不同的访问器： 
```c
int gpiod_get_value_cansleep(const struct gpio_desc *desc)
void gpiod_set_value_cansleep(struct gpio_desc *desc, int value)
```


## RTC
&emsp;&emsp;闰年：规定，每四年一个闰年，但是遇到整百的倍数时，不是400的倍数的就是平年，是400的倍数就是闰年。  
&emsp;&emsp;原因：
* 四年一闰：一个回归年大约等于365.24220日。因为在平年公历只计算365日，结果四年后便会累积0.24220*4=0.9688日，大约等于一日，所以便逢四年增加一日闰日以抵销这0.9688日。
* 百年不闰：每四年一个闰年计算，平均每年就要多算出0.0078天，这样经过四百年就会多算出大约3天来，因此，每四百年中要减少三个闰年。  
### 1 rtc.txt linux的RTC驱动
&emsp;&emsp;当 Linux 开发人员谈论“实时时钟”时，他们通常指的是可以跟踪挂钟时间并由电池供电的东西，因此即使系统断电也能正常工作。 此类时钟通常不会跟踪本地时区或夏令时，而是将设置成协调世界时间（UTC，以前称为“格林威治标准时间”），除非它们与 MS-Windows 双启动。  
&emsp;&emsp;最新的非 PC 硬件往往只计算秒数，如 time(2) 系统调用报告，但 RTC 也非常普遍地使用公历和 24 小时时间表示时间，如 gmtime(3) 报告的那样。  
&emsp;&emsp;Linux 有两个高度兼容的用户空间 RTC API 系列，您可能需要了解：
* /dev/rtc ... 是 PC 兼容系统提供的 RTC，因此对于非 x86 系统不是很适应.
* /dev/rtc0, /dev/rtc1 ... 是所有系统上各种 RTC 芯片支持的框架的一部分 .

&emsp;&emsp;程序员需要了解 PC/AT 功能并不总是可用的，有些系统可以做的更多。 也就是说，RTC 使用相同的 API 在两个 RTC 框架中发出请求（当然使用不同的文件名），但硬件可能不提供相同的功能。 例如，并非每个 RTC 都连接到一个 IRQ，因此它们不能都发出警报； 标准 PC RTC 只能在未来 24 小时内发出警报，而其他硬件可能能够在下个世纪的任何时间安排警报。   
#### 1.1 旧的 PC/AT 兼容驱动程序：/dev/rtc 
&emsp;&emsp;所有 PC（甚至 Alpha 机器）都内置有实时时钟。通常它们内置在计算机的芯片组中，但有些实际上可能在板上安装（或克隆）了摩托罗拉 MC146818。这是在计算机关闭时维持日期和时间的时钟。  
&emsp;&emsp;ACPI 已对 MC146818 功能进行了标准化，并以几种方式对其进行了扩展（启用更长的警报周期和从休眠状态唤醒）。该功能未在旧驱动程序中公开。  
&emsp;&emsp;然而，它也可以用于生成从慢 2Hz 到相对较快 8192Hz 的信号，以 2 的幂为增量。这些信号由中断号 8 报告。（哦！所以这就是 IRQ 8 的用途......）它也可以用作 24 小时警报，当警报响起时引起 IRQ 8。闹钟也可以设置为仅检查三个编程值的任何一个，这意味着它可以设置为例如在每小时的第 30 分钟的第 30 秒响铃。时钟也可以设置为在每次时钟更新时产生中断，从而产生 1Hz 信号。    
&emsp;&emsp;中断通过 /dev/rtc（主要 10，次要 135，只读字符设备）以 unsigned long 的形式报告。低字节包含引发的中断类型（更新完成、警报范围或周期性），其余字节包含自上次读取以来的中断数。如果 /proc 文件系统已启用，状态信息将通过伪文件 /proc/driver/rtc 报告。驱动程序内置了锁定功能，因此一次只允许一个进程打开 /dev/rtc 接口。  
&emsp;&emsp;用户进程可以通过在 /dev/rtc 上执行 read(2) 或 select(2) 来监视这些中断——要么将阻止/停止用户进程直到收到下一个中​​断。这对于诸如不希望通过轮询 gettimeofday 等来消耗 100% CPU 的合理高频数据采集之类的事情很有用。  
&emsp;&emsp;在高频率或高负载下，用户进程应该检查自上次读取以来接收到的中断数量，以确定是否有任何中断“堆积”。仅供参考，对于 1024Hz 以上的频率，在典型的 486-33 上的/dev/rtc 上运行紧密读取循环将开始遇到偶尔的中断堆积（即自上次读取以来 > 1 个 IRQ 事件）。所以你真的应该检查你读取的值的高字节，尤其是在高于正常定时器中断频率（100Hz）的情况下。     
&emsp;&emsp;只有 root 才允许编程和/或启用大于 64Hz 的中断频率。这可能有点保守，但我们不希望邪恶的用户在缓慢的 386sx-16 上生成大量 IRQ，这可能会对性能产生负面影响。可以通过向 /proc/sys/dev/rtc/max-user-freq 写入不同的值来更改此 64Hz 限制。请注意，中断处理程序只有几行代码，可以最大限度地减少这种影响的可能性。  
&emsp;&emsp;此外，如果内核时间与外部源同步，内核将每 11 分钟将时间写回 CMOS 时钟。在执行此操作的过程中，内核会暂时关闭 RTC 周期性中断，因此如果您正在认真工作，请注意这一点。如果您不将内核时间与外部源（通过 ntp 或其他方式）同步，那么内核将远离 RTC，允许您的应用程序独占访问设备。  
&emsp;&emsp;警报和/或中断频率通过 ./include/linux/rtc.h 中列出的各种 ioctl(2) 调用被编程到 RTC 中而不是写 50 页描述 ioctl() 等。包含一个演示如何使用它们的小测试程序，并演示驱动程序的功能可能更有用。对于有兴趣编写将使用此驱动程序的应用程序的人来说，这可能更有用。请参阅本文档末尾的代码。 
#### 1.2 新的便携式“RTC 类”驱动程序：/dev/rtcN 
&emsp;&emsp;由于 Linux 支持许多非 ACPI 和非 PC 平台，其中一些平台具有不止一个 RTC 样式的时钟，因此它需要一种更便携的解决方案，而不是期望每个系统上都有一个由电池供电的 MC146818 克隆。 因此，定义了一个新的“RTC 类”框架。 它提供了三种不同的用户空间界面： 
* /dev/rtcN ... 和旧的 /dev/rtc 接口差不多
* /sys/class/rtc/rtcN ... sysfs 属性支持对某些 RTC 属性的只读访问。 .
* /proc/driver/rtc ... 系统时钟 RTC 可能会使用 procfs 接口暴露自己。 如果系统时钟没有 RTC，则默认使用 rtc0。 此处显示的信息比通过 sysfs 显示的信息更多。 

&emsp;&emsp;RTC 类框架支持各种 RTC，从集成到嵌入式片上系统 (SOC) 处理器的 RTC 到使用 I2C、SPI 或其他一些总线与主机 CPU 通信的离散芯片。 甚至支持 PC 风格的 RTC……包括通过 ACPI 在较新的 PC 上公开的功能。
&emsp;&emsp;新框架还取消了“每个系统一个 RTC”的限制。 例如，低功耗电池支持的 RTC 可能是一个分立的 I2C 芯片，但高性能 RTC 集成到 SOC 中。 该系统可能会从分立式 RTC 读取系统时钟，但使用集成式 RTC 执行所有其他任务，因为它具有更强大的功能。
&emsp;&emsp;**查看 tools/testing/selftests/timers/rtctest.c 以获取 ioctl 接口的示例用法**。

### 2 rtctest.c文件解析
1. 首先对命令行输入参数进行判断，如果只有一个参数，即rtctest.c编译的可执行文件名，如`rtctestApp`，那么默认使用`/dev/rtc0`，如果有两个参数，那么第二个参数是rtc的设备名，如`/dev/rtc3`。如果有三个参数，第三个参数应该是`d`。


### 3 module
#### 3.1 fprintf()函数
&emsp;&emsp;fprintf是C/C++的一个格式化库函数，位于头文件<stdio.h>中，函数原型如下：
```c
int fprintf( FILE *stream, const char *format, [ argument ]...)
```
&emsp;&emsp;fprintf()函数根据指定的格式（format），向输出流（stream）写入数据（argument）。
&emsp;&emsp;stream可以stdout，stderr或者指定的文件。（stdin是标准输入，stdout是标准输出，stderr是标准错误输出）。
示例：
```c
fprintf(stderr, "usage:  rtctest [rtcdev] [d]\n");
```
示例：
```c
FILE *in;
in = fopen("\\AUTOEXEC.BAT", "rt");
fprintf(in, "Can not open inputfile.\n");
```
#### 3.2 sscanf()函数
&emsp;&emsp;从字符串读取格式化输入，函数原型如下：
```c
int sscanf(const char *str, const char *format, ...)
```
示例：
```c
const char* g_TestUtcDate = "2021-10-11";
const char* g_TestUtcTime = "19:54:30";
int year, month, day, hour, minute, second;
sscanf(g_TestUtcDate, "%d-%d-%d",  &year, &month, &day);
sscanf(g_TestUtcTime, "%d:%d:%d",  &hour, &minute, &second); 
```
#### 3.3 sprintf()函数
&emsp;&emsp;sprintf()函数主要是把格式化的数据写入某个字符串中，位于头文件<stdio.h>中，函数原型如下：
```c
int sprintf(char *string, char *format [,argument,...]);
```
&emsp;&emsp;参数列表：
* string：这是指向一个字符数组的指针，该数组存储了C字符串。
* format：这是字符串，包含了要被写入到字符串str的文本。它可以包含嵌入了format的标签，format标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format的标签属性是`%[flags][width][.precision][length]specifier`。
* argument：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。

示例：
```c
void main(int argc, char **argv)
{
	char path[256];
	sprintf(path, "dev/%s", argv[1]);

	return 0;
}
```

#### 3.4 perror()函数
&emsp;&emsp;perror()函数用于抛出最近的一次系统错误信息，位于头文件<stdio.h>中，函数原型如下：
```c
void perror(char *string);
```
&emsp;&emsp;perror()用来将上一个函数发生错误的原因输出到标准错误(stderr)。参数string所指的字符串会先打印出，后面再加上错误原因字符串，此错误原因依照全局变量errno 的值来决定要输出的字符串。  
&emsp;&emsp;在库函数中有个errno变量，每个errno值对应着以字符串表示的错误类型。当你调用"某些"函数出错时，该函数已经重新设置了errno的值。perror函数只是将你输入的一些信息和现在的errno所对应的错误一起输出。  
示例：
```c
FILE *fp;

/* 打开一个不存在的文件 */
fp = fopen("file.txt", "r");
if( fp == NULL ) {
    perror("Error: ");
    return(-1);
}
```
&emsp;&emsp;将会输出下面的结果：
```shell
Error: : No such file or directory
```



### 4 rtc-lib.c文件分析
&emsp;&emsp;这个文件是时间计算的一些函数，从以秒为单位的时间转换到年月日为单位的结构体中。
* `rtc_days_in_month`定义了每个月份的天数
* `rtc_ydays`定义了平年和闰年每个月份的结束的总天数
* `LEAPS_THRU_END_OF`计算从0000年开始到y年一共闰了多少天
```c
#define LEAPS_THRU_END_OF(y) ((y)/4 - (y)/100 + (y)/400)
```
* `rtc_month_days`输入月份和年份，返回当月的天数
* `rtc_year_days`输入年月日，返回该日期在当年的总天数，月份输入的是0-13。
* `rtc_time64_to_tm`时间转换函数，这个.c文件的核心。
```c
struct rtc_time {
	int tm_sec;  //秒
	int tm_min;  //分
	int tm_hour; //时
	int tm_mday; //该月的第几天
	int tm_mon;  //月
	int tm_year; //年
	int tm_wday; //该周的第几天
	int tm_yday; //当年的第几天
	int tm_isdst;//
};

typedef __s64 time64_t;

/*
 * rtc_time_to_tm64 - Converts time64_t to rtc_time.
 * Convert seconds since 01-01-1970 00:00:00 to Gregorian date.
 */
void rtc_time64_to_tm(time64_t time, struct rtc_time *tm)
{
	unsigned int month, year, secs;
	int days;

	/* time must be positive */
    //用秒数除以每天的秒数，得到从1970年到现在一共多少天了，
    //剩余的秒数存储在secs中
	days = div_s64_rem(time, 86400, &secs);

	/* day of the week, 1970-01-01 was a Thursday */
    //计算星期几
	tm->tm_wday = (days + 4) % 7;

    /* 在下面这段程序中，首先按一年365天计算一共有多少年，
     * 加上1970得到年份。
     * 再通过宏定义计算从00年到该年份一共闰了多少天，
     * 再通过宏定义计算从00年到1969年一共闰了多少天，
     * 两次宏定义的结果相减得到从1970年到该年份一共闰了多少天。
     * 用(year - 1970) * 365 + 两次宏定义之差，得到按365一年计算出来的年份来算
     * 实际该有多少天
     */
	year = 1970 + days / 365;
	days -= (year - 1970) * 365
		+ LEAPS_THRU_END_OF(year - 1)
		- LEAPS_THRU_END_OF(1970 - 1);
	while (days < 0) {
		year -= 1;
		days += 365 + is_leap_year(year);
	}
	tm->tm_year = year - 1900;//得到的年份时从1900年开始一共过了多少年，
                              //例如2001年就是101
	tm->tm_yday = days + 1;

	for (month = 0; month < 11; month++) {
		int newdays;

		newdays = days - rtc_month_days(month, year);
		if (newdays < 0)
			break;
		days = newdays;
	}
	tm->tm_mon = month;
	tm->tm_mday = days + 1;

	tm->tm_hour = secs / 3600;
	secs -= tm->tm_hour * 3600;
	tm->tm_min = secs / 60;
	tm->tm_sec = secs - tm->tm_min * 60;

	tm->tm_isdst = 0;
}
EXPORT_SYMBOL(rtc_time64_to_tm);
```
* `rtc_valid_tm`判断得到的时间是否有效
* `rtc_tm_to_time64`将年月日为单位的结果改为按秒计数的结果
* `rtc_tm_to_ktime`将年月日为单位的结果改为按纳秒计数的结果
* `rtc_ktime_to_tm`将纳秒计数的结果改为年月日为单位的结果



## watchdog
### wdt文档
看门狗的文档结构如下：
```shell
Documentation
    -->watchdog-->watchdog-kernel-api.txt
    -->watchdog-->watchdog-api.txt
drivers
    -->watchdog-->watchdog_dev.c
    -->watchdog-->watchdog_core.c
    -->watchdog-->watchdog_core.h
    -->watchdog-->dw_wdt.c（具体的驱动文件，这里是新思的）
include
    -->linux-->watchdog.h
```
#### 1 watchdog-api.txt
##### 1.1 介绍
&emsp;&emsp;看门狗定时器 (WDT) 是一种硬件电路，可以在出现软件故障时重置计算机系统。 你可能已经知道了。  
&emsp;&emsp;通常，用户空间守护进程会定期通过 /dev/watchdog 特殊设备文件通知内核看门狗驱动程序用户空间仍处于活动状态。 当出现这样的通知时，驱动程序通常会告诉硬件看门狗一切正常，看门狗应该再等待一段时间来重置系统。 如果用户空间失败（RAM 错误、内核错误等），通知将停止发生，并且硬件看门狗将在超时发生后重置系统（导致重新启动）。 
&emsp;&emsp;Linux 看门狗 API 是一种相当特殊的结构，不同的驱动程序实现了其中的不同部分，有时甚至是不兼容的部分。该文件试图记录现有用法并允许未来的驱动程序编写者将其用作参考。  
##### 1.2 最简单的API
&emsp;&emsp;所有驱动程序都支持基本的操作模式，当 /dev/watchdog 打开时，看门狗会立即激活，除非在一定时间内 ping 看门狗，否则将重新启动，这个时间称为超时或余量。 ping 看门狗的最简单方法是向设备写入一些数据。 所以一个非常简单的看门狗守护进程看起来像这个源文件：参见 samples/watchdog/watchdog-simple.c   
&emsp;&emsp;例如，更高级的驱动程序可以在执行写入调用以 ping 看门狗之前检查 HTTP 服务器是否仍在响应。 
&emsp;&emsp;当设备关闭时，看门狗被禁用，除非支持“魔术关闭”功能（见下文）。 这并不总是一个好主意，因为如果看门狗守护程序中存在错误并且它崩溃，系统将不会重新启动。 因此，一些驱动程序支持配置选项“关闭时禁用看门狗关闭”，CONFIG_WATCHDOG_NOWAYOUT。 如果在编译内核时设置为Y，则一旦启动就无法禁用看门狗。 因此，如果看门狗守护进程崩溃，系统将在超时过后重新启动。 看门狗设备通常也支持nowayout 模块参数，以便可以在运行时控制此选项。  
##### 1.3 魔数关闭功能 
&emsp;&emsp;如果驱动程序支持“魔术关闭”，则驱动程序不会禁用看门狗，除非在关闭文件之前将特定的魔术字符“V”发送到 /dev/watchdog。 如果用户空间守护进程在没有发送这个特殊字符的情况下关闭文件，驱动程序将假定守护进程（以及一般的用户空间）死亡，并且将停止 ping 看门狗而不先禁用它。 如果看门狗没有在足够的时间内重新打开，这将导致重新启动。  
##### 1.4 ioctl API
&emsp;&emsp;所有符合要求的驱动程序也支持 ioctl API。
###### 1.4.1 使用 ioctl ping 看门狗
&emsp;&emsp;所有具有 ioctl 接口的驱动程序都至少支持一个 ioctl，KEEPALIVE。 这个 ioctl 做的事情和写看门狗设备完全一样，所以上面程序中的主循环可以替换为： 
```c
while (1) {
	ioctl(fd, WDIOC_KEEPALIVE, 0);
	sleep(10);
}
```
&emsp;&emsp;ioctl 的参数被忽略。  

###### 1.4.2 设置和获取超时
&emsp;&emsp;对于某些驱动程序，可以使用 SETTIMEOUT ioctl 动态修改看门狗超时，这些驱动程序在其选项字段中设置了 WDIOF_SETTIMEOUT 标志。 参数是一个整数，以秒为单位表示超时。 驱动程序返回在同一变量中使用的实际超时，**由于硬件限制，该超时可能与请求的超时不同**。 
```c
int timeout = 45;
ioctl(fd, WDIOC_SETTIMEOUT, &timeout);
printf("The timeout was set to %d seconds\n", timeout);
```
&emsp;&emsp;如果设备的超时粒度为分钟，则此示例实际上可能会打印“超时设置为 60 秒”。
&emsp;&emsp;从 Linux 2.4.18 内核开始，可以使用 GETTIMEOUT ioctl 查询当前超时。 
```c
ioctl(fd, WDIOC_GETTIMEOUT, &timeout);
printf("The timeout was is %d seconds\n", timeout);
```
###### 1.4.3 超时
&emsp;&emsp;一些看门狗定时器可以设置为：在它们重置系统的实际时间之前，触发一个trigger。 这可以通过 NMI、中断或其他机制来完成。 这允许 Linux 在重置之前记录有用的信息（如panic information和kernel coredumps）。 
```c
pretimeout = 10;
ioctl(fd, WDIOC_SETPRETIMEOUT, &pretimeout);
```
&emsp;&emsp;请注意，pretimeout 是超时时间之前的秒数。 它不是预超时的秒数。 因此，例如，如果您将超时设置为 60 秒并将预超时设置为 10 秒，则预超时将在 50 秒后触发。 将预超时设置为零会禁用它。
&emsp;&emsp;还有一个用于获取预超时的 get 函数： 
```c
ioctl(fd, WDIOC_GETPRETIMEOUT, &timeout);
printf("The pretimeout was is %d seconds\n", timeout);
```
&emsp;&emsp;并非所有看门狗驱动程序都支持预超时。
&emsp;&emsp;获取重启前的秒数：
&emsp;&emsp;某些看门狗驱动程序能够报告系统重新启动之前的剩余时间。 WDIOC_GETTIMELEFT 是返回重启前秒数的 ioctl。 
```c
ioctl(fd, WDIOC_GETTIMELEFT, &timeleft);
printf("The timeout was is %d seconds\n", timeleft);
```
###### 1.4.4 环境监测
&emsp;&emsp;所有看门狗驱动程序都需要返回有关系统的更多信息，有些会进行温度、风扇和功率级别的监控，有些可以告诉您上次重新启动系统的原因。 GETSUPPORT ioctl 可用于询问设备可以做什么： 
```c
struct watchdog_info ident;
ioctl(fd, WDIOC_GETSUPPORT, &ident);
```
&emsp;&emsp;ident 结构中返回的字段是：
```shell
identity 标识看门狗驱动程序的字符串
firmware_version 卡的固件版本（如果可用）
options 描述设备支持的标志 
```
&emsp;&emsp;options 字段可以设置以下位，并且 ioctls 可以 通过GET_STATUS 和 GET_BOOT_STATUS 返回的描述的信息类型。 [修正——这是正确的吗？] 
```shell
WDIOF_OVERHEAT   由于CPU过热而复位。机器上次由看门狗重新启动，因为超出了热限制 
WDIOF_FANFAULT   风扇故障。看门狗板卡监控的系统风扇出现故障 
WDIOF_EXTERN1    外部继电器1。外部监控继电器/源1被触发。 
                 用于实际应用的控制器包括将触发复位的外部监控引脚。 
WDIOF_EXTERN2    外部继电器2。外部监控继电器/源2被触发。
WDIOF_POWERUNDER 电源损坏/电源故障。机器显示低压状态
WDIOF_CARDRESET  板子先前复位了CPU。上次重启是看门狗板卡引起的 
WDIOF_POWEROVER  电源过压。机器显示高压状态。请注意，如果低压和高压位同时被设置  
                 了，这可能看起来有点奇怪，但是是有理由的。
WDIOF_KEEPALIVEPING 保持活跃 ping 回复。自上次查询以来，看门狗看到了一个  
                    keepalive ping。 
WDIOF_SETTIMEOUT 可以设置/获取超时时间 
```
&emsp;&emsp;对于那些返回option字段中bit位的驱动程序，可以使用 GETSTATUS 和 GETBOOTSTATUS 的ioctls 分别询问当前状态和上次重新启动时的状态。 
```c
int flags;
ioctl(fd, WDIOC_GETSTATUS, &flags);
ioctl(fd, WDIOC_GETBOOTSTATUS, &flags);
```
&emsp;&emsp;注意并不是所有的设备都支持这两种调用，有的只支持GETBOOTSTATUS调用。  
&emsp;&emsp;某些驱动程序可以使用 GETTEMP ioctl 测量温度。 返回值是以华氏度为单位的温度。 
```c
int temperature;
ioctl(fd, WDIOC_GETTEMP, &temperature);
```
&emsp;&emsp;最后，SETOPTIONS 的 ioctl 可用于控制板卡的某些操作。 
```c
int options = 0;
ioctl(fd, WDIOC_SETOPTIONS, &options);
```
&emsp;&emsp;以下选项可用：
```shell
WDIOS_DISABLECARD 关闭看门狗定时器
WDIOS_ENABLECARD 打开看门狗定时器
WDIOS_TEMPPANIC 温度跳闸时内核panic
```

#### 2 watchdog-kernel-api.txt
##### 2.1 介绍
&emsp;&emsp;它描述了想要使用看门狗框架的看门狗驱动可以使用的 API。 该框架提供了面向用户空间的所有接口，因此不必每次都复制相同的代码。 这也意味着看门狗驱动只需要提供控制看门狗的不同实现（操作）。 
##### 2.1 API
&emsp;&emsp;每个想要使用看门狗框架的驱动都要包含头文件<linux/watchdog.h>（无论何时编写看门狗驱动都要这么做）。此头文件包含了下列register/unregister函数：
```c
extern int watchdog_register_device(struct watchdog_device *);
extern void watchdog_unregister_device(struct watchdog_device *);
```
&emsp;&emsp;watchdog_register_device 例程注册一个看门狗定时器设备。该例程的参数是一个指向 watchdog_device 的指针。
&emsp;&emsp;此例程在成功时返回零，失败时返回负的 errno 代码。  
&emsp;&emsp;watchdog_unregister_device 例程unregister已注册的看门狗定时器设备。 该例程的参数是指向已注册 watchdog_device 的指针。 
&emsp;&emsp;看门狗子系统包括注册延迟机制，它允许您在引导过程中尽早注册看门狗。
&emsp;&emsp;`watchdog_device`结构体如下：
```c
struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	unsigned long status;
	struct list_head deferred;
};
```
它包含了下面的字段：
* id：由 watchdog_register_device 设置，id 0 是特殊的。 它既有 /dev/watchdog0 cdev（动态的主设备号，次设备号是 0），也有旧的 /dev/watchdog miscdev。调用 watchdog_register_device 时会自动设置 id。 
* parent：在调用 watchdog_register_device 之前将其指向父设备（或 NULL）。 
* groups：创建看门狗设备时要创建的 sysfs attribute groups。 
* info：一个指向watchdog_info结构体的指针。这个结构体给出了关于看门狗自身的一些信息（例如它特有的名字）。
* ops：一个指向看门狗支持的操作集合的指针。
* gov：指向分配的看门狗pretimeout控制器的指针，或者为NULL。
* timeout：看门狗的超时时间（以秒为单位）。如果WDOG_ACTIVE被设置，且在此时间之内，没有喂狗，那么在此时间之后系统将会重启。
* pretimeout：看门狗的pretimeout（预超时）时间（以秒为单位）。
* min_timeout：看门狗最小超时时间（以秒为单位）。如果设置了此参数，那么此值是`timeout`可配置的最小值。
* max_timeout：从用户空间看到的，看门狗最大超时时间（以秒为单位）。如果设置了此参数，那么此值是`timeout`可配置的最大值。如果 max_hw_heartbeat_ms 非零，则不使用。 
* min_hw_heartbeat_ms：心跳之间最短时间的硬件限制，以毫秒为单位。该值通常为 0；只有当硬件不能容忍心跳之间的较低间隔时才应该提供它。 
* max_hw_heartbeat_ms：最大硬件心跳，以毫秒为单位。如果设置了此参数，且`timeout`大于`max_hw_heartbeat_ms`，那么infrastructure将会发送心跳给看门狗驱动。如果设置了WDOG_ACTIVE并且用户空间在至少“timeout”秒内未能发送心跳，那么infrastructure将不会发送心跳。 **如果驱动程序没有实现停止功能，则必须设置 max_hw_heartbeat_ms**。 
* reboot_nb：为<u>重启通知</u>注册的通知程序块，仅供内部使用。如果驱动调用watchdog_stop_on_reboot，看门狗内核将在收到此类通知时停止看门狗。 
* restart_nb：为机器重启注册的通知程序块，仅供内部使用。 如果看门狗能够重启机器，它应该定义 ops->restart。 可以通过 watchdog_set_restart_priority 更改优先级。 
* bootstatus：设备启动后的状态（用看门狗 WDIOF_* 状态位报告）。 
* driver_data：指向看门狗设备的驱动程序私有数据的指针。 该数据只能通过 watchdog_set_drvdata 和 watchdog_get_drvdata 函数访问。 
* wd_data：看门狗内核内部数据的指针。 
* status：该字段包含许多状态位，提供有关设备状态的额外信息（例如：看门狗定时器是否正在运行/活动，或者是否设置了 nowayout 位）。 
* deferred：wtd_deferred_reg_list 中的条目，用于注册早期初始化的看门狗。 

&emsp;&emsp;看么狗`operations`结构体如下：
```c
struct watchdog_ops {
	struct module *owner;
	/* mandatory operations */
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	/* optional operations */
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *);
	void (*ref)(struct watchdog_device *) __deprecated;
	void (*unref)(struct watchdog_device *) __deprecated;
	long (*ioctl)(struct watchdog_device *, unsigned int, unsigned long);
};
```
&emsp;&emsp;先定义看门狗驱动程序的operatins的模块所有者很重要。当看门狗处于活动状态时，此模块所有者将用于锁定模块。（这是为了避免在卸载模块并且 /dev/watchdog 仍然打开时系统崩溃）。
&emsp;&emsp;有些操作是强制性的，有些是可选的。 强制性操作是：
* start：这是一个指向启动看门狗设备函数的指针。此函数需要一个指向watchdog_device结构体的指针。如果操作成功返回0，操作失败返回负的error。

&emsp;&emsp;不是所有的看门狗硬件都支持同样的功能。这就是为什么别的所有的函数/操作都是可选的原因。它们只需在它们支持相应的功能时提供相应的函数。这些可选的函数是：
* stop：此函数停止看门狗设备。此函数需要一个指向watchdog_device结构体的指针。如果操作成功返回0，操作失败返回负的error。有些看门狗定时器硬件只能启动不能停止。 支持此类硬件的驱动程序不必实现stop函数。如果驱动没有停止功能，看门狗内核会设置WDOG_HW_RUNNING，并在看门狗设备关闭后开始调用驱动的keepalive pings函数。**如果看门狗驱动没有实现停止功能，则必须设置max_hw_heartbeat_ms**。
* ping：这是向看门狗硬件发送keepalive ping的函数。此函数需要一个指向watchdog_device结构体的指针。如果操作成功返回0，操作失败返回负的error。大多数硬件不支持将此函数作为启动看门狗的单独（separate）的函数。此功能是看门狗驱动core所做的：向看门狗定时器硬件发送一个保持活动的 ping，它将使用 ping 操作（当可用时）或启动操作（当 ping 操作不可用时）。（注意：WDIOC_KEEPALIVE ioctl 调用仅在看门狗信息结构的选项字段中设置了WDIOF_KEEPALIVEPING位时才会激活）。
* status：此函数检查看门狗设备的状态。设备的状态通过看门狗的WDIOF_*状态位报告。WDIOF_MAGICCLOSE 和 WDIOF_KEEPALIVEPING 由看门狗内核报告;由驱动报告的这些位不重要。此外，如果驱动程序未提供状态函数，则看门狗内核会报告 struct watchdog_device 的 bootstatus 变量中提供的状态位。 
* set_timeout：此函数检查并改变看门狗设备的`timeout`。如果设置成功，此函数返回0，如果设置的参数值超出范围返回`-EINVAL`，如果无法将参数写入看门狗返回`_EIO`。如果设置成功的话，此函数应该将看门狗设备的超时时间设置为`可设置`的值（可能与请求的值不同，因为看门狗不一定具有1秒的分辨率）。
  &emsp;&emsp;实现 max_hw_heartbeat_ms 的驱动程序将硬件看门狗心跳设置为 timeout 和 max_hw_heartbeat_ms 中的最小值。这些驱动程序将 watchdog_device 的超时值设置为请求的超时值（如果它大于 max_hw_heartbeat_ms）或可设置的超时值。（注意： WDIOF_SETTIMEOUT 需要在看门狗的信息结构的选项字段中设置）。 
  &emsp;&emsp;如果看门狗驱动除了设置`watchdog_device.timeout`之外无需执行任何操作，则可以省略此回调函数。
  &emsp;&emsp;如果没有提供set_timeout，但是设置了WDIOF_SETTIMEOUT，看门狗infrastructure会在内部将watchdog_device的`timeout`的值更新为请求的值。
  &emsp;&emsp;如果使用了pretimeout功能(WDIOF_PRETIMEOUT)，则 set_timeout 还必须检查 pretimeout 是否仍然有效并相应地设置计时器。这不能在没有races的情况下在core中完成，所以这是驱动需要负责的事情。
* set_pretimeout：此函数检查并改变看门狗的`pretimeout`的值。此函数是可选的，因为并不是所有的看门狗都支持pretimeout的通知。`pretimeout`值不是一个绝对时间值，而是`timeout`之前的时间值。如果设置成功，此函数返回0，如果设置的参数值超出范围返回`-EINVAL`，如果无法将参数写入看门狗返回`_EIO`。如果`pretimeout`值是0，失能pretimeout通知。（注意：在看门狗信息结构中的WDIOF_PRETIMEOUT字段需要被设置）。
  &emsp;&emsp;如果看门狗驱动除了设置`watchdog_device.pretimeout`之外无需执行任何操作，则可以省略此回调函数。这意味着如果没有提供set_pretimeout，但是设置了WDIOF_PRETIMEOUT，看门狗infrastructure会在内部将watchdog_device的`pretimeout`的值更新为请求的值。
* get_timeleft：此函数返回在重置之前的剩余时间。
* restart：此函数重启机器。如果操作成功返回0，操作失败返回负的error。
* ioctl：如果此函数存在，则在我们进行自己的内部 ioctl 调用处理之前，将首先调用它。 如果不支持命令，此例程应返回 -ENOIOCTLCMD。 传递给 ioctl 调用的参数有：watchdog_device、cmd 和 arg。 

&emsp;&emsp;不再使用并弃用了 'ref' 和 'unref' 操作。   

&emsp;&emsp;状态位应该（最好）用 set_bit 和 clear_bit 类似的位操作来设置。 定义的状态位是： 
* WDOG_ACTIVE：该状态位从用户的角度表明看门狗定时器设备是否处于活动状态。 设置此标志时，用户空间应向驱动程序发送心跳请求。
* WDOG_NO_WAY_OUT：该位存储看门狗的 nowayout 设置。 如果该位被设置，那么看门狗定时器将无法停止。  
* WDOG_HW_RUNNING：如果硬件看门狗正在运行，则由看门狗驱动程序设置。 如果看门狗定时器硬件无法停止，则必须设置该位。 如果在启动后看门狗定时器正在运行，在看门狗设备打开之前，也可以设置该位。 如果设置，看门狗基础设施将在未设置 WDOG_ACTIVE 的情况下向看门狗硬件发送 keepalive。 
  &emsp;&emsp;注意：当设置了此位来注册看门狗设备时，打开/dev/watchdog将跳过start操作，通过发送keepalive的请求来实现。

&emsp;&emsp;要设置WDOG_NO_WAY_OUT状态位，可以选择：
* 在watchdog_device结构体中静态的设置：`.status = WATCHDOG_NOWAYOUT_INIT_STATUS`（这等同于在menuconfig中选中`CONFIG_WATCHDOG_NOWAYOUT`）
* 使用下面的函数：
```c
static inline void watchdog_set_nowayout(struct watchdog_device *wdd, int nowayout)
```
&emsp;&emsp;注意：看门狗驱动core支持魔数close功能和nowayout功能。为了使用魔数close功能必须在看门狗信息结构中设置`WDIOF_MAGICCLOSE`字段。`noway`功能将会使`close`功能失效。
&emsp;&emsp;要设置驱动的specific数据，可以使用下面的函数：
```c
static inline void watchdog_set_drvdata(struct watchdog_device *wdd, void *data)
static inline void *watchdog_get_drvdata(struct watchdog_device *wdd)
```
&emsp;&emsp;`watchdog_set_drvdata`函数允许你添加驱动的specific数据。此函数的参数是一个指向watchdog_device的指针和一个指向驱动的specific数据的指针。
&emsp;&emsp;可以使用下面的函数来初始化`timeout`字段：
```c
extern int watchdog_init_timeout(struct watchdog_device *wdd,
                                  unsigned int timeout_parm, struct device *dev);
```
&emsp;&emsp;watchdog_init_timeout 函数允许您使用`timeout`参数或通过从设备树中检索 timeout-sec 属性（如果`timeout`参数无效）来初始化`timeout`字段。 最佳做法是在 watchdog_device 中将`timeout`值设置为超时值，然后使用此函数设置用户“首选”超时值。 此例程在成功时返回零，失败时返回负的 errno 代码。
&emsp;&emsp;要在重启时禁用看门狗，用户必须调用以下帮助程序：
```c
static inline void watchdog_stop_on_reboot(struct watchdog_device *wdd);
```
&emsp;&emsp;要在取消注册看门狗时禁用看门狗，用户必须调用以下帮助程序。 请注意，只有在没有设置 nowayout 标志才能停止看门狗。 
```c
static inline void watchdog_stop_on_unregister(struct watchdog_device *wdd);
```
&emsp;&emsp;要更改restart handler的优先级，应使用以下函数： 
```c
void watchdog_set_restart_priority(struct watchdog_device *wdd, int priority);
```
&emsp;&emsp;用户应遵循以下准则来设置优先级： 
* 0：应作为最低的优先级调用，重启能力有限
* 128：默认级别的重启程序，如果没有其他handler处理程序可用，和/或需要足以重启整个系统的重启，则使用此优先级
* 256：最高优先级，将会抢占其他所有重启程序。

要引发pretimeout通知，应使用以下函数： 
```c
void watchdog_notify_pretimeout(struct watchdog_device *wdd)
```
&emsp;&emsp;该函数可以在中断上下文中调用。 如果看门狗预超时控制器框架（kbuild CONFIG_WATCHDOG_PRETIMEOUT_GOV 符号）被启用，则由预先分配给看门狗设备的预配置预超时控制器执行操作。 如果没有启用看门狗预超时调控器框架，watchdog_notify_pretimeout() 会向内核日志缓冲区打印一条通知消息。 

#### 3 应用层测试看门狗代码
主要流程是
1. 输入参数，输入参数的格式是`./测试文件名 设备名 timeout时间 间隔喂狗时间`。
2. 获取默认超时时间，设置超时时间，再次获取超时时间看是否设置进去了。
3. 以interval的时间间隔喂狗五次。
4. 停止喂狗，等待重启，期间获取reboot的剩余时间。
```c
#include <unistd.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/watchdog.h>

int getTimeOut(int fd, int *timeout)
{
    int ret = ioctl(fd, WDIOC_GETTIMEOUT, timeout);
    if(ret == -1)
    {
        perror("get timeout failed");
        return -1;
    }
    return 0;
}

int setTimeOut(int fd, int *timeout)
{
    int ret = ioctl(fd, WDIOC_SETTIMEOUT, timeout);
    if(ret == -1)
    {
        perror("set timeout failed");
        return -1;
    }
    return 0;
}

int getTimeOutLeft(int fd, int *timeout)
{
    int ret = ioctl(fd, WDIOC_GETTIMELEFT, timeout);
    if(ret == -1)
    {
        perror("get timeout left failed");
        return -1;
    }
    return 0;
}

int stopWdt(int fd)
{
    int options = WDIOS_DISABLECARD;
    int ret = ioctl(fd, WDIOC_SETOPTIONS, &options);
    if(ret == -1)
    {
        perror("can't disable wdt");
        return -1;
    }
    return 0;
}

int startWdt(int fd)
{
    int options = WDIOS_ENABLECARD;
    int ret = ioctl(fd, WDIOC_SETOPTIONS, &options);
    if(ret == -1)
    {
        perror("can't enable wdt");
        return -1;
    }
    return 0;
}

void main(int argc, char *argv[])
{
    int i = 0;
    int ret, fd;
    int get_timeout, set_timeout, get_timeout_left, sleep_interval;

    if(argc != 4)
    {
        fprintf(stdout, "useage: ./user_wdt_test watchdogn timeout sleep_interval");
        fprintf(stdout, "for example: ./user_wdt_test watchdog1 10 3");
        return;
    }

    char device[256];
    sprintf(device, "/dev/%s", argv[1]);
    if(access(device, F_OK) < 0)
    {
        perror(device);
    }
    set_timeout = atoi(argv[2]);
    sleep_interval = atoi(argv[3]);
    printf("input argument is : %s %s %d %d\r\n", argv[0], device, set_timeout, sleep_interval);

    fd = open(device, O_RDWR);
    if(fd == -1)
    {
        perror(device);
        return;
    }
    else
        printf("open %s success\r\n", device);

    ret = getTimeOut(fd, &get_timeout);
    if(ret == -1)
    {
        close(fd);
        perror("get timeout failed");
        return;
    }
    else
        printf("get timeout before set, timeout = %d\r\n", get_timeout);

    ret = setTimeOut(fd, &set_timeout);
    if(ret == -1)
    {
        close(fd);
        perror("set timeout failed");
        return;
    }
    else
        printf("set timeout success,    timeout = %d\r\n", set_timeout);

    ret = getTimeOut(fd, &get_timeout);
    if(ret == -1)
    {
        close(fd);
        perror("get timeout failed");
        return;
    }
    else
        printf("get timeout after  set, timeout = %d\r\n", get_timeout);

    //daemon: feed wdt five times at two second intervals
    while(i < 5)
    {
        sleep(sleep_interval);
        ioctl(fd, WDIOC_KEEPALIVE, 0);
        printf("feed wdt %3d times\r\n", ++i);
    }
    i = 0;

#if 0
    ret = stopWdt(fd);
    if(ret == -1)
    {
        close(fd);
        perror("stop wdt");
        return;
    }
    else
        printf("wdt has been closed\r\n");

    ret = startWdt(fd);
    if(ret == -1)
    {
        close(fd);
        perror("start wdt");
        return;
    }
    else
        printf("wdt has been enabled\r\n");
#endif

    while(1)
    {
        i++;
        sleep(sleep_interval);
        printf("wait for restart, time has passed %3d seconds\r\n", i*sleep_interval);
        getTimeOutLeft(fd, &get_timeout_left);
        printf("%-3d seconds left to reboot\r\n", get_timeout_left);
    }
}

```

#### 4 watchdog.h
&emsp;&emsp;定义了watchdog_ops操作函数集合结构体；定义了watchdog_device设备结构体。结构体成员具体含义可以看`watchdog-kernel-api.txt`。  
&emsp;&emsp;此文件中的一些函数是检查watchdog_device->status成员各个状态为是否有效。检查一些设置的参数是否有效，设置私有数据灯。

#### 5 watchdog_dev.c














