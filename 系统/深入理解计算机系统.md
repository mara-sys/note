# 深入理解计算机系统
## 第三章 程序的机器级表示
### 3.2 程序编码
&emsp;&emsp;源码转换成可执行代码的过程。
1. `C 预处理器`扩展源代码，插入所有用 #include 命令指定的文件，并扩展所有用 #define 生命指定的宏。
2. `编译器`产生两个源文件的汇编代码。
3. `汇编器`会将汇编代码转换成二进制目标代码文件。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
4. `链接器`将两个目标代码文件与实现库函数（例如 printf）合并，并产生最终的可执行代码文件。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

#### 3.2.1 机器级代码
&emsp;&emsp;x86-64 的机器代码。
* 程序计数器（通常称为 PC）：给出将要执行的下一条指令在内存中的地址。
* 整数寄存器文件：包含16个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
* 条件码寄存器：保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 或 while 语句。
* 向量寄存器：可以存放一个或多个整数或浮点数值。

#### 3.2.2 代码示例
&emsp;&emsp;在命令行使用`-S`选项，就能看到 C 语言编译器产生的汇编代码：
```shell
linux>gcc -Og -S mstore.c
```
&emsp;&emsp;这会使 GCC 运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。
&emsp;&emsp;如果我们使用`-c`命令行选项，GCC 会编译并汇编改代码：
```shell
linux>gcc -Og -c mstore.c
```
&emsp;&emsp;这就会产生目标代码文件 mstore.o，它是二进制格式的，所以无法直接查看。
&emsp;&emsp;要查看机器代码文件的内容，有一类称为反汇编器（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似汇编代码的格式。在 Linux 系统中，带`-d`命令行标志的程序 OBJDUMP 可以充当这个角色：
```shell
linux>objdump -d mstore.o
```
&emsp;&emsp;生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main 函数。我们可以使用如下方法生成可执行文件 prog：
```shell
linux>gcc -Og -o prog main.c mstore.c
```
&emsp;&emsp;也可以使用反汇编器抽取出各种代码序列，包括下面这段：
```shell
000000000040061b <multstore>:
  40061b:	53                   	push   %rbx
  40061c:	48 89 d3             	mov    %rdx,%rbx
  40061f:	e8 ef ff ff ff       	callq  400613 <mult2>
  400624:	48 89 03             	mov    %rax,(%rbx)
  400627:	5b                   	pop    %rbx
  400628:	c3                   	retq   
  400629:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
```
&emsp;&emsp;有一个不同之处在于链接器填上了 callq 指令调用函数 mult2 需要使用的地址，链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。单独的 mstore.c 反汇编产生的指令如下：
```shell
0000000000000000 <multstore>:
   0:	53                   	push   %rbx
   1:	48 89 d3             	mov    %rdx,%rbx
   4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
   9:	48 89 03             	mov    %rax,(%rbx)
   c:	5b                   	pop    %rbx
   d:	c3                   	retq   
```
&emsp;&emsp;还有一个区别是多了两行代码，这条指令对程序没有影响，因为它们出现在返回指令后面。插入这些行是为了使函数代码变为 16 字节，使得就存储系统性能而言，能更好地放置下一个代码块。


#### 3.2.3 关于格式的注解
&emsp;&emsp;mstore.s 文件完整内容如下：
```shell
	.file	"mstore.c"
	.text
	.globl	multstore
	.type	multstore, @function
multstore:
.LFB0:
	.cfi_startproc
	pushq	%rbx
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
	movq	%rdx, %rbx
	call	mult2
	movq	%rax, (%rbx)
	popq	%rbx
	.cfi_def_cfa_offset 8
	ret
	.cfi_endproc
.LFE0:
	.size	multstore, .-multstore
	.ident	"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609"
	.section	.note.GNU-stack,"",@progbits
```
&emsp;&emsp;所有以`.`开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。

### 3.3 数据格式
&emsp;&emsp;字（word）：16 bit；
&emsp;&emsp;双字（double words）：32 bit；
&emsp;&emsp;四字（quad words）：64 bit。
&emsp;&emsp;大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和 movq（传送四字）。后缀‘l’用来表示双字，因为 32 位数被看成是“长字（long word）”。注意，汇编代码也使用后缀‘l’来表示 4 字节整数和 8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。


### 3.4 访问信息
#### 3.4.3 数据传送示例
&emsp;&emsp;这一节没认真看。

#### 3.4.4 压入和弹出栈数据
&emsp;&emsp;栈在处理过程调用中起到至关重要的作用。栈是一种数据结构，可以添加或删除值，不过要遵循“后进先出”的原则。通过 push 操作把数据压入栈中，通过 pop 操作删除数据；它具有一个属性：弹出的值永远是最近被压入而且仍然在栈中的值。
&emsp;&emsp;栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为`栈顶`，栈顶元素的地址是所有栈中元素地址最低的。
&emsp;&emsp;push 和 pop 指令都只有一个操作数——压入的数据源和弹出的数据目的。
&emsp;&emsp;**将一个四字值压入栈中，首先要将栈指针减 8，然后将值写到新的栈顶地址。**

### 3.5 算数和逻辑操作

























## 第七章 链接