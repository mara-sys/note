<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:Linux_module</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p><a href="#八-零散的宏定义">八、 零散的宏定义</a></p>
<ul>
<li><a href="#81-device_attr">8.1 DEVICE_ATTR</a><ul>
<li><a href="#811-介绍">8.1.1 介绍</a></li>
<li><a href="#812-device_attr举例">8.1.2 DEVICE_ATTR举例</a></li>
<li><a href="#813-device_attr分析">8.1.3 DEVICE_ATTR分析</a></li>
<li><a href="#814-device_attr_rwdevice_attr_rodevice_attr_wo分析">8.1.4 DEVICE_ATTR_RW、DEVICE_ATTR_RO、DEVICE_ATTR_WO分析</a></li>
<li><a href="#815-权限标识方法">8.1.5 权限标识方法</a></li>
<li><a href="#816-pwmc中宏定义的展开">8.1.6 pwm.c中宏定义的展开</a></li>
<li><a href="#817-device_attribute结构体的定义">8.1.7 device_attribute结构体的定义</a></li>
<li><a href="#818-将属性公开到文件系统中">8.1.8 将属性公开到文件系统中</a></li>
</ul>
</li>
</ul>
<h1 id="-">八、 零散的宏定义</h1>
<h2 id="8-1-device_attr">8.1 DEVICE_ATTR</h2>
<h3 id="8-1-1-">8.1.1 介绍</h3>
<p>&emsp;&emsp;使用DEVICE_ATTR，可以实现驱动在sys目录自动创建文件，我们只需要实现show和store函数即可。然后在应用层就能通过cat和echo命令来对sys创建出来的文件进行读写驱动设备，实现交互。</p>
<h3 id="8-1-2-device_attr-">8.1.2 DEVICE_ATTR举例</h3>
<p>以pwm中的sysfs.c为例。文件位置位于/drivers/pwm/sysfs.c</p>
<pre><code class="lang-c">static ssize_t polarity_show(struct device *child,
                 struct device_attribute *attr,
                 char *buf)
{
    const struct pwm_device *pwm = child_to_pwm_device(child);
    /* 省略具体的处理内容 */

    return sprintf(buf, &quot;%s\n&quot;, polarity);
}

static ssize_t polarity_store(struct device *child,
                  struct device_attribute *attr,
                  const char *buf, size_t size)
{
    struct pwm_export *export = child_to_pwm_export(child);
    /* 省略具体的处理内容 */

    return ret ? : size;
}

static DEVICE_ATTR_RW(polarity);
</code></pre>
<p>在<code>/sys/class/pwm</code>下可以看到polarity属性</p>
<p><img src="Linux_module_images/080102_polarity_example.png" alt="polarity属性"></p>
<p>通过</p>
<pre><code class="lang-shell">echo 0 &gt; polarity
cat polarity
</code></pre>
<p>来对该属性进行读写操作。</p>
<h3 id="8-1-3-device_attr-">8.1.3 DEVICE_ATTR分析</h3>
<p>DEVICE_ATTR定义在/include/linux/device.h中</p>
<pre><code class="lang-c">#define DEVICE_ATTR(_name, _mode, _show, _store) \
    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
</code></pre>
<p>__ATTR定义在/include/linux/sysfs.h中</p>
<pre><code class="lang-c">#define __ATTR(_name, _mode, _show, _store) {               \
    .attr = {.name = __stringify(_name),                \
         .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },     \
    .show   = _show,                        \
    .store  = _store,                       \
}
</code></pre>
<h3 id="8-1-4-device_attr_rw-device_attr_ro-device_attr_wo-">8.1.4 DEVICE_ATTR_RW、DEVICE_ATTR_RO、DEVICE_ATTR_WO分析</h3>
<pre><code class="lang-c">#define DEVICE_ATTR_RW(_name) \
    struct device_attribute dev_attr_##_name = __ATTR_RW(_name)
#define DEVICE_ATTR_RO(_name) \
    struct device_attribute dev_attr_##_name = __ATTR_RO(_name)
#define DEVICE_ATTR_WO(_name) \
    struct device_attribute dev_attr_##_name = __ATTR_WO(_name)
</code></pre>
<p><strong>ATTR_RW、</strong>ATTR_RO、<strong>ATTR_WO和</strong>ATTR类似，定义在/include/linux/sysfs.h中</p>
<pre><code class="lang-c">#define __ATTR_RO(_name) {                      \
    .attr   = { .name = __stringify(_name), .mode = 0444 },     \
    .show   = _name##_show,                     \
}

#define __ATTR_WO(_name) {                      \
    .attr   = { .name = __stringify(_name), .mode = 0200 },     \
    .store  = _name##_store,                    \
}

#define __ATTR_RW(_name) __ATTR(_name, 0644, _name##_show, _name##_store)
</code></pre>
<p>&emsp;&emsp;<strong>ATTR_RO只定义了show函数，函数名字是“_name_show”，类似的</strong>ATTR_WO只定义了store函数，函数名字是”_name_store”，__ATTR_RW同时定义了show、store函数。这三个宏定义是DEVICE_ATTR的简化使用，默认对权限进行了配置。</p>
<h3 id="8-1-5-">8.1.5 权限标识方法</h3>
<p>umask变量表示方法
|加权数值|第1位            |第2位          |第3位              |
|:---:  |:---             |:---           |:---              |
|100    |所有者拥有读权限  |群组拥有读权限  |其他用户拥有读权限  |
|010    |所有者拥有写权限  |群组拥有写权限  |其他用户拥有写权限  |
|001    |所有者拥有执行权限|群组拥有执行权限|其他用户拥有执行权限 |</p>
<p>与上面权限对应的宏定义是</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>参数</th>
<th>说明</th>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>S_IRUSR</td>
<td>所有者拥有读权限</td>
<td>S_IRGRP</td>
<td>群组拥有读权限</td>
<td>S_IROTH</td>
<td>其他用户拥有读权限</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>所有者拥有写权限</td>
<td>S_IWGRP</td>
<td>群组拥有写权限</td>
<td>S_IWOTH</td>
<td>其他用户拥有写权限</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>所有者拥有执行权限</td>
<td>S_IXGRP</td>
<td>群组拥有执行权限</td>
<td>S_IXOTH</td>
<td>其他用户拥有执行权限</td>
</tr>
</tbody>
</table>
<h3 id="8-1-6-pwm-c-">8.1.6 pwm.c中宏定义的展开</h3>
<p>因此</p>
<pre><code class="lang-c">static DEVICE_ATTR_RW(polarity);
</code></pre>
<p>展开以后就是</p>
<pre><code class="lang-c">struct device_attribute dev_attr_polarity = {                
    .attr = {.name = __stringify(polarity),                
         .mode = VERIFY_OCTAL_PERMISSIONS(0644) },     
    .show   = polarity_show,                        
    .store  = polarity_store,                       
}
</code></pre>
<p>其中polarity_show和polarity_store已经在上面实现了。</p>
<h3 id="8-1-7-device_attribute-">8.1.7 device_attribute结构体的定义</h3>
<p>attribute结构体定义在include/linux/sysfs.h</p>
<pre><code class="lang-c">struct attribute {
    const char      *name;
    umode_t         mode;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
    bool            ignore_lockdep:1;
    struct lock_class_key   *key;
    struct lock_class_key   skey;
#endif
};
</code></pre>
<p>&emsp;&emsp;此结构体中name代表属性名称，一般表示为文件名，mode代表该属性的读写权限。device_attribute定义在/include/linux/device.h中</p>
<pre><code class="lang-c">struct device_attribute {
    struct attribute    attr;
    ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf);
    ssize_t (*store)(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);
};
</code></pre>
<p>&emsp;&emsp;该结构体是对attribute结构体的进一步封装，并提供了两个函数指针，show函数用于读取设备的属性文件，而store则是用于写设备的属性文件，<strong>当我们在linux驱动程序中实现了这两个函数后，便可以使用cat和echo命令对设备属性文件进行读写操作。</strong></p>
<h3 id="8-1-8-">8.1.8 将属性公开到文件系统中</h3>
<p>&emsp;&emsp;可以通过ATTRIBUTE_GROUPS宏定义来实现，在pwm的sysfs.c中可以看到，其中的dev_attr_name就是在DEVICE_ATTR中定义的结构体。</p>
<pre><code class="lang-c">static struct attribute *pwm_attrs[] = {
    &amp;dev_attr_period.attr,
    &amp;dev_attr_duty_cycle.attr,
    &amp;dev_attr_enable.attr,
    &amp;dev_attr_polarity.attr,
    &amp;dev_attr_capture.attr,
    NULL
};
ATTRIBUTE_GROUPS(pwm);
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>