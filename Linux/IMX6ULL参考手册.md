## 第十五章 AHB-to-APBH Bridge with DMA (APBH-Bridge-DMA)
### 15.1 概述
&emsp;&emsp;AHB-to-APBH 桥接器为芯片提供了在 AHB 的 HCLK 上运行的廉价外设连接总线。 （APBH 中的 H 表示 APBH 与 HCLK 同步。）  
&emsp;&emsp;如下图所示，AHB-to-APBH 桥包括 AHB-to-APB PIO 桥，用于到 APB 设备的内存映射 I/O，以及用于该总线上的设备的中央 DMA 设施和一个 Arm内核的向量中断控制器。 每个 APB 外设，包括向量中断控制器，都在各自的章节中进行了记录。  
&emsp;&emsp;DMA 控制器使用 APBH 总线向每个外设传输读写数据。 这些设备没有单独的 DMA 总线。 DMA 对 APBH 总线的使用与 AHB 到 APB 桥功能对 APBH 的使用之间的争用由内部仲裁逻辑调解。 对于这两个单元之间的竞争，DMA 受到青睐，AHB 从设备将通过其 HREADY 输出报告“未准备好”，直到桥接传输完成。 仲裁器跟踪重复的锁定并反转优先级，保证 APB 上每四次传输一次 Arm 平台。 
### 15.2 时钟
&emsp;&emsp;此处的表格描述了 APBH 的时钟源。 有关时钟设置、配置和门控信息，请参阅时钟控制器模块 (CCM)。 
### 15.3 APBH DMA
&emsp;&emsp;DMA 支持四个通道的 DMA 服务，如下表所示。 共享 DMA 资源允许每个独立通道遵循简单的链式命令列表。 命令链使用通用结构构建，如图 15-2 所示。 
&emsp;&emsp;单个命令结构体或通道命令字指定由 DMA 执行以支持给定设备的许多操作。 因此，Arm 平台可以设置大型工作单元，将许多 DMA 通道命令字链接在一起，将它们传递给 DMA，并且在 DMA 完成中断发生之前不再关心设备。 目标是在 DMA 和设备中具有足够的智能，以将来自任何设备的中断频率保持在 1 KHz 以下（到达间隔长于 1 ms）。 
&emsp;&emsp;单个命令结构可以使用相同的 APB 总线向相关设备中的关键寄存器发出 32 位 PIO 写操作，并控制它用于将 DMA 数据字节写入设备。 例如，这允许向 GPMI 控制器发出一系列操作，以发送 NAND 命令字节、地址字节和数据传输，其中命令和地址结构完全受软件控制，但该传输的管理是由 DMA 自主处理的。 每个 DMA 结构可以附加 0-15 个 PIO 字。 CMDPIOWORDS 字段（如果非零）指示 DMA 引擎将这些字复制到 APB，从外设的第一个寄存器地址偏移量开始，并在每个周期递增寄存器偏移量。 
&emsp;&emsp;DMA 主机仅生成到 APBH 的正常读/写传输。 它不会生成设置、清除或切换 (SCT) 传输。 
&emsp;&emsp;在任何请求的 PIO 字传输到外设后，DMA 检查通道命令结构中的两位命令字段。 表 15-3 显示了 DMA 实现的四个命令。 
&emsp;&emsp;DMA_WRITE 操作将数据字节从相关外设复制到系统存储器（片上 RAM 或 SDRAM）。 
&emsp;&emsp;DMA_READ 操作将数据字节从系统存储器复制到 APB 外设。 DMA 引擎包含一个共享字节对齐器，用于对齐来自系统存储器和外设的字节。 外设总是假设小端对齐的数据到达或离开它们的 32 位 APB。 DMA_READ 传输使用命令结构中的 BUFFER_ADDRESS 字指向要由 DMA_READ 命令读取的 DMA 数据缓冲区。
&emsp;&emsp;NO_DMA_XFER 命令用于将 PIO 字写入设备而不执行任何 DMA 数据字节传输。 此命令在激活 NAND 设备 CHECKSTATUS 操作等应用中很有用。 检查状态命令从 NAND 设备读取状态字节，对作为 PIO 传输的一部分提供的预期值执行 XOR 和 MASK。 读取检查完成后（请参阅 NAND 读取状态轮询示例），NO_DMA_XFER 命令完成。 外设中的结果是其感测线由比较结果驱动。 感测触发器仅由执行的设备的 CHECKSTATUS 更新。 在未来的某个时刻，该链包含具有第四个也是最后一个命令值的 DMA 命令结构，即 DMA_SENSE 命令。 
&emsp;&emsp;随着每个 DMA 命令完成，它会触发 DMA 加载链中的下一个 DMA 命令结构。 DMA命令的正常流列表是通过跟踪DMA命令结构中的NEXTCMD_ADDR指针找到的。 DMA_SENSE 命令使用命令结构的 DMA 缓冲区指针字指向备用 DMA 命令结构链或列表。 DMA_SENSE 命令检查相关外设的检测线。 如果检测线为假，则 DMA 遵循找到的标准列表，其下一个命令是从命令结构的 NEXTCMD_ADDR 字中的指针中找到的。 如果检测线为真，则 DMA 遵循备用列表，其下一个命令是从 DMA_SENSE 命令结构的 DMA 缓冲区指针字中的指针中找到的（见图 15-2）。 检测命令忽略 CHAIN 位，因此当 DMA 发出检测命令时，两个指针都必须有效。  
&emsp;&emsp;如果在命令结构中设置了等待结束命令位 (WAIT4ENDCMD)，则 DMA 通道通过切换 endcmd 信号等待设备发出命令完成信号，然后再继续加载和执行下一个命令结构。 然后，如果设置了 DECREMENT_SEMAPHORE，则在看到结束命令后减少信号量。  
&emsp;&emsp;下表显示了 DMA 命令结构的详细位字段视图，其中显示了一个字段，该字段指定此 DMA 命令要传输的字节数。 传输计数机制在相关外设中复制，作为外设中的隐含或指定计数。  
&emsp;&emsp;Freq_i图 15-2 还显示了命令结构的第二个字的位 2 中的 CHAIN 位。 如果 NEXT_COMMAND_ADDRESS 包含指向另一个 DMA 命令结构的指针，则该位设置为 1。 如果将空指针 (0) 加载到 NEXT_COMMAND_ADDRESS 中，则 DMA 硬件不会检测到它。 只有 CHAIN 位指示在当前结构之外是否存在有效列表。  
&emsp;&emsp;如果在命令结构中设置了 IRQ_COMPLETE 位，则 DMA 在加载下一条命令之前的最后一个动作是设置当前通道对应的中断状态位。 DMA CSR 中的粘滞中断请求位保持置位，直到被软件清除。 它可以用来中断ARM平台。  
&emsp;&emsp;NAND_LOCK 位由 DMA 通道仲裁器监控。 在其 NAND_LOCK 位设置的仲裁器中成功，然后仲裁器忽略其他 NAND 通道，直到完成未设置 NAND_LOCK 的命令。 请注意，这里的语义是 NAND_LOCK 状态是限制非锁定 DMA 的调度。 当 NAND_LOCK 位置位时，DMA 通道可以在命令开始时在仲裁器中从解锁状态变为锁定状态。 当原子序列的最后一个 DMA 命令完成时，应该解除锁定。 为此，最后一条命令没有 NAND_LOCK 位。 命令启动时，它仍然被锁定在仲裁器内部的原子状态，因此它是唯一可以执行的 NAND 命令。 最后，它从仲裁器中的原子状态下降。  
&emsp;&emsp;NAND_WAIT4READY 位对 GPMI 通道（从通道到通道）也有特殊用途，即 NAND 设备通道。 GPMI 外设提供来自 NAND 设备的就绪行的样本。 该就绪值用于延迟该位设置的命令，直到就绪行断言为 1。一旦仲裁器看到设置了等待就绪的命令，它就会延迟该通道，直到断言就绪。  
&emsp;&emsp;接收 HALTONTERMINATE (HOT) 的 IRQ 是 APBH DMA 描述符中的一项功能，它允许 GPMI 向 DMA 引擎发送已发生错误的信号。 如果命令由于错误而停止，则从外设向 DMA 引擎发送 HOT 信号，并在终止正在执行的 DMA 描述符后引发 IRQ。  
&emsp;&emsp;因此，建议软件按如下方式使用该信号： 
* 在 DMA 描述符中始终将 HALTONTERMINATE 设置为 1。 这样，如果外设发出 HOT 信号，传输将结束，使外设块和 DMA 引擎保持同步（但在命令结束时）。 
* 当接收到来自 APBH 通道的 IRQ，并且确定该 IRQ 是由于错误（与 IRQONCOMPLETE 中断相反）导致的，软件应该： 
  * 复位通道；
  * 根据外设模块中的错误报告确定错误，然后以该设备存在的任何适当方式（软件恢复、设备复位、模块复位等）管理连接到该通道的外设中的错误。 

&emsp;&emsp;每个通道都有一个八位计数信号量，用于控制它是否处于空闲状态。 当信号量不为零时，通道已准备好运行、处理命令并执行 DMA 传输。 每当命令完成其 DMA 传输时，它都会检查 DECREMENT_SEMAPHORE 位。 如果设置，它会减少计数信号量。 如果信号量因此变为 0，则通道进入空闲状态并保持在那里，直到信号量被软件递增。 当信号量变为非零且通道处于空闲状态时，它使用 APBH_CHn_NXTCMDAR 寄存器（下一个命令地址寄存器）中的值来获取指向下一个要处理的命令的指针。 
&emsp;&emsp;注意：这是一个双重间接案例。 这种方法允许软件在计数信号量的保护下附加到一个正在运行的命令列表。  
&emsp;&emsp;第一次开始处理时，软件会创建要处理的命令列表。 它将第一个命令的地址写入 APBH_CHn_NXTCMDAR 寄存器，然后将 1 写入 APBH_CHn_SEMA 中的计数信号量。 DMA 通道加载 APBH_CHn_CURCMDAR 寄存器，然后进入正常状态机处理下一条命令。 当软件向计数信号量写入一个值时，它会被硬件添加到信号量计数中，以保护硬件和软件都试图在同一时钟沿更改信号量的情况。  
&emsp;&emsp;软件可以随时检查 APBH_CHn_CURCMDAR 的值以确定当前正在处理的命令结构的位置。 

### 15.5 寄存器定义
#### 15.5.1 AHB 到 APBH 桥接控制和状态寄存器 0（APBH_CTRL0n）
&emsp;&emsp;APBH CTRL 0 提供对 AHB 到 APBH 桥接和 DMA 的整体控制。  
&emsp;&emsp;该寄存器包含模块软复位、时钟门控、通道时钟门控/冻结位。 

| 位               | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 31 SFTRST        | 将此位设置为零以启用正常的 APBH DMA 操作。 将此位设置为 1（默认）以禁用 APBH DMA 的时钟并将其保持在其复位（最低功耗）状态。 该位可以打开然后关闭，以将 APBH DMA 块重置为其默认状态。（软件复位） |
| 30 CLKGATE       | 该位必须设置为零才能正常运行。 当设置为 1 时，它会关闭模块的时钟。 |
| 29 AHB_BURST8_EN | 将此位设置为 1（默认）以使能 AHB 8-beat burst。设置为 0 失能 AHB 上的 8-beat burst。 |
| 28 APB_BURST_EN  | 将此位设置为 1 可在设备请求 burst dma 时使能 apb 主机进行连续传输。 设置为 0 会将 burst dma 请求视为 4/8 个单独的请求。 |
| 27 RSVD0         |                                                              |
| CLKGATE_CHANNEL  | 为了每个通道的正常操作，这些位必须设置为零。 当设置为 1 时，它们会关闭通道的各个时钟。<br>0x0001    NAND0<br>0x0002    NAND1<br>0x0004    NAND2<br>0x0008    NAND3<br>0x0010    NAND4<br>0x0020    NAND5<br>0x0040    NAND6<br>0x0080    NAND7<br>0x0100    SSP |

#### 15.5.2 AHB 到 APBH 桥接控制和状态寄存器 1（APBH_CTRL1n）
&emsp;&emsp;APBH CTRL 1 提供对 AHB 对 APBH DMA 产生的中断的整体控制。 该寄存器包含每个通道的中断状态位和每个通道的中断使能位。 每个通道在向量中断控制器中都有一个专用的中断向量。 

| 位                      | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 31 CH15_CMDCMPLT_IRQ_EN | 设置该位可以使能 APBH DMA 通道 15 生成中断的请求。           |
| ......                  |                                                              |
| 15 CH15_ CMDCMPLT_ IRQ  | APBH DMA 通道 15 的中断请求状态位。该粘性位由 DMA 硬件设置并由软件复位。 它与相应的使能位进行“与”运算以产生中断。 |
| ......                  |                                                              |

#### 15.5.3 AHB 到 APBH 桥接控制和状态寄存器 2（APBH_CTRL2n）
&emsp;&emsp;APBH CTRL 2 将 AHB 生成的通道错误中断提供给 APBH DMA。 该寄存器包含每个通道的中断状态位和每个通道的中断使能位。 每个通道在向量中断控制器中都有一个专用的中断向量。 

| 位                    | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| 31 CH15_ERROR_ STATUS | APBH DMA 通道 15 的错误状态位。当相应的 Error IRQ 被设置时有效。<br>1：AHB bus error<br>0：通道提前终止。<br>0x0    TERMINATION：设备提前终止会导致错误 IRQ。<br>0x1    BUS_ERROR：AHB 总线错误导致错误 IRQ。 |
| .......               |                                                              |
| 15 CH15_ERROR_ IRQ    | APBH DMA 通道 15 的错误中断状态位。该粘性位由 DMA 硬件设置并由软件复位。 它与相应的 cmdcmplt irq 进行 OR 运算以生成 ARM 的 irq。 |
| ......                |                                                              |

#### 15.5.4 AHB 到 APBH 桥接通道寄存器（APBH_CHANNEL_CTRLn）
&emsp;&emsp;APBH CHANNEL CTRL 提供每个 DMA 通道的复位/冻结控制。 该寄存器包含单独的通道复位/冻结位。 

| 位                  | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| 31-16 RESET_CHANNEL | 在该字段中设置一个位会导致 DMA 控制器通过其复位状态获取相应的通道。 清除通道资源后，该位复位。<br>0x0001    NAND0<br/>0x0002    NAND1<br/>0x0004    NAND2<br/>0x0008    NAND3<br/>0x0010    NAND4<br/>0x0020    NAND5<br/>0x0040    NAND6<br/>0x0080    NAND7<br/>0x0100    SSP |
| FREEZE_CHANNEL      | 在该字段中设置一个位将冻结与其关联的 DMA 通道。 该字段是 DMA 通道仲裁器的直接输入。 冻结时，通道被定义为访问中央 DMA 资源。<br>0x0001    NAND0<br/>0x0002    NAND1<br/>0x0004    NAND2<br/>0x0008    NAND3<br/>0x0010    NAND4<br/>0x0020    NAND5<br/>0x0040    NAND6<br/>0x0080    NAND7<br/>0x0100    SSP |
#### 15.5.5 AHB 到 APBH DMA 设备分配寄存器 
&emsp;&emsp;没用
#### 15.5.6 AHB 到 APBH DMA burst size（APBH_DMA_BURST_SIZE）
&emsp;&emsp;当发出 DMA burst 请求时，该寄存器对 APBH DMA 设备的 apbh burst size 进行编程。
&emsp;&emsp;该寄存器提供了一种分配设备的机制。 

| 位        | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| 17–16 CH8 | DMA burst size for SSP.<br>0x0    BURST0<br>0x1    BURST4<br>0x2    BURST8 |
| 15–14 CH7 | GPMI 通道 7 的 DMA burst 大小。不要更改。 GPMI 仅支持 burst 大小 4。 |
|           |                                                              |

#### 15.5.7 AHB to APBH DMA Debug 寄存器 (APBH_DEBUG)
&emsp;&emsp;该寄存器用于调试目的。
&emsp;&emsp;调试寄存器仅供内部使用。 不推荐客户使用。 

#### 15.5.8 APBH DMA 通道 n 当前命令地址寄存器 (APBH_CHn_CURCMDAR) 
&emsp;&emsp;APBH DMA 通道 n 当前命令地址寄存器指向当前正在执行的多字命令。 命令在命令地址上线程化。
&emsp;&emsp;APBH DMA 通道 n 由可变大小的命令结构控制。 该寄存器指向当前正在执行的命令结构。 

| 位       | 描述                                        |
| -------- | ------------------------------------------- |
| CMD_ADDR | 指向当前正在为通道 n 处理的命令结构的指针。 |

#### 15.5.9 APBH DMA 通道 n 下一个命令地址寄存器 (APBH_CHn_NXTCMDAR) 
&emsp;&emsp;APBH DMA 通道 n 下一个命令地址寄存器包含要执行的下一个多字命令的地址。 命令在命令地址上线程化。 在 DMA 命令字中将 CHAIN 设置为 1 以处理命令列表。
&emsp;&emsp;APBH DMA 通道 n 由可变大小的命令结构控制。 软件将第一个命令结构的地址加载到该寄存器以进行处理，并增加通道 n 信号量以开始处理。 该寄存器指向当前命令完成时要执行的下一个命令结构。 

| 位       | 描述                                        |
| -------- | ------------------------------------------- |
| CMD_ADDR | 指向下一条为通道 n 处理的命令结构的指针。 |

#### 15.5.10 APBH DMA 通道 n 命令寄存器 (APBH_CHn_CMD) 
&emsp;&emsp;APBH DMA 通道 n 命令寄存器指定要为当前命令链项执行的 DMA 事务。
&emsp;&emsp;命令寄存器控制该通道的每个 DMA 命令的整体操作。 它包括传输到设备或从设备传输的字节数、包含在此命令结构中的 APB PIO 命令字的数量、是否在命令完成时中断、是否将附加命令链接到该命令的末尾以及此传输是否是读或写 DMA 传输。 

| 位                | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| 31-16 XFER_COUNT  | 该字段指示与 GPMI0 设备中适当的 PIO 寄存器之间传输的字节数。 值 0 表示 64 KB 传输。 |
| 15–12 CMDWORDS    | 该字段指示要发送到 GPMI0 的命令字的数量，从 GPMI0 控制寄存器的 PIO 基地址开始并从那里递增。 零表示无传输命令字 |
| 11-9 reserved     |                                                              |
| 8 HALTONTERMINATE | 值 1 表示如果设置了终止信号，通道将立即终止当前描述符并停止 DMA 通道。 如果设置了终止信号，值 0 仍将导致通道立即终止，但通道将继续运行，就好像计数已用完一样，这意味着它将遵循 IRQONCMPLT、CHAIN、SEMAPHORE 和 WAIT4ENDCMD。 |
| 7 WAIT4ENDCMD     | 值 1 表示通道将等待命令结束信号从 APBH 设备发送到 DMA，然后再开始下一个 DMA 命令。 |
| 6 SEMAPHORE       | 值 1 表示通道将在当前命令结构完成时减少其信号量。 如果信号量减为零，则此通道停止，直到软件再次增加它。 |
| 5 NANDWAIT4READY  | 值 1 表示 NAND DMA 通道将等到 NAND 设备报告“就绪”后再执行命令。 对于非 NAND DMA 通道，它会被忽略。 |
| 4 NANDLOCK        | 值 1 表示 NAND DMA 通道将在仲裁器中保持“锁定”状态，但会牺牲其他 NAND DMA 通道。 对于非 NAND DMA 通道，它会被忽略。 |
| 3 IRQONCMPLT      | 值 1 表示通道将在当前命令完成后（即 DMA 传输完成后）设置中断状态位。 |
| 2 CHAIN           | 值 1 表示另一个命令链接到当前命令结构的末尾。 当前命令完成后，该通道将跟随 APBH_CHn_CMDAR 中的指针寻找下一条命令。 |
| COMMAND           | 该位域指示当前命令的类型： <br>0x0    NO_DMA_XFER：执行任何请求的 PIO 字传输，但在任何 DMA 传输之前终止命令。 <br>0x1    DMA_WRITE：执行任何请求的 PIO 字传输，然后从外设执行指定字节数的 DMA 传输。 <br>0x2    DMA_READ：执行任何请求的 PIO 字传输，然后针对指定字节数执行到外设的 DMA 传输。 <br>0x3    DMA_SENSE：执行任何请求的 PIO 字传输，然后执行条件分支到下一个链接设备。 如果外围意义为真，则跟随 NEXCMD_ADDR 指针。 如果外围检测线为假，则将 BUFFER_ADDRESS 作为链指针。 |

#### 15.5.11 APBH DMA Channel n Buffer Address Register (APBH_CHn_BAR)
&emsp;&emsp;APBH DMA 通道 n 缓冲区地址寄存器包含一个指向用于传输的数据缓冲区的指针。 对于立即数形式，数据取自该寄存器。 这是一个字节地址，这意味着传输可以从任何字节边界开始。 
&emsp;&emsp;该寄存器保存指向系统内存中数据缓冲区的指针。 在命令值被读入 DMA 控制器和由该通道控制的设备之后，DMA 传输将开始，传输到或来自该寄存器指向的缓冲区。

| 位      | 描述                                               |
| ------- | -------------------------------------------------- |
| ADDRESS | 要通过 AHB 总线读取或写入的系统内存缓冲区的地址 。 |

#### 15.5.12 APBH DMA Channel n Semaphore Register (APBH_CHn_SEMA)
&emsp;&emsp;APBH DMA Channel n 信号量寄存器用于同步 Arm 平台指令流和 DMA 链处理状态。
每个 DMA 通道都有一个 8 位计数信号量，用于在程序流和 DMA 链处理之间进行同步。 DMA 处理将继续，直到 DMA 尝试减少已达到零值的信号量。 进行尝试时，DMA 通道会停止，直到软件增加信号量计数。 

| 位              | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| 31-24 reserved  |                                                              |
| 23-16 PHORE     | 此只读字段显示信号量计数器的当前（瞬时）值。                 |
| 15-8 reserved   |                                                              |
| INCREMENT_ SEMA | 写入此字段的值以原子方式添加到信号量计数中，从而保护在同一时钟上同时发生的软件添加和 DMA 硬件减法。 该位字段读回值 0x00。 写入 0x02 值会使信号量计数增加 2，除非 DMA 通道在同一时钟上减少计数，否则计数会增加净 1。 |

## 第四十章 PWM
### 40.1 概述
&emsp;&emsp;脉冲宽度调制 (PWM) 有一个 16 位计数器，并经过优化以从存储的样本音频图像中生成声音，它还可以生成音调。 它使用 16 位分辨率和 4 x 16 数据 FIFO。
本节概述了 PWM。 PWM 模块的框图如下图所示。 
&emsp;&emsp;PWM 具有以下特点： 
* 带时钟源选择的 16 位递增计数器 
* 4 x 16 FIFO 以最小化中断开销 
* 用于时钟分频的 12 位预分频器 
* 声音和旋律生成 
* 高电平有效或低电平有效配置输出 
* 可以编程为在低功耗模式下处于活动状态 
* 可以编程为在调试模式下处于活动状态 
* 比较和翻转时的中断 
### 40.2 外部信号 
&emsp;&emsp;PWM 在与处理器内核接口时遵循 IP 总线协议。 除了来自时钟控制模块 (CCM)、系统复位控制器 (SRC) 的时钟和复位输入以及处理器中断处理程序的中断信号外，PWM 与芯片内的任何其他模块没有任何接口信号。 有一个单一的输出信号。
&emsp;下表概述了外部信号。 

| Signal   | 描述                                                         | Pad            | Mode | 描述 |
| -------- | ------------------------------------------------------------ | -------------- | ---- | ---- |
| PWM1_OUT | 这是 PWM 的 PWM1 功能输出。 在此引脚上观察到模块的调制信号。 它可以看作是一个时钟信号，其周期和占空比可以随着 50% 周期的不同设置而变化。 | ENET1_RX_DATA0 | ALT2 | O    |
|          |                                                              | GPIO1_IO08     | ALT0 |      |
|          |                                                              | LCD_DATA00     | ALT1 |      |
| ......   |                                                              |                |      |      |
| PWM8_OUT |                                                              |                |      |      |

### 40.3 时钟
&emsp;&emsp;此处的表格描述了 PWM 的时钟源。 有关时钟设置、配置和门控信息，请参阅时钟控制器模块 (CCM)。   
&emsp;&emsp;可以从以下选项中选择预分频器的时钟： 
* 高频参考时钟 (ipg_clk_highfreq) pat_ref 或 CKIH 
  这是一个高频时钟，由时钟控制模块 (CCM) 提供。 当 ipg_clk 关闭时，该时钟应在低功耗模式下打开。 因此，PWM 可以在低功耗模式下在该时钟上运行。 CCM 预计在正常功能模式下将其同步到 ahb_clk 后提供此时钟，然后在低功耗模式下切换到非同步版本。  
* 低频参考时钟 (ipg_clk_32k, CKIL) 
  这是由 CCM 提供的 32 KHz 低频参考时钟。 当 ipg_clk 关闭时，该时钟应在低功耗模式下打开。 因此，PWM 可以在低功耗模式下在该时钟上运行。 CCM 预计在正常功能模式下将其同步到 ahb_clk 后提供此时钟，然后在低功耗模式下切换到非同步版本。 
* 外设时钟 (ipg_clk) 
  此时钟应在正常操作中打开。 在低功耗模式下，可以将其关闭。
* 外设访问时钟 (ipg_clk_s) 
  该时钟用于寄存器读/写。

&emsp;&emsp;时钟输入源由 PWM 控制寄存器字段 PWM_CR[CLKSRC] 确定。要更改 CLKSRC 值需要先失能 PWM。
&emsp;&emsp;控制寄存器的 PRESCALER 字段值的变化会立即反映在其输出时钟频率上。  

### 40.4 功能描述
&emsp;&emsp;下面的章节描述了 PWM 的操作和功能。
#### 40.4.1 操作
&emsp;&emsp;PWM 的输出是一个切换信号，其频率和占空比可以通过编程适当的寄存器来调制。 它有一个 16 位向上计数器，从 0x0000 开始计数，直到计数器值等于 PWM_PR + 1。匹配发生后，计数器重置为 0x0000。
&emsp;&emsp;在计数周期开始时，PWMO 引脚设置为 1（默认），计数器从 0x0000 开始向上计数。 在预分频器时钟的每个计数上比较采样 FIFO 中的采样值。 当采样值和计数值匹配时，PWMO 信号设置为 0（默认）。 计数器继续计数，直到周期匹配发生，随后另一个周期周期开始。
&emsp;&emsp;当 PWM 使能时，计数器开始运行并生成一个输出，其周期和采样值使用寄存器中复位时的值。 建议在启用 PWM 之前对这些寄存器进行编程。
&emsp;&emsp;硬件复位会导致所有 PWM 计数和采样寄存器被清除，FIFO 被刷新。 控制寄存器显示 FIFO 为空，可写入，PWM 关闭。 软件复位具有相同的结果，但是控制寄存器中的 DBGEN、STOPEN、DOZEN 和 WAITEN 位的状态不受影响。 即使 PWM 处于禁用状态，也可以断言软件复位。
##### 40.4.1.1 FIFO
&emsp;&emsp;数字采样值可以作为 16 位字加载到脉宽调制器中。可以使用控制寄存器的 BCTR 和 HCTR 位更改字节顺序。 4 字（16 位）FIFO 将中断开销降至最低。当数据字数低于控制寄存器中 FWM 字段设置的水位时，会产生可屏蔽中断。
&emsp;&emsp;如果 FIFO 未满，写入 PWM_SAR 采样寄存器会导致值被存储到 FIFO 中。 FIFO 满时写入会设置状态寄存器中的 FWE（FIFO 写入错误）位，并且 FIFO 内容保持不变。 FIFO 可以随时写入，但只能在 PWM 使能时读取。 PWM_SR[FIFOAV] 字段显示 FIFO 中当前包含多少数据字以及是否可以写入。
&emsp;&emsp;对采样寄存器的读取产生当前 FIFO 值，PWM 正在使用或将使用该值来生成输出信号。因此，对样本寄存器的写入和后续读取可能会导致获得不同的值。 
##### 40.4.1.2 翻转和比较事件 
&emsp;&emsp;在其值等于PWM_PR[周期]+1后，计数器重置为0x0000，然后继续计数。此事件称为滚动。例如，如果PWM_PR[PERIOD]=0x0000，则计数器在等于0x0001时复位。当PWM_PR[周期]=0xFFFF或0xFFFE时，计数器在等于0xFFFF时复位。有关更多信息，请参阅PWM周期寄存器（PWM_PR）说明。
&emsp;&emsp;在滚动事件期间，通过 control register 的 POUTC 字段来设置为set(default), reset或no effect。如果在控制寄存器中设置了相应的中断启用位，则此事件也会生成中断。
&emsp;&emsp;当计数器值达到采样值时，根据控制寄存器 POUTC 字段的编程，PWM 输出复位（默认）、置位或无效。此事件称为比较事件。如果在控制寄存器中设置了相应的中断启用位，则此事件也会生成中断。
&emsp;&emsp;如果翻滚事件设置PWM输出信号，则比较事件将对其进行重置，反之亦然，用于 POUTC 字段的特定编程配置。
##### 40.4.1.3 低功耗模式行为
&emsp;&emsp;在低功耗模式下，如果来自所选时钟源的时钟可用，则 PWM 计数器继续运行并产生输出，具体取决于是否设置了该模式的控制位。 在没有时钟本身的情况下，或者如果控制寄存器中相应的低功耗位为 0，则计数器复位并在退出低功耗模式时恢复计数。 
##### 40.4.1.3 Debug 模式行为
&emsp;&emsp;在调试模式下，PWM 可以选择继续运行或停止。 如果 PWM_PWMCR 中的 DBGEN 位未设置，则 PWM 停止。 如果 DBGEN 位置位，那么 PWM 将继续在调试模式下运行。 
### 40.5 使能PWM操作序列
1. 失能PWM（PWMx_PWMCR[0]=0），再设置所需要的PWM控制寄存器（PWMx_PWMCR）。
2. 在PWM中断寄存器（PWMx_PWMIR）中启用所需的中断。
3. 一到三个初始样本可写入PWM样本寄存器（PWMx_PWMSAR）。即使PWM尚未启用，初始采样值也将加载到PWM FIFO中。不要写入第四个样本，因为FIFO将变满并触发FIFO写入错（FWE）。一旦启用，该错误将阻止PWM启动。
4. 检查PWM状态寄存器（PWMx_PWMSR）中的FIFO写入错误状态位（FWE）、比较状态位（CMP）和翻滚状态位（ROV），确保它们都为零。任何非零状态位都应通过向其写入1来清除。
5. 将所需周期写入PWM周期寄存器（PWMx_PWMPR）。
6. 通过将1写入PWM启用位PWMx_PWMCR[0]来启用PWM，同时将其他寄存器位保持在其先前配置的状态。
### 40.6 失能PWM操作序列
&emsp;&emsp;通过清除PWM使能位PWMx_PWMCR[0]至0，可随时禁用PWM。
&emsp;&emsp;禁用PWM后，FIFO中剩余的任何数据将不会在PWM输出处产生，并将保留在FIFO中，直到再次启用PWM。软件复位（将PWMx_PWMCR[3]设置为1）或硬件复位将清除FIFO，所有剩余数据将丢失。
### 40.7 PWM 寄存器
&emsp;&emsp;一共有8个PWM，每个PWM有6个寄存器。
#### 40.7.1 PWM Control Register (PWMx_PWMCR)
&emsp;&emsp;PWM 控制寄存器 (PWM_PWMCR) 用于配置 PWM 的操作设置。 它包含时钟分频的预分频器。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-28 reserved |                                                              |
| 27-26 FWM      | FIFO Water Mark。这两位被用于设置“FIFO 中的数据为多少时 FIFO empty flag 被设置”，且产生相应的中断<br>00    当 FIFO 中有 ≥ 1 空槽时，设置 FIFO empty<br>01    当 FIFO 中有 ≥ 2 空槽时，设置 FIFO empty<br>10    当 FIFO 中有 ≥ 3 空槽时，设置 FIFO empty<br>11    当 FIFO 中有 ≥ 4 空槽时，设置 FIFO empty |
| 25 STOPEN      | 使能 stop mode。 该位在停止模式下保持 PWM 功能。 当该位清零时，输入时钟在停止模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在停止模式下无效 <br>1    在停止模式下有效 |
| 24 DOZEN       | 使能 doze mode（打盹模式）。 该位使 PWM 在 doze 模式下保持功能。 当该位清零时，输入时钟在 doze 模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在 doze 模式下无效<br>1    在 doze 模式下有效 |
| 23 WAITEN      | 使能等待模式。 该位使 PWM 在等待模式下保持功能。 当该位清零时，输入时钟在等待模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。<br>0    在等待模式下有效<br>1    在等待模式下无效 |
| 22 DBGEN       | 使能调试模式。 该位使 PWM 在调试模式下保持功能。 当该位清零时，输入时钟在调试模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在调试模式下有效<br>1    在调试模式下无效 |
| 21 BCTR        | 字节数据交换控制。 该位决定 16 位数据从采样寄存器进入 FIFO 时的字节顺序。 <br>0    保持相同的字节序<br>1    字节序反转 |
| 20 HCTR        | 半字数据交换控制。 该位决定将来自 32 位 IP 总线接口的哪个半字数据写入采样寄存器的低 16 位。 <br>0    半字交换不发生<br>1    交换写数据总线的半个字 |
| 19-18 POUTC    | PWM 输出配置。 该位确定输出引脚上 PWM 输出的模式。 <br>00    输出引脚在翻转时设置并在比较时清除 <br>01    输出引脚在翻转时清零并在比较时设置  <br>10    PWM输出断开  <br>11    PWM输出断开 |
| 17-16 CLKSRC   | 选择时钟源。 这些位确定将选择哪个时钟输入来运行计数器。 复位后选择系统功能时钟。 如果这些位设置为 00，也可以关闭输入时钟。该字段值仅应在失能 PWM 时更改 <br>00    关闭时钟<br>01    ipg_clk<br>10    ipg_clk_highfreq<br>11    ipg_clk_32k |
| 15–4 PRESCALER | 计数器时钟预分频器值。 该位字段确定时钟在进入计数器之前将被分频的值。 <br>0x000    1 分频<br>0x001    2 分频<br>0xfff    4096分频 |
| 3 SWR          | 软件复位。当此位设置为 1 时 PWM 复位。它是一个自清除位。向该位写 1 是一个等待状态的写周期。 当模块处于复位状态时，该位被设置，并在复位过程结束时被清除。 设置该位会将所有寄存器复位为其复位值，但该控制寄存器中的 DBGEN、STOPEN、DOZEN 和 WAITEN 位除外。 <br>0    PWM 未复位<br>1    PWM PWM 正在复位 |
| 2-1 REPEAT     | 采样重复次数。 该位字段确定使用 FIFO 中每个采样值的次数。 <br>00    使用每个采样值 1 次<br>01    使用每个采样值 2 次<br>10    使用每个采样值 4 次<br>11    使用每个采样值 8 次 |
| 0 EN           | PWM 使能。 该位使能 PWM。 如果该位未使能，则时钟预分频器和计数器复位。 当 PWM 使能时，它开始一个新的周期，输出引脚设置为开始一个新的周期，同时释放预分频器和计数器并开始计数。 <br>要使 PWM 与软复位和使能/失能一起工作，用户可以通过设置 SWR 位进行软件复位，等待软件复位完成，配置寄存器，然后通过将该位设置为“1”来启用 PWM <br>如果 PWM 想要使用相同的寄存器配置停止和恢复，用户还可以使能/失能 PWM。 <br>0    PWM 失能<br>1    PWM 使能 |

#### 40.7.2 PWM Status Register (PWMx_PWMSR)
&emsp;&emsp;PWM 状态寄存器 (PWM_PWMSR) 包含 7 个位，用于显示 FIFO 的状态以及翻转和比较事件的发生。 FIFOAV 位是只读的，但其他四位可以通过向它们写入 1 来清除。 FE、ROV 和 CMP 位分别与 FIFO-Empty、Roll-over 和 Compare 中断相关联。 

| 位            | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 31-7 Reserved |                                                              |
| 6 FWE         | FIFO 写错误状态。 该位表示已尝试在 FIFO 已满时对其进行写入。 <br>0    没有发生 FIFO 写错误<br>1    发生了 FIFO 写错误 |
| 5 CMP         | 比较状态位。此位表明发生了一个比较事件。<br>0    没有发生比较事件<br>1    发生了比较事件 |
| 4 ROV         | 反转状态位。 该位表明发生了一个翻转事件。<br>0    没有发生反转事件<br>1    发生了反转事件 |
| 3 FE          | FIFO 空状态位。 该位指示 FIFO 数据级别与控制寄存器中 FWM 字段设置的水位的比较。 <br>0    Data level is above water mark<br>1    When the data level falls below the mark set by PWM field |
| FIFOAV        | FIFO 可用。 这些只读位指示 FIFO 中剩余的数据级别。 尝试写入这些位不会影响它们的值，并且不会产生传输错误。<br>000    没有有效数据<br>001    FIFO 中有一个 word 的数据 <br>010    FIFO 中有两个 word 的数据<br>011    FIFO 中有三个 word 的数据<br>100    FIFO 中有四个 word 的数据<br>101    未使用<br>110    未使用<br>111    未使用 |

#### 40.7.3 PWM Interrupt Register (PWMx_PWMIR)
&emsp;&emsp;PWM 中断寄存器 (PWM_PWMIR) 包含三个位，用于控制比较、翻转和 FIFO 空中断的产生。 

| 位            | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 31-3 reserved |                                                              |
| 2 CIE         | 比较中断使能位。此位控制比较中断的产生<br>0    比较中断未使能<br>1    比较中断使能 |
| 1 RIE         | 翻转中断使能位。此位控制翻转中断的产生<br>0    翻转中断未使能<br>1    翻转中断使能 |
| 0 FIE         | FIFO 空中断使能。此位控制 FIFO 空中断的产生<br>0    使能 FIFO 空中断<br>1    使能 FIFO 空中断 |

#### 40.7.4 PWM Sample Register (PWMx_PWMSAR)
&emsp;&emsp;PWM 采样寄存器 (PWM_PWMSAR) 是 FIFO 的输入。 16 位字被加载到 FIFO。 FIFO 可以随时写入，但只能在 PWM 使能时读取。 如果 FIFO 的所有值都已被使用，PWM 将以最后设置的占空比设置运行，直到重新加载 FIFO 或禁用 PWM。 当写入新值时，占空比会在当前周期结束后发生变化。
&emsp;&emsp;采样寄存器中的零值将导致 PWMO 输出信号始终为低/高（POUTC = 00 为低，POUTC = 01 为高），不会产生输出波形。 如果此寄存器中的值高于 PERIOD + 1，则输出将永远不会根据 POUTC 值设置/重置。

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| SAMPLE         | 样本值。 这是 4x16 FIFO 的输入。 该寄存器中的值表示当前正在使用的样本的值。 |

 

#### 40.7.5 PWM Period Register (PWMx_PWMPR)
&emsp;&emsp;PWM 周期寄存器 (PWM_PWMPR) 决定 PWM 输出信号的周期。 计数器值与 PERIOD + 1 匹配后，计数器复位以开始另一个周期。 
PWMO (Hz) = PCLK(Hz) / (period +2)
&emsp;&emsp;PWM_PWMPR 中的零值将导致输出信号的周期为两个时钟周期。 向该寄存器写入 0xFFFF 将获得与写入 0xFFFE 相同的结果。
&emsp;&emsp;由于写入 PWM_PWMPR 而导致的周期值变化会导致计数器重置为零并开始新的计数周期。 
注意：当 PWMx_PWMCR REPEAT 位设置为非零值时，将 PWM_PWMPR 设置为 0xFFFF 是不允许的。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| PERIOD         | 周期值。 这些位确定计数周期的周期。 计数器计数到 [Period Value] +1，然后重置为 0x0000。 |

#### 40.7.6 PWM Counter Register (PWMx_PWMCNR)  
&emsp;&emsp;只读脉冲宽度调制器计数器寄存器 (PWM_PWMCNR) 包含当前计数值，可随时读取而不会干扰计数器。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| COUNT          | 计数器值。 这些位是计数器寄存器的值，表示计数器寄存器的当前计数状态。 |




## 第四十六章 SDMA
### 46.1 概述
&emsp;&emsp;智能直接内存访问 (SDMA) 控制器提供极具竞争力的 DMA 功能以及灵活的基于软件的虚拟 DMA。 它支持外围 I/O 设备和内部/外部存储器之间的数据传输。
&emsp;&emsp;SDMA 控制器通过在动态数据路由中卸载 Arm 内核来帮助最大限度地提高系统性能。 
#### 46.1.1 框图 
&emsp;&emsp;下图显示了 SDMA 控制器的框图。 它包括自定义 RISC 内核及其 RAM、ROM、DMA 单元和调度程序。 


&emsp;&emsp;SDMA核心执行<u>执行DMA传输</u>的短例程；这些例程称为脚本。SDMA核心通过SDMA系统总线连接到自己的内存。SDMA系统总线支持32位数据路径和16位地址总线。系统总线数据路径用于16位指令（程序）内存访问和32位数据访问。DMA单元通过功能单元总线与核心接口，并使用专用寄存器执行DMA传输。
&emsp;&emsp;SDMA内存包含一个 ROM 和一个 RAM 。ROM包含启动脚本（例如，启动代码）和其他公用工具，它们由驻留在 RAM 中的脚本引用。内部 RAM 分为上下文区域和脚本区域（有关此映射的更多详细信息，请参阅指令内存映射和数据内存映射）。
&emsp;&emsp;每个传输通道在不活动时都需要一个上下文区域来保持所有内核和单元寄存器的内容。通道脚本由 SDMA 使用在引导序列期间启动的专用通道下载到内部 RAM。使用 Arm 平台提供的命令和指针调用下载。每个通道都包含位于 RAM 和/或 ROM 中的相应通道脚本，可以根据需要独立重新配置。通道脚本可以存储在外部存储器中，并在需要时下载。SDMA 可以配置任何脚本组合，以实现支持服务的无限组合。 




















## 第四十八章 SNVS 安全非易失性存储
### 48.1 概述
&emsp;&emsp;智能直接内存访问 (SDMA) 控制器提供极具竞争力的 DMA 功能以及基于软件的虚拟 DMA 灵活性。 它支持外围 I/O 设备和内部/外部存储器之间的数据传输。
&emsp;&emsp;SDMA 控制器通过在动态数据路由中卸载 Arm 内核来帮助最大限度地提高系统性能。 


## 第五十二章 Temperature Monitor 温度监测器
### 52.1 概述
&emsp;&emsp;温度传感器模块基于与温度相关的电压到时间的转换来实现温度传感/转换功能。 
&emsp;&emsp;该模块具有报警功能，如果温度高于两个高温阈值和低于一个低温阈值，可以发出独立的中断信号。这些温度阈值是可编程的，并指定为低、高和紧急温度。紧急阈值是一个特殊的可编程阈值，因为如果温度升高到该值以上并且在系统复位控制器中启用了温度紧急复位中断，则硬件将假定软件不再控制热情况并启动芯片复位。 
&emsp;&emsp;为了避免错误的紧急温度启动复位，在连续四个转换周期满足温度紧急条件之前，紧急警报不会触发。也可以对自重复模式进行编程，该模式基于可编程的延迟执行温度感测操作。 
&emsp;&emsp;由于高温和低温阈值是可编程的，因此它们形成了一个可根据应用需求量身定制的滑动温度支架。 例如，在启动时，软件可以将低温阈值设置为系统的最低温度代码，将高温阈值设置为系统的最高工作温度。
&emsp;&emsp;然后，系统可以使用该模块来监控片上温度，并在设置高温中断时采取适当的措施，例如节流内核频率。 一旦设置了高温中断，系统就可以将低温阈值编程为所需的冷却温度。 然后系统将切换到监测低温警报并等待其中断被设置。 通过这种方案，一旦设置了低温中断，软件就可以确保温度已经冷却到安全水平，并且可以重复该过程。 
&emsp;&emsp;如上图所示，温度传感器使用并假设带隙参考、480MHz PLL 和 32KHz RTC 模块已正确编程并完全稳定以进行正确操作。 
### 52.2 软件使用指南
&emsp;&emsp;在系统正常运行期间，软件可以使用温度传感器计数器的输出 (TEMP_CNT) 和熔断器温度校准数据来确定片上运行温度或将过温中断警报设置在几°C 以内。
&emsp;&emsp;根据校准，可通过设备上的保险丝获得两组温度和计数器值。 这些数据点将对应于下面曲线中的点 (N1, T1) 和 (N2, T2)。 
&emsp;&emsp;在一次温度测量周期之后，软件应结合使用校准点和 TEMPMON_TEMPSENSE0[TEMP_CNT] 位域中的温度编码值，使用以下公式计算设备的温度： 
$$T_{meas} = T_2 - (N_{meas} - N_2) * ((T_2 - T_1)/(N_1 - N_2))$$
&emsp;&emsp;同样，为了确定要写入 TEMPMON_TEMPSENSE0 寄存器中的警报计数器值，用于基于温度的中断，可以根据所需的温度触发器对应使用的 $N_{meas}$ 值求解上述等式。
&emsp;&emsp;OCOTP_ANA1 寄存器中提供了温度校准点保险丝值。 在产品测试过程中，每个部件的温度校准值都是单独融合的。 下表描述了该寄存器的字段。 
### 52.3 TEMPMON 寄存器定义
#### 52.3.1 Tempsensor Control Register 0
&emsp;&emsp;此寄存器定义了温度传感器的基本控制位，除了在 tempsensor 中定义的采样频率。
* 31-20 ALARM_VALUE 温度计数值（原始传感器的输出），此值可以产生警告中断。
* 19-8 TEMP_CNT 上次的温度计数值。
* 2 FINISHED 表明上次采样有效。每次监测开始之后，sensor应该清空此位
  * 0 INVALID 上次监测还未准备好
  * 1 VALID 上次监测有效
* 1 MEASURE_TEMP 开始监测过程。如果在 TEMPSENSE1 寄存器中监测频率是0，此结果是单次转换。
  * 0 STOP 不开始监测过程
  * 1 START 开始监测过程
* 0 POWER_DOWN 此位控制传感器的电源开关
  * 0 POWER UP
  * 1 POWER DOWN
#### 52.3.2 Tempsensor Control Register 1
&emsp;&emsp;该寄存器定义了温度传感器的自动重复时间。 
#### 52.3.3 Tempsensor Control Register 2
* 27-16 PANIC_ALARM_VALUE 
* 11-0 LOW_ALARM_VALUE

## imx_thermal.c文件分析









