## 第十五章 AHB-to-APBH Bridge with DMA (APBH-Bridge-DMA)
### 15.1 概述
&emsp;&emsp;AHB-to-APBH 桥接器为芯片提供了在 AHB 的 HCLK 上运行的廉价外设连接总线。 （APBH 中的 H 表示 APBH 与 HCLK 同步。）  
&emsp;&emsp;如下图所示，AHB-to-APBH 桥包括 AHB-to-APB PIO 桥，用于到 APB 设备的内存映射 I/O，以及用于该总线上的设备的中央 DMA 设施和一个 Arm内核的向量中断控制器。 每个 APB 外设，包括向量中断控制器，都在各自的章节中进行了记录。  
&emsp;&emsp;DMA 控制器使用 APBH 总线向每个外设传输读写数据。 这些设备没有单独的 DMA 总线。 DMA 对 APBH 总线的使用与 AHB 到 APB 桥功能对 APBH 的使用之间的争用由内部仲裁逻辑调解。 对于这两个单元之间的竞争，DMA 受到青睐，AHB 从设备将通过其 HREADY 输出报告“未准备好”，直到桥接传输完成。 仲裁器跟踪重复的锁定并反转优先级，保证 APB 上每四次传输一次 Arm 平台。 
### 15.2 时钟
&emsp;&emsp;此处的表格描述了 APBH 的时钟源。 有关时钟设置、配置和门控信息，请参阅时钟控制器模块 (CCM)。 
### 15.3 APBH DMA
&emsp;&emsp;DMA 支持四个通道的 DMA 服务，如下表所示。 共享 DMA 资源允许每个独立通道遵循简单的链式命令列表。 命令链使用通用结构构建，如图 15-2 所示。 
&emsp;&emsp;单个命令结构体或通道命令字指定由 DMA 执行以支持给定设备的许多操作。 因此，Arm 平台可以设置大型工作单元，将许多 DMA 通道命令字链接在一起，将它们传递给 DMA，并且在 DMA 完成中断发生之前不再关心设备。 目标是在 DMA 和设备中具有足够的智能，以将来自任何设备的中断频率保持在 1 KHz 以下（到达间隔长于 1 ms）。 
&emsp;&emsp;单个命令结构可以使用相同的 APB 总线向相关设备中的关键寄存器发出 32 位 PIO 写操作，并控制它用于将 DMA 数据字节写入设备。 例如，这允许向 GPMI 控制器发出一系列操作，以发送 NAND 命令字节、地址字节和数据传输，其中命令和地址结构完全受软件控制，但该传输的管理是由 DMA 自主处理的。 每个 DMA 结构可以附加 0-15 个 PIO 字。 CMDPIOWORDS 字段（如果非零）指示 DMA 引擎将这些字复制到 APB，从外设的第一个寄存器地址偏移量开始，并在每个周期递增寄存器偏移量。 
&emsp;&emsp;DMA 主机仅生成到 APBH 的正常读/写传输。 它不会生成设置、清除或切换 (SCT) 传输。 
&emsp;&emsp;在任何请求的 PIO 字传输到外设后，DMA 检查通道命令结构中的两位命令字段。 表 15-3 显示了 DMA 实现的四个命令。 
&emsp;&emsp;DMA_WRITE 操作将数据字节从相关外设复制到系统存储器（片上 RAM 或 SDRAM）。 
&emsp;&emsp;DMA_READ 操作将数据字节从系统存储器复制到 APB 外设。 DMA 引擎包含一个共享字节对齐器，用于对齐来自系统存储器和外设的字节。 外设总是假设小端对齐的数据到达或离开它们的 32 位 APB。 DMA_READ 传输使用命令结构中的 BUFFER_ADDRESS 字指向要由 DMA_READ 命令读取的 DMA 数据缓冲区。
&emsp;&emsp;NO_DMA_XFER 命令用于将 PIO 字写入设备而不执行任何 DMA 数据字节传输。 此命令在激活 NAND 设备 CHECKSTATUS 操作等应用中很有用。 检查状态命令从 NAND 设备读取状态字节，对作为 PIO 传输的一部分提供的预期值执行 XOR 和 MASK。 读取检查完成后（请参阅 NAND 读取状态轮询示例），NO_DMA_XFER 命令完成。 外设中的结果是其感测线由比较结果驱动。 感测触发器仅由执行的设备的 CHECKSTATUS 更新。 在未来的某个时刻，该链包含具有第四个也是最后一个命令值的 DMA 命令结构，即 DMA_SENSE 命令。 
&emsp;&emsp;随着每个 DMA 命令完成，它会触发 DMA 加载链中的下一个 DMA 命令结构。 DMA命令的正常流列表是通过跟踪DMA命令结构中的NEXTCMD_ADDR指针找到的。 DMA_SENSE 命令使用命令结构的 DMA 缓冲区指针字指向备用 DMA 命令结构链或列表。 DMA_SENSE 命令检查相关外设的检测线。 如果检测线为假，则 DMA 遵循找到的标准列表，其下一个命令是从命令结构的 NEXTCMD_ADDR 字中的指针中找到的。 如果检测线为真，则 DMA 遵循备用列表，其下一个命令是从 DMA_SENSE 命令结构的 DMA 缓冲区指针字中的指针中找到的（见图 15-2）。 检测命令忽略 CHAIN 位，因此当 DMA 发出检测命令时，两个指针都必须有效。  
&emsp;&emsp;如果在命令结构中设置了等待结束命令位 (WAIT4ENDCMD)，则 DMA 通道通过切换 endcmd 信号等待设备发出命令完成信号，然后再继续加载和执行下一个命令结构。 然后，如果设置了 DECREMENT_SEMAPHORE，则在看到结束命令后减少信号量。  
&emsp;&emsp;下表显示了 DMA 命令结构的详细位字段视图，其中显示了一个字段，该字段指定此 DMA 命令要传输的字节数。 传输计数机制在相关外设中复制，作为外设中的隐含或指定计数。  
&emsp;&emsp;Freq_i图 15-2 还显示了命令结构的第二个字的位 2 中的 CHAIN 位。 如果 NEXT_COMMAND_ADDRESS 包含指向另一个 DMA 命令结构的指针，则该位设置为 1。 如果将空指针 (0) 加载到 NEXT_COMMAND_ADDRESS 中，则 DMA 硬件不会检测到它。 只有 CHAIN 位指示在当前结构之外是否存在有效列表。  
&emsp;&emsp;如果在命令结构中设置了 IRQ_COMPLETE 位，则 DMA 在加载下一条命令之前的最后一个动作是设置当前通道对应的中断状态位。 DMA CSR 中的粘滞中断请求位保持置位，直到被软件清除。 它可以用来中断ARM平台。  
&emsp;&emsp;NAND_LOCK 位由 DMA 通道仲裁器监控。 在其 NAND_LOCK 位设置的仲裁器中成功，然后仲裁器忽略其他 NAND 通道，直到完成未设置 NAND_LOCK 的命令。 请注意，这里的语义是 NAND_LOCK 状态是限制非锁定 DMA 的调度。 当 NAND_LOCK 位置位时，DMA 通道可以在命令开始时在仲裁器中从解锁状态变为锁定状态。 当原子序列的最后一个 DMA 命令完成时，应该解除锁定。 为此，最后一条命令没有 NAND_LOCK 位。 命令启动时，它仍然被锁定在仲裁器内部的原子状态，因此它是唯一可以执行的 NAND 命令。 最后，它从仲裁器中的原子状态下降。  
&emsp;&emsp;NAND_WAIT4READY 位对 GPMI 通道（从通道到通道）也有特殊用途，即 NAND 设备通道。 GPMI 外设提供来自 NAND 设备的就绪行的样本。 该就绪值用于延迟该位设置的命令，直到就绪行断言为 1。一旦仲裁器看到设置了等待就绪的命令，它就会延迟该通道，直到断言就绪。  
&emsp;&emsp;接收 HALTONTERMINATE (HOT) 的 IRQ 是 APBH DMA 描述符中的一项功能，它允许 GPMI 向 DMA 引擎发送已发生错误的信号。 如果命令由于错误而停止，则从外设向 DMA 引擎发送 HOT 信号，并在终止正在执行的 DMA 描述符后引发 IRQ。  
&emsp;&emsp;因此，建议软件按如下方式使用该信号： 
* 在 DMA 描述符中始终将 HALTONTERMINATE 设置为 1。 这样，如果外设发出 HOT 信号，传输将结束，使外设块和 DMA 引擎保持同步（但在命令结束时）。 
* 当接收到来自 APBH 通道的 IRQ，并且确定该 IRQ 是由于错误（与 IRQONCOMPLETE 中断相反）导致的，软件应该： 
  * 复位通道；
  * 根据外设模块中的错误报告确定错误，然后以该设备存在的任何适当方式（软件恢复、设备复位、模块复位等）管理连接到该通道的外设中的错误。 

&emsp;&emsp;每个通道都有一个八位计数信号量，用于控制它是否处于空闲状态。 当信号量不为零时，通道已准备好运行、处理命令并执行 DMA 传输。 每当命令完成其 DMA 传输时，它都会检查 DECREMENT_SEMAPHORE 位。 如果设置，它会减少计数信号量。 如果信号量因此变为 0，则通道进入空闲状态并保持在那里，直到信号量被软件递增。 当信号量变为非零且通道处于空闲状态时，它使用 APBH_CHn_NXTCMDAR 寄存器（下一个命令地址寄存器）中的值来获取指向下一个要处理的命令的指针。 
&emsp;&emsp;注意：这是一个双重间接案例。 这种方法允许软件在计数信号量的保护下附加到一个正在运行的命令列表。  
&emsp;&emsp;第一次开始处理时，软件会创建要处理的命令列表。 它将第一个命令的地址写入 APBH_CHn_NXTCMDAR 寄存器，然后将 1 写入 APBH_CHn_SEMA 中的计数信号量。 DMA 通道加载 APBH_CHn_CURCMDAR 寄存器，然后进入正常状态机处理下一条命令。 当软件向计数信号量写入一个值时，它会被硬件添加到信号量计数中，以保护硬件和软件都试图在同一时钟沿更改信号量的情况。  
&emsp;&emsp;软件可以随时检查 APBH_CHn_CURCMDAR 的值以确定当前正在处理的命令结构的位置。 

### 15.5 寄存器定义
#### 15.5.1 AHB 到 APBH 桥接控制和状态寄存器 0（APBH_CTRL0n）
&emsp;&emsp;APBH CTRL 0 提供对 AHB 到 APBH 桥接和 DMA 的整体控制。  
&emsp;&emsp;该寄存器包含模块软复位、时钟门控、通道时钟门控/冻结位。 

| 位               | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 31 SFTRST        | 将此位设置为零以启用正常的 APBH DMA 操作。 将此位设置为 1（默认）以禁用 APBH DMA 的时钟并将其保持在其复位（最低功耗）状态。 该位可以打开然后关闭，以将 APBH DMA 块重置为其默认状态。（软件复位） |
| 30 CLKGATE       | 该位必须设置为零才能正常运行。 当设置为 1 时，它会关闭模块的时钟。 |
| 29 AHB_BURST8_EN | 将此位设置为 1（默认）以使能 AHB 8-beat burst。设置为 0 失能 AHB 上的 8-beat burst。 |
| 28 APB_BURST_EN  | 将此位设置为 1 可在设备请求 burst dma 时使能 apb 主机进行连续传输。 设置为 0 会将 burst dma 请求视为 4/8 个单独的请求。 |
| 27 RSVD0         |                                                              |
| CLKGATE_CHANNEL  | 为了每个通道的正常操作，这些位必须设置为零。 当设置为 1 时，它们会关闭通道的各个时钟。<br>0x0001    NAND0<br>0x0002    NAND1<br>0x0004    NAND2<br>0x0008    NAND3<br>0x0010    NAND4<br>0x0020    NAND5<br>0x0040    NAND6<br>0x0080    NAND7<br>0x0100    SSP |

#### 15.5.2 AHB 到 APBH 桥接控制和状态寄存器 1（APBH_CTRL1n）
&emsp;&emsp;APBH CTRL 1 提供对 AHB 对 APBH DMA 产生的中断的整体控制。 该寄存器包含每个通道的中断状态位和每个通道的中断使能位。 每个通道在向量中断控制器中都有一个专用的中断向量。 

| 位                      | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 31 CH15_CMDCMPLT_IRQ_EN | 设置该位可以使能 APBH DMA 通道 15 生成中断的请求。           |
| ......                  |                                                              |
| 15 CH15_ CMDCMPLT_ IRQ  | APBH DMA 通道 15 的中断请求状态位。该粘性位由 DMA 硬件设置并由软件复位。 它与相应的使能位进行“与”运算以产生中断。 |
| ......                  |                                                              |

#### 15.5.3 AHB 到 APBH 桥接控制和状态寄存器 2（APBH_CTRL2n）
&emsp;&emsp;APBH CTRL 2 将 AHB 生成的通道错误中断提供给 APBH DMA。 该寄存器包含每个通道的中断状态位和每个通道的中断使能位。 每个通道在向量中断控制器中都有一个专用的中断向量。 

| 位                    | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| 31 CH15_ERROR_ STATUS | APBH DMA 通道 15 的错误状态位。当相应的 Error IRQ 被设置时有效。<br>1：AHB bus error<br>0：通道提前终止。<br>0x0    TERMINATION：设备提前终止会导致错误 IRQ。<br>0x1    BUS_ERROR：AHB 总线错误导致错误 IRQ。 |
| .......               |                                                              |
| 15 CH15_ERROR_ IRQ    | APBH DMA 通道 15 的错误中断状态位。该粘性位由 DMA 硬件设置并由软件复位。 它与相应的 cmdcmplt irq 进行 OR 运算以生成 ARM 的 irq。 |
| ......                |                                                              |

#### 15.5.4 AHB 到 APBH 桥接通道寄存器（APBH_CHANNEL_CTRLn）
&emsp;&emsp;APBH CHANNEL CTRL 提供每个 DMA 通道的复位/冻结控制。 该寄存器包含单独的通道复位/冻结位。 

| 位                  | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| 31-16 RESET_CHANNEL | 在该字段中设置一个位会导致 DMA 控制器通过其复位状态获取相应的通道。 清除通道资源后，该位复位。<br>0x0001    NAND0<br/>0x0002    NAND1<br/>0x0004    NAND2<br/>0x0008    NAND3<br/>0x0010    NAND4<br/>0x0020    NAND5<br/>0x0040    NAND6<br/>0x0080    NAND7<br/>0x0100    SSP |
| FREEZE_CHANNEL      | 在该字段中设置一个位将冻结与其关联的 DMA 通道。 该字段是 DMA 通道仲裁器的直接输入。 冻结时，通道被定义为访问中央 DMA 资源。<br>0x0001    NAND0<br/>0x0002    NAND1<br/>0x0004    NAND2<br/>0x0008    NAND3<br/>0x0010    NAND4<br/>0x0020    NAND5<br/>0x0040    NAND6<br/>0x0080    NAND7<br/>0x0100    SSP |
#### 15.5.5 AHB 到 APBH DMA 设备分配寄存器 
&emsp;&emsp;没用
#### 15.5.6 AHB 到 APBH DMA burst size（APBH_DMA_BURST_SIZE）
&emsp;&emsp;当发出 DMA burst 请求时，该寄存器对 APBH DMA 设备的 apbh burst size 进行编程。
&emsp;&emsp;该寄存器提供了一种分配设备的机制。 

| 位        | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| 17–16 CH8 | DMA burst size for SSP.<br>0x0    BURST0<br>0x1    BURST4<br>0x2    BURST8 |
| 15–14 CH7 | GPMI 通道 7 的 DMA burst 大小。不要更改。 GPMI 仅支持 burst 大小 4。 |
|           |                                                              |

#### 15.5.7 AHB to APBH DMA Debug 寄存器 (APBH_DEBUG)
&emsp;&emsp;该寄存器用于调试目的。
&emsp;&emsp;调试寄存器仅供内部使用。 不推荐客户使用。 

#### 15.5.8 APBH DMA 通道 n 当前命令地址寄存器 (APBH_CHn_CURCMDAR) 
&emsp;&emsp;APBH DMA 通道 n 当前命令地址寄存器指向当前正在执行的多字命令。 命令在命令地址上线程化。
&emsp;&emsp;APBH DMA 通道 n 由可变大小的命令结构控制。 该寄存器指向当前正在执行的命令结构。 

| 位       | 描述                                        |
| -------- | ------------------------------------------- |
| CMD_ADDR | 指向当前正在为通道 n 处理的命令结构的指针。 |

#### 15.5.9 APBH DMA 通道 n 下一个命令地址寄存器 (APBH_CHn_NXTCMDAR) 
&emsp;&emsp;APBH DMA 通道 n 下一个命令地址寄存器包含要执行的下一个多字命令的地址。 命令在命令地址上线程化。 在 DMA 命令字中将 CHAIN 设置为 1 以处理命令列表。
&emsp;&emsp;APBH DMA 通道 n 由可变大小的命令结构控制。 软件将第一个命令结构的地址加载到该寄存器以进行处理，并增加通道 n 信号量以开始处理。 该寄存器指向当前命令完成时要执行的下一个命令结构。 

| 位       | 描述                                        |
| -------- | ------------------------------------------- |
| CMD_ADDR | 指向下一条为通道 n 处理的命令结构的指针。 |

#### 15.5.10 APBH DMA 通道 n 命令寄存器 (APBH_CHn_CMD) 
&emsp;&emsp;APBH DMA 通道 n 命令寄存器指定要为当前命令链项执行的 DMA 事务。
&emsp;&emsp;命令寄存器控制该通道的每个 DMA 命令的整体操作。 它包括传输到设备或从设备传输的字节数、包含在此命令结构中的 APB PIO 命令字的数量、是否在命令完成时中断、是否将附加命令链接到该命令的末尾以及此传输是否是读或写 DMA 传输。 

| 位                | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| 31-16 XFER_COUNT  | 该字段指示与 GPMI0 设备中适当的 PIO 寄存器之间传输的字节数。 值 0 表示 64 KB 传输。 |
| 15–12 CMDWORDS    | 该字段指示要发送到 GPMI0 的命令字的数量，从 GPMI0 控制寄存器的 PIO 基地址开始并从那里递增。 零表示无传输命令字 |
| 11-9 reserved     |                                                              |
| 8 HALTONTERMINATE | 值 1 表示如果设置了终止信号，通道将立即终止当前描述符并停止 DMA 通道。 如果设置了终止信号，值 0 仍将导致通道立即终止，但通道将继续运行，就好像计数已用完一样，这意味着它将遵循 IRQONCMPLT、CHAIN、SEMAPHORE 和 WAIT4ENDCMD。 |
| 7 WAIT4ENDCMD     | 值 1 表示通道将等待命令结束信号从 APBH 设备发送到 DMA，然后再开始下一个 DMA 命令。 |
| 6 SEMAPHORE       | 值 1 表示通道将在当前命令结构完成时减少其信号量。 如果信号量减为零，则此通道停止，直到软件再次增加它。 |
| 5 NANDWAIT4READY  | 值 1 表示 NAND DMA 通道将等到 NAND 设备报告“就绪”后再执行命令。 对于非 NAND DMA 通道，它会被忽略。 |
| 4 NANDLOCK        | 值 1 表示 NAND DMA 通道将在仲裁器中保持“锁定”状态，但会牺牲其他 NAND DMA 通道。 对于非 NAND DMA 通道，它会被忽略。 |
| 3 IRQONCMPLT      | 值 1 表示通道将在当前命令完成后（即 DMA 传输完成后）设置中断状态位。 |
| 2 CHAIN           | 值 1 表示另一个命令链接到当前命令结构的末尾。 当前命令完成后，该通道将跟随 APBH_CHn_CMDAR 中的指针寻找下一条命令。 |
| COMMAND           | 该位域指示当前命令的类型： <br>0x0    NO_DMA_XFER：执行任何请求的 PIO 字传输，但在任何 DMA 传输之前终止命令。 <br>0x1    DMA_WRITE：执行任何请求的 PIO 字传输，然后从外设执行指定字节数的 DMA 传输。 <br>0x2    DMA_READ：执行任何请求的 PIO 字传输，然后针对指定字节数执行到外设的 DMA 传输。 <br>0x3    DMA_SENSE：执行任何请求的 PIO 字传输，然后执行条件分支到下一个链接设备。 如果外围意义为真，则跟随 NEXCMD_ADDR 指针。 如果外围检测线为假，则将 BUFFER_ADDRESS 作为链指针。 |

#### 15.5.11 APBH DMA Channel n Buffer Address Register (APBH_CHn_BAR)
&emsp;&emsp;APBH DMA 通道 n 缓冲区地址寄存器包含一个指向用于传输的数据缓冲区的指针。 对于立即数形式，数据取自该寄存器。 这是一个字节地址，这意味着传输可以从任何字节边界开始。 
&emsp;&emsp;该寄存器保存指向系统内存中数据缓冲区的指针。 在命令值被读入 DMA 控制器和由该通道控制的设备之后，DMA 传输将开始，传输到或来自该寄存器指向的缓冲区。

| 位      | 描述                                               |
| ------- | -------------------------------------------------- |
| ADDRESS | 要通过 AHB 总线读取或写入的系统内存缓冲区的地址 。 |

#### 15.5.12 APBH DMA Channel n Semaphore Register (APBH_CHn_SEMA)
&emsp;&emsp;APBH DMA Channel n 信号量寄存器用于同步 Arm 平台指令流和 DMA 链处理状态。
每个 DMA 通道都有一个 8 位计数信号量，用于在程序流和 DMA 链处理之间进行同步。 DMA 处理将继续，直到 DMA 尝试减少已达到零值的信号量。 进行尝试时，DMA 通道会停止，直到软件增加信号量计数。 

| 位              | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| 31-24 reserved  |                                                              |
| 23-16 PHORE     | 此只读字段显示信号量计数器的当前（瞬时）值。                 |
| 15-8 reserved   |                                                              |
| INCREMENT_ SEMA | 写入此字段的值以原子方式添加到信号量计数中，从而保护在同一时钟上同时发生的软件添加和 DMA 硬件减法。 该位字段读回值 0x00。 写入 0x02 值会使信号量计数增加 2，除非 DMA 通道在同一时钟上减少计数，否则计数会增加净 1。 |

## 第四十章 PWM
### 40.1 概述
&emsp;&emsp;脉冲宽度调制 (PWM) 有一个 16 位计数器，并经过优化以从存储的样本音频图像中生成声音，它还可以生成音调。 它使用 16 位分辨率和 4 x 16 数据 FIFO。
本节概述了 PWM。 PWM 模块的框图如下图所示。 
&emsp;&emsp;PWM 具有以下特点： 
* 带时钟源选择的 16 位递增计数器 
* 4 x 16 FIFO 以最小化中断开销 
* 用于时钟分频的 12 位预分频器 
* 声音和旋律生成 
* 高电平有效或低电平有效配置输出 
* 可以编程为在低功耗模式下处于活动状态 
* 可以编程为在调试模式下处于活动状态 
* 比较和翻转时的中断 
### 40.2 外部信号 
&emsp;&emsp;PWM 在与处理器内核接口时遵循 IP 总线协议。 除了来自时钟控制模块 (CCM)、系统复位控制器 (SRC) 的时钟和复位输入以及处理器中断处理程序的中断信号外，PWM 与芯片内的任何其他模块没有任何接口信号。 有一个单一的输出信号。
&emsp;下表概述了外部信号。 

| Signal   | 描述                                                         | Pad            | Mode | 描述 |
| -------- | ------------------------------------------------------------ | -------------- | ---- | ---- |
| PWM1_OUT | 这是 PWM 的 PWM1 功能输出。 在此引脚上观察到模块的调制信号。 它可以看作是一个时钟信号，其周期和占空比可以随着 50% 周期的不同设置而变化。 | ENET1_RX_DATA0 | ALT2 | O    |
|          |                                                              | GPIO1_IO08     | ALT0 |      |
|          |                                                              | LCD_DATA00     | ALT1 |      |
| ......   |                                                              |                |      |      |
| PWM8_OUT |                                                              |                |      |      |

### 40.3 时钟
&emsp;&emsp;此处的表格描述了 PWM 的时钟源。 有关时钟设置、配置和门控信息，请参阅时钟控制器模块 (CCM)。   
&emsp;&emsp;可以从以下选项中选择预分频器的时钟： 
* 高频参考时钟 (ipg_clk_highfreq) pat_ref 或 CKIH 
  这是一个高频时钟，由时钟控制模块 (CCM) 提供。 当 ipg_clk 关闭时，该时钟应在低功耗模式下打开。 因此，PWM 可以在低功耗模式下在该时钟上运行。 CCM 预计在正常功能模式下将其同步到 ahb_clk 后提供此时钟，然后在低功耗模式下切换到非同步版本。  
* 低频参考时钟 (ipg_clk_32k, CKIL) 
  这是由 CCM 提供的 32 KHz 低频参考时钟。 当 ipg_clk 关闭时，该时钟应在低功耗模式下打开。 因此，PWM 可以在低功耗模式下在该时钟上运行。 CCM 预计在正常功能模式下将其同步到 ahb_clk 后提供此时钟，然后在低功耗模式下切换到非同步版本。 
* 外设时钟 (ipg_clk) 
  此时钟应在正常操作中打开。 在低功耗模式下，可以将其关闭。
* 外设访问时钟 (ipg_clk_s) 
  该时钟用于寄存器读/写。

&emsp;&emsp;时钟输入源由 PWM 控制寄存器字段 PWM_CR[CLKSRC] 确定。要更改 CLKSRC 值需要先失能 PWM。
&emsp;&emsp;控制寄存器的 PRESCALER 字段值的变化会立即反映在其输出时钟频率上。  

### 40.4 功能描述
&emsp;&emsp;下面的章节描述了 PWM 的操作和功能。
#### 40.4.1 操作
&emsp;&emsp;PWM 的输出是一个切换信号，其频率和占空比可以通过编程适当的寄存器来调制。 它有一个 16 位向上计数器，从 0x0000 开始计数，直到计数器值等于 PWM_PR + 1。匹配发生后，计数器重置为 0x0000。
&emsp;&emsp;在计数周期开始时，PWMO 引脚设置为 1（默认），计数器从 0x0000 开始向上计数。 在预分频器时钟的每个计数上比较采样 FIFO 中的采样值。 当采样值和计数值匹配时，PWMO 信号设置为 0（默认）。 计数器继续计数，直到周期匹配发生，随后另一个周期周期开始。
&emsp;&emsp;当 PWM 使能时，计数器开始运行并生成一个输出，其周期和采样值使用寄存器中复位时的值。 建议在启用 PWM 之前对这些寄存器进行编程。
&emsp;&emsp;硬件复位会导致所有 PWM 计数和采样寄存器被清除，FIFO 被刷新。 控制寄存器显示 FIFO 为空，可写入，PWM 关闭。 软件复位具有相同的结果，但是控制寄存器中的 DBGEN、STOPEN、DOZEN 和 WAITEN 位的状态不受影响。 即使 PWM 处于禁用状态，也可以断言软件复位。
##### 40.4.1.1 FIFO
&emsp;&emsp;数字采样值可以作为 16 位字加载到脉宽调制器中。可以使用控制寄存器的 BCTR 和 HCTR 位更改字节顺序。 4 字（16 位）FIFO 将中断开销降至最低。当数据字数低于控制寄存器中 FWM 字段设置的水位时，会产生可屏蔽中断。
&emsp;&emsp;如果 FIFO 未满，写入 PWM_SAR 采样寄存器会导致值被存储到 FIFO 中。 FIFO 满时写入会设置状态寄存器中的 FWE（FIFO 写入错误）位，并且 FIFO 内容保持不变。 FIFO 可以随时写入，但只能在 PWM 使能时读取。 PWM_SR[FIFOAV] 字段显示 FIFO 中当前包含多少数据字以及是否可以写入。
&emsp;&emsp;对采样寄存器的读取产生当前 FIFO 值，PWM 正在使用或将使用该值来生成输出信号。因此，对样本寄存器的写入和后续读取可能会导致获得不同的值。 
##### 40.4.1.2 翻转和比较事件 
&emsp;&emsp;在其值等于PWM_PR[周期]+1后，计数器重置为0x0000，然后继续计数。此事件称为滚动。例如，如果PWM_PR[PERIOD]=0x0000，则计数器在等于0x0001时复位。当PWM_PR[周期]=0xFFFF或0xFFFE时，计数器在等于0xFFFF时复位。有关更多信息，请参阅PWM周期寄存器（PWM_PR）说明。
&emsp;&emsp;在滚动事件期间，通过 control register 的 POUTC 字段来设置为set(default), reset或no effect。如果在控制寄存器中设置了相应的中断启用位，则此事件也会生成中断。
&emsp;&emsp;当计数器值达到采样值时，根据控制寄存器 POUTC 字段的编程，PWM 输出复位（默认）、置位或无效。此事件称为比较事件。如果在控制寄存器中设置了相应的中断启用位，则此事件也会生成中断。
&emsp;&emsp;如果翻滚事件设置PWM输出信号，则比较事件将对其进行重置，反之亦然，用于 POUTC 字段的特定编程配置。
##### 40.4.1.3 低功耗模式行为
&emsp;&emsp;在低功耗模式下，如果来自所选时钟源的时钟可用，则 PWM 计数器继续运行并产生输出，具体取决于是否设置了该模式的控制位。 在没有时钟本身的情况下，或者如果控制寄存器中相应的低功耗位为 0，则计数器复位并在退出低功耗模式时恢复计数。 
##### 40.4.1.3 Debug 模式行为
&emsp;&emsp;在调试模式下，PWM 可以选择继续运行或停止。 如果 PWM_PWMCR 中的 DBGEN 位未设置，则 PWM 停止。 如果 DBGEN 位置位，那么 PWM 将继续在调试模式下运行。 
### 40.5 使能PWM操作序列
1. 失能PWM（PWMx_PWMCR[0]=0），再设置所需要的PWM控制寄存器（PWMx_PWMCR）。
2. 在PWM中断寄存器（PWMx_PWMIR）中启用所需的中断。
3. 一到三个初始样本可写入PWM样本寄存器（PWMx_PWMSAR）。即使PWM尚未启用，初始采样值也将加载到PWM FIFO中。不要写入第四个样本，因为FIFO将变满并触发FIFO写入错（FWE）。一旦启用，该错误将阻止PWM启动。
4. 检查PWM状态寄存器（PWMx_PWMSR）中的FIFO写入错误状态位（FWE）、比较状态位（CMP）和翻滚状态位（ROV），确保它们都为零。任何非零状态位都应通过向其写入1来清除。
5. 将所需周期写入PWM周期寄存器（PWMx_PWMPR）。
6. 通过将1写入PWM启用位PWMx_PWMCR[0]来启用PWM，同时将其他寄存器位保持在其先前配置的状态。
### 40.6 失能PWM操作序列
&emsp;&emsp;通过清除PWM使能位PWMx_PWMCR[0]至0，可随时禁用PWM。
&emsp;&emsp;禁用PWM后，FIFO中剩余的任何数据将不会在PWM输出处产生，并将保留在FIFO中，直到再次启用PWM。软件复位（将PWMx_PWMCR[3]设置为1）或硬件复位将清除FIFO，所有剩余数据将丢失。
### 40.7 PWM 寄存器
&emsp;&emsp;一共有8个PWM，每个PWM有6个寄存器。
#### 40.7.1 PWM Control Register (PWMx_PWMCR)
&emsp;&emsp;PWM 控制寄存器 (PWM_PWMCR) 用于配置 PWM 的操作设置。 它包含时钟分频的预分频器。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-28 reserved |                                                              |
| 27-26 FWM      | FIFO Water Mark。这两位被用于设置“FIFO 中的数据为多少时 FIFO empty flag 被设置”，且产生相应的中断<br>00    当 FIFO 中有 ≥ 1 空槽时，设置 FIFO empty<br>01    当 FIFO 中有 ≥ 2 空槽时，设置 FIFO empty<br>10    当 FIFO 中有 ≥ 3 空槽时，设置 FIFO empty<br>11    当 FIFO 中有 ≥ 4 空槽时，设置 FIFO empty |
| 25 STOPEN      | 使能 stop mode。 该位在停止模式下保持 PWM 功能。 当该位清零时，输入时钟在停止模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在停止模式下无效 <br>1    在停止模式下有效 |
| 24 DOZEN       | 使能 doze mode（打盹模式）。 该位使 PWM 在 doze 模式下保持功能。 当该位清零时，输入时钟在 doze 模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在 doze 模式下无效<br>1    在 doze 模式下有效 |
| 23 WAITEN      | 使能等待模式。 该位使 PWM 在等待模式下保持功能。 当该位清零时，输入时钟在等待模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。<br>0    在等待模式下有效<br>1    在等待模式下无效 |
| 22 DBGEN       | 使能调试模式。 该位使 PWM 在调试模式下保持功能。 当该位清零时，输入时钟在调试模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在调试模式下有效<br>1    在调试模式下无效 |
| 21 BCTR        | 字节数据交换控制。 该位决定 16 位数据从采样寄存器进入 FIFO 时的字节顺序。 <br>0    保持相同的字节序<br>1    字节序反转 |
| 20 HCTR        | 半字数据交换控制。 该位决定将来自 32 位 IP 总线接口的哪个半字数据写入采样寄存器的低 16 位。 <br>0    半字交换不发生<br>1    交换写数据总线的半个字 |
| 19-18 POUTC    | PWM 输出配置。 该位确定输出引脚上 PWM 输出的模式。 <br>00    输出引脚在翻转时设置并在比较时清除 <br>01    输出引脚在翻转时清零并在比较时设置  <br>10    PWM输出断开  <br>11    PWM输出断开 |
| 17-16 CLKSRC   | 选择时钟源。 这些位确定将选择哪个时钟输入来运行计数器。 复位后选择系统功能时钟。 如果这些位设置为 00，也可以关闭输入时钟。该字段值仅应在失能 PWM 时更改 <br>00    关闭时钟<br>01    ipg_clk<br>10    ipg_clk_highfreq<br>11    ipg_clk_32k |
| 15–4 PRESCALER | 计数器时钟预分频器值。 该位字段确定时钟在进入计数器之前将被分频的值。 <br>0x000    1 分频<br>0x001    2 分频<br>0xfff    4096分频 |
| 3 SWR          | 软件复位。当此位设置为 1 时 PWM 复位。它是一个自清除位。向该位写 1 是一个等待状态的写周期。 当模块处于复位状态时，该位被设置，并在复位过程结束时被清除。 设置该位会将所有寄存器复位为其复位值，但该控制寄存器中的 DBGEN、STOPEN、DOZEN 和 WAITEN 位除外。 <br>0    PWM 未复位<br>1    PWM PWM 正在复位 |
| 2-1 REPEAT     | 采样重复次数。 该位字段确定使用 FIFO 中每个采样值的次数。 <br>00    使用每个采样值 1 次<br>01    使用每个采样值 2 次<br>10    使用每个采样值 4 次<br>11    使用每个采样值 8 次 |
| 0 EN           | PWM 使能。 该位使能 PWM。 如果该位未使能，则时钟预分频器和计数器复位。 当 PWM 使能时，它开始一个新的周期，输出引脚设置为开始一个新的周期，同时释放预分频器和计数器并开始计数。 <br>要使 PWM 与软复位和使能/失能一起工作，用户可以通过设置 SWR 位进行软件复位，等待软件复位完成，配置寄存器，然后通过将该位设置为“1”来启用 PWM <br>如果 PWM 想要使用相同的寄存器配置停止和恢复，用户还可以使能/失能 PWM。 <br>0    PWM 失能<br>1    PWM 使能 |

#### 40.7.2 PWM Status Register (PWMx_PWMSR)
&emsp;&emsp;PWM 状态寄存器 (PWM_PWMSR) 包含 7 个位，用于显示 FIFO 的状态以及翻转和比较事件的发生。 FIFOAV 位是只读的，但其他四位可以通过向它们写入 1 来清除。 FE、ROV 和 CMP 位分别与 FIFO-Empty、Roll-over 和 Compare 中断相关联。 

| 位            | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 31-7 Reserved |                                                              |
| 6 FWE         | FIFO 写错误状态。 该位表示已尝试在 FIFO 已满时对其进行写入。 <br>0    没有发生 FIFO 写错误<br>1    发生了 FIFO 写错误 |
| 5 CMP         | 比较状态位。此位表明发生了一个比较事件。<br>0    没有发生比较事件<br>1    发生了比较事件 |
| 4 ROV         | 反转状态位。 该位表明发生了一个翻转事件。<br>0    没有发生反转事件<br>1    发生了反转事件 |
| 3 FE          | FIFO 空状态位。 该位指示 FIFO 数据级别与控制寄存器中 FWM 字段设置的水位的比较。 <br>0    Data level is above water mark<br>1    When the data level falls below the mark set by PWM field |
| FIFOAV        | FIFO 可用。 这些只读位指示 FIFO 中剩余的数据级别。 尝试写入这些位不会影响它们的值，并且不会产生传输错误。<br>000    没有有效数据<br>001    FIFO 中有一个 word 的数据 <br>010    FIFO 中有两个 word 的数据<br>011    FIFO 中有三个 word 的数据<br>100    FIFO 中有四个 word 的数据<br>101    未使用<br>110    未使用<br>111    未使用 |

#### 40.7.3 PWM Interrupt Register (PWMx_PWMIR)
&emsp;&emsp;PWM 中断寄存器 (PWM_PWMIR) 包含三个位，用于控制比较、翻转和 FIFO 空中断的产生。 

| 位            | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 31-3 reserved |                                                              |
| 2 CIE         | 比较中断使能位。此位控制比较中断的产生<br>0    比较中断未使能<br>1    比较中断使能 |
| 1 RIE         | 翻转中断使能位。此位控制翻转中断的产生<br>0    翻转中断未使能<br>1    翻转中断使能 |
| 0 FIE         | FIFO 空中断使能。此位控制 FIFO 空中断的产生<br>0    使能 FIFO 空中断<br>1    使能 FIFO 空中断 |

#### 40.7.4 PWM Sample Register (PWMx_PWMSAR)
&emsp;&emsp;PWM 采样寄存器 (PWM_PWMSAR) 是 FIFO 的输入。 16 位字被加载到 FIFO。 FIFO 可以随时写入，但只能在 PWM 使能时读取。 如果 FIFO 的所有值都已被使用，PWM 将以最后设置的占空比设置运行，直到重新加载 FIFO 或禁用 PWM。 当写入新值时，占空比会在当前周期结束后发生变化。
&emsp;&emsp;采样寄存器中的零值将导致 PWMO 输出信号始终为低/高（POUTC = 00 为低，POUTC = 01 为高），不会产生输出波形。 如果此寄存器中的值高于 PERIOD + 1，则输出将永远不会根据 POUTC 值设置/重置。

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| SAMPLE         | 样本值。 这是 4x16 FIFO 的输入。 该寄存器中的值表示当前正在使用的样本的值。 |

 

#### 40.7.5 PWM Period Register (PWMx_PWMPR)
&emsp;&emsp;PWM 周期寄存器 (PWM_PWMPR) 决定 PWM 输出信号的周期。 计数器值与 PERIOD + 1 匹配后，计数器复位以开始另一个周期。 
PWMO (Hz) = PCLK(Hz) / (period +2)
&emsp;&emsp;PWM_PWMPR 中的零值将导致输出信号的周期为两个时钟周期。 向该寄存器写入 0xFFFF 将获得与写入 0xFFFE 相同的结果。
&emsp;&emsp;由于写入 PWM_PWMPR 而导致的周期值变化会导致计数器重置为零并开始新的计数周期。 
注意：当 PWMx_PWMCR REPEAT 位设置为非零值时，将 PWM_PWMPR 设置为 0xFFFF 是不允许的。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| PERIOD         | 周期值。 这些位确定计数周期的周期。 计数器计数到 [Period Value] +1，然后重置为 0x0000。 |

#### 40.7.6 PWM Counter Register (PWMx_PWMCNR)  
&emsp;&emsp;只读脉冲宽度调制器计数器寄存器 (PWM_PWMCNR) 包含当前计数值，可随时读取而不会干扰计数器。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| COUNT          | 计数器值。 这些位是计数器寄存器的值，表示计数器寄存器的当前计数状态。 |




## 第四十六章 SDMA
### 46.1 概述
&emsp;&emsp;智能直接内存访问 (SDMA) 控制器提供极具竞争力的 DMA 功能以及灵活的基于软件的虚拟 DMA。 它支持外围 I/O 设备和内部/外部存储器之间的数据传输。
&emsp;&emsp;SDMA 控制器通过在动态数据路由中卸载 Arm 内核来帮助最大限度地提高系统性能。 
#### 46.1.1 框图 
&emsp;&emsp;下图显示了 SDMA 控制器的框图。 它包括自定义 RISC 内核及其 RAM、ROM、DMA 单元和调度程序。 


&emsp;&emsp;SDMA核心执行<u>执行DMA传输</u>的短例程；这些例程称为脚本。SDMA核心通过SDMA系统总线连接到自己的内存。SDMA系统总线支持32位数据路径和16位地址总线。系统总线数据路径用于16位指令（程序）内存访问和32位数据访问。DMA单元通过功能单元总线与核心接口，并使用专用寄存器执行DMA传输。
&emsp;&emsp;SDMA内存包含一个 ROM 和一个 RAM 。ROM包含启动脚本（例如，启动代码）和其他公用工具，它们由驻留在 RAM 中的脚本引用。内部 RAM 分为上下文区域和脚本区域（有关此映射的更多详细信息，请参阅指令内存映射和数据内存映射）。
&emsp;&emsp;每个传输通道在不活动时都需要一个上下文区域来保持所有内核和单元寄存器的内容。通道脚本由 SDMA 使用在引导序列期间启动的专用通道下载到内部 RAM。使用 Arm 平台提供的命令和指针调用下载。每个通道都包含位于 RAM 和/或 ROM 中的相应通道脚本，可以根据需要独立重新配置。通道脚本可以存储在外部存储器中，并在需要时下载。SDMA 可以配置任何脚本组合，以实现支持服务的无限组合。 
&emsp;&emsp;调度程序监视和检测 DMA 请求，将它们映射到通道，并将各个通道映射到预先配置的优先级。在任何给定点，调度程序都会向 SDMA 内核提供需要服务的最高优先级的通道。一个特殊的 SDMA 核心指令用于“有条件地将正在执行的当前通道”让给需要服务的合格通道。如果（且仅当）有一个合格的通道待处理，当前通道执行是否会被抢占。
&emsp;&emsp;有两个 yield 指令以不同的方式确定合适的通道： 在第一个版本中，合适通道是待处理的通道，其优先级严格高于当前通道优先级。在第二个版本（yieldge）中，符合条件的通道是优先级大于或等于当前通道优先级的待处理通道。调度程序通过其 48 个 DMA 请求输入检测需要服务的设备。在检测到请求后，调度程序确定由该请求触发的通道并将其标记为“通道未决（EP）”寄存器中的未决。所有未决通道的优先级不断评估，以更新最高的未决优先级。传输完成后，通道脚本会清除通道挂起标志。 
&emsp;&emsp;Arm 平台控制块包含用于配置 32 个单独通道的控制寄存器。有 48 个通道使能寄存器，每个寄存器将一个 DMA 请求映射到任何所需的通道组合。 32 个优先级寄存器用于为每个可能的通道分配可编程的 7 级优先级。该块还包含 Arm 平台可以访问的所有其他控制寄存器。
&emsp;&emsp;连接到调度程序的 48 个 DMA 请求来自多种来源。 UART 和 USB 端口中的“接收寄存器满”和“发送寄存器空”信号是可以连接到 SDMA 的 DMA 请求的典型示例。这些请求可用于触发特定的 SDMA 通道或多个通道。
&emsp;&emsp;有一个用于产品开发的 OnCE 兼容调试端口。 OnCE 包括对设置断点、单步和跟踪以及寄存器转储功能的支持。此外，所有内存位置都可以从调试端口访问。 
#### 46.1.2 特征 
以下是 SDMA 功能： 
* 支持多达 32 个时分复用 DMA 通道的多通道 DMA 
* 每个通道的硬件或软件驱动触发器 
* 48 个硬件驱动的触发器，可以映射到任何通道。 
* 存储器访问，包括线性寻址、FIFO 寻址和 2D 寻址 
* 具有两级、基于优先级的抢占式多任务的快速上下文切换 
* 16 位指令集 micro-RISC 引擎（SDMA 内核） 
* 具有以下部分或全部功能的两个 DMA 单元： 
  * 自动刷新和预取功能 
  * 灵活的地址管理（递增、递减，源地址和目标地址不变） 
  * 未对齐的数据传输支持 
  * 单向和双向流（复制模式） 
  * 多达 8 个字的缓冲区，用于可配置的突发传输 
* 支持字节交换 
* 可用的 API 和脚本库 
* 小端和大端模式
* 用于低功耗进入序列的硬件握手 
* 安全支持锁定 SDMA 脚本 RAM 的内容。 
* 4 KB ROM，包含启动脚本（例如，引导代码）和其他可由位于 RAM 的脚本引用的常用实用程序 
* 8 KB RAM 区域分为处理器上下文区域和代码空间区域，用于存储从系统内存下载的通道脚本 
* 调试支持，包括 OnCE 端口、实时监视器和嵌入式交叉触发事件 
* 进程中支持的时钟频率： 
  * SDMA 内核和 Arm 平台 DMA 单元的可配置时钟选项 
    * 1:2 比率，最大 SDMA 内核以 Arm 平台外设总线速度运行，DMA 以最大 DMA 频率运行。 
    * 当 SDMA 内核和 Arm 平台 DMA 时钟都设置为 Arm 平台外设总线速度时，比率为 1:1。 
* Arm 平台用于配置寄存器编程的外设总线接口 
* SDMA RISC 引擎（算术和逻辑运算），称为“SDMA 核心”。 
* 连接到共享外设总线接口 (SPBA) 的内部外设总线，可以访问多达 14 个共享外设。 SDMA 支持对字外设的 32 位访问和对半字外设的 16 位访问。 
* 连接到 Arm 平台 Crossbar Switch 以服务 Arm 外设的外设 DMA 单元 
* 突发 DMA 单元能够对外部存储器执行突发访问 
* 所有的 DMA 单元都是 32 位 AHB 主机。 它们连接到不同的总线，从而允许并发访问。 
### 46.4 功能描述
&emsp;&emsp;下图显示了 SDMA 拓扑，由以下组件组成： 

&emsp;&emsp;功能单元总线提供 SDMA 内核对 DMA 单元的访问。系统总线提供对 SDMA 内部存储器的访问，并且还支持多达 14 个外设。 
#### 46.4.1 SDMA Core
&emsp;&emsp;SDMA 内核是一种定制的类似 RISC 的处理器，专门开发用于控制 DMA 单元并执行 L1 任务，如字节填充或成帧。 
&emsp;&emsp;SDMA 内核包含使用 OnCE 的片上调试功能。
&emsp;&emsp;SDMA 内核基于具有 16 位指令的 32 位寄存器架构。 有八个通用 32 位寄存器、四个标志（T、LM、SF 和 DF）和四个 PCU 寄存器（PC、RPC、SPC 和 EPC），可寻址 16,384 条 16 位指令。 
##### 46.4.1.1 SDMA Core Structure
&emsp;&emsp;此处找到的图显示了 SDMA 内核的结构。 它还显示了不同的寄存器、计算资源和可能的数据移动。 
* 程序控制单元 (PCU) 在程序控制单元 (PCU) 中进行了描述。 它处理内核的状态并生成指令获取地址。 指令从指令总线 (IBUS) 中检索，并在解码之前存储在 SDMA 核心指令寄存器中。 PCU 包含以下寄存器： 
  * 程序计数器 (PC) 包含当前指令的地址。 
  * 返回程序计数器 (RPC) 包含跳转到子程序之后的指令地址。 
  * 起始程序计数器 (SPC) 包含当前硬件循环的第一条指令的地址。 
  * 结束程序计数器 (EPC) 包含当前硬件循环的最后一条指令的地址。 
* 其他核心寄存器是通用寄存器 (GREGn) 和标志。 
  * 通用寄存器可用于保存数据和地址。 它们可以加载立即值（例如，指令中编码的 8 位数据）、使用 ALU 执行的计算结果、来自存储器或通过数据存储器总线的外围设备的 32 位数据（ DMBUS），通过功能单元总线 (FUBUS) 或其他通用寄存器来自 DMA 的 32 位数据。 它们的内容可以是 ALU 的操作数、要在任一总线（DMBUS 或 FUBUS）上发送的数据，或指向内存的指针（DMBUS 地址）。 
  * 通用寄存器 0 (GREG0) 也是硬件循环计数器。 在硬件循环中，它不能用于任何其他目的。 该寄存器使用图 46-3 中所示的专用递减单元 (DECR)。 
  * flags 反映了操作的状态： 
    * 当任一总线（FUBUS 或 DMBUS）上的最后加载或存储接收到错误响应时，设置 SF 和 DF。 
    * 当内核在硬件循环内执行指令时设置 LM。 
    * 当 ALU 运算结果为 0 或循环计数器达到 0 时设置 T（后者在 ALU 运算是硬件循环的最后一条指令时占优势）。 
* ALU 有两个操作数：任何通用寄存器和第二个通用寄存器或立即值。 结果总是存储在第一个通用寄存器中。 NOP 函数可以通过将寄存器的内容移动到自身中来使用（例如，指令：mov R0,R0）。 
* 16 位指令通过指令总线 (IBUS) 获取，其地址由 PC 驱动。 SDMA RAM 和 ROM 通过该接口作为 16 位设备对内核可见。 
* 通过 DMBUS 访问内存（RAM 和 ROM）、内存映射寄存器和外围设备。 地址总是取自一个通用寄存器，其内容被添加到一个 5 位立即数上。 这是唯一可用的寻址模式。 DMBUS 是 32 位数据总线。 除 SDMA 外部的外设外，地址精度为 32 位字（例如，地址加 1 指向下一个字，而不是下一个字节）。 
* 通过 FUBUS 连接访问功能单元。 数据与任何通用寄存器交换，但地址（实际上是指令和功能单元的选择器）来自相应加载或存储的8位字段。 
##### 46.4.1.2 Program Control Unit (PCU)
&emsp;&emsp;SDMA 内核的这一部分专门用于控制 RISC 引擎，正如执行的指令所暗示的那样。它的行为由指令类型和 SDMA 的输入决定。
&emsp;&emsp;它包含 SDMA 核心结构中描述的 PC、RPC、SPC 和 EPC 寄存器。 
......
##### 46.4.1.3 SDMA Core Memory
&emsp;&emsp;SDMA 有两个存储空间：一个用于指令，一个用于数据。由于两个空间共享相同的资源（ROM 和 RAM 设备），当内核访问相同资源进行指令读取和数据读取或写入时，系统总线管理可能发生的冲突。
&emsp;&emsp;地址空间中进一步描述了程序和数据存储器。
&emsp;&emsp;16 位宽的指令存储在 32 位宽的设备中，可以作为数据访问。映射为 Big Endian：偶数指令地址（以 0 结尾）访问 32 位数据（位 [31:16]）的最高有效部分，奇数指令地址（以 1 结尾）访问最低有效部分的 32 位数据（位 [15:0]）。指令可以从内部 ROM 或 RAM 中取出。
&emsp;&emsp;可以从 ROM、RAM、内存映射寄存器和外围设备读取数据，并将数据写入相同的设备（ROM 除外）。
&emsp;&emsp;ROM 包含引导加载脚本、通道脚本和公共子例程，它们可能被 ROM 或 RAM 中其他地方的通道脚本引用。
&emsp;&emsp;RAM分为上下文区和代码空间区，可用于存储通道脚本。RAM 在硬件复位后包含未定义的值。使用为引导加载功能保留的通道 0 将通道脚本和初始上下文值下载到 RAM 中。 
#### 46.4.2 Scheduler
所有通道调度硬件都包含在调度程序中。 
##### 46.4.2.1 Primary Functions
&emsp;&emsp;调度器是一种基于硬件的设计，用于协调 SDMA 内核根据通道状态和优先级及时执行 32 个虚拟 DMA 通道。
&emsp;&emsp;调度程序执行以下功能： 
* 监视、检测和记录 48 个 DMA 请求中任何一个的发生 
* 将特定请求链接到通道或通道组（通道映射）
* 忽略未映射到先前配置的通道的请求 
* 维护请求服务的所有频道的列表 
* 为每个请求服务的通道分配一个预编程的优先级（7 个中的 1 个） 
* 检测并标记溢出/欠载情况 
##### 46.4.2.2 Channels and DMA Requests
###### 46.4.2.2.1 Channels
&emsp;&emsp;虚拟通道（以下简称为通道）管理通过 SDMA 的数据流。 流动通常是单向的。
&emsp;&emsp;SDMA 最多可以同时运行 32 个通道，编号从 0 到 31。通道 0 通常专用于控制 SDMA 脚本下载。 所有通道都可以通过 Arm 平台软件进行分配。 
###### 46.4.2.2.2 DMA Requests
&emsp;&emsp;DMA 请求是由外部（例如，SDMA 外部）控制条件（例如，UART 接收 FIFO 达到阈值）引起的。 SDMA 当前最多支持 48 个 DMA 请求。 
###### 46.4.2.2.3 Mapping from DMA Requests to Channels and Priorities
&emsp;&emsp;通道可能会停止等待单个 DMA 请求。 单个 DMA 请求可以唤醒多个通道（实际上，任何请求都可以唤醒任何通道组合）。
&emsp;&emsp;DMA 请求和通道之间的映射是由程序控制的。 为 48 个请求中的每一个分配了一个存储元素，其中包含由事件唤醒的通道的位图表。
&emsp;&emsp;每个通道还有一个三位寄存器，用于指示其优先级。 
##### 46.4.2.3 Scheduler 功能描述
&emsp;&emsp;调度器概述描述了 SDMA 调度器的行为——从通道启用条件到最高优先级的未决通道选择。 
###### 46.4.2.3.1 Scheduler Overview
&emsp;&emsp;调度程序算法内置于硬件中。 它为 Arm 平台提供了控制其行为的可能性。
&emsp;&emsp;调度程序处理传入的 DMA 请求，将检测到的请求映射到 0 个、一个或多个通道，维护请求服务的通道列表（待处理通道），识别最高优先级及其关联通道，并在当前通道结束时选择下一个活动的通道。
&emsp;&emsp;下图显示了功能概览。 

###### 46.4.2.3.2 DMA Requests Scanning
&emsp;&emsp;调度器包含一个 48 位边沿检测设备，它检测每个 DMA 请求的上升沿并将请求号传送到下一级。
&emsp;&emsp;假设 DMA 请求在与 SDMA 内核时钟相同的参考时钟上生成； 一旦信号从 1 到 n 周期的低状态变为 1 到 m 周期的高状态，它们就会被检测到。
&emsp;&emsp;该系统能够检测单周期脉冲以及基于电平的 DMA 请求，例如 FIFO 阈值交叉。 在这种情况下，SDMA 提供了一个内存映射寄存器，通道脚本可以使用该寄存器来监视 DMA 请求行，从而确定数据传输是否完成，然后继续传输或关闭通道。
&emsp;&emsp;当同时检测到多个 DMA 请求时，它们会以每个周期一个请求的速率转发到下一个调度程序阶段。 没有请求丢失。


&emsp;&emsp;DMA 请求输入连接到取决于 SoC 的各种源。 DMA 请求输入的确切列表及其相关编号可在每个项目特定的章节中找到。 
###### 46.4.2.3.3 Mapping DMA Requests to Pending Channels
&emsp;&emsp;每当第一阶段检测到 DMA 请求时，其编号将在第二阶段用于确定必须激活的通道。
&emsp;&emsp;这是通过 48 个 32 位宽的寄存器阵列执行的：有 48 个通道启用寄存器 (CHNENBLn)，每个 DMA 请求一个寄存器。 DMA 请求号选择 Channel Enable Registers，这个 32 位寄存器的每一位表示为 1 时必须激活相应的通道。 
&emsp;&emsp;该信息在 EP 寄存器上传递。 对于通道启用寄存器的每一位被置位，EP 寄存器的相应位也被置位，而 EP 的其余位保持不变。 EP 的变换由以下等式总结：
EP = EP 或 CHNENBLn
&emsp;&emsp;EP 寄存器用于了解哪些通道需要服务，因为它们收到了 DMA 请求。
&emsp;&emsp;CHNENBLn 寄存器的典型内容都是 0，除了单个位设置。 例如，一个 DMA 请求触发一个通道，但可能是全 0 或几个 1。 一个 DMA 请求可以激活多个通道，通道执行顺序可以由通道优先级和编号控制，如下一节所述。 下表说明了一个示例配置。 
&emsp;&emsp;注意：从表中可以看出，DMA 请求 0 被编程为同时触发通道 0、1 和 31。此外，此示例中未使用 DMA 请求 30-47。 其余通道 2 到 30 分别配置为由 DMA 请求 29 到 1 触发。 
###### 46.4.2.3.4 Channel Overflow
&emsp;&emsp;当 DMA 请求通过设置寄存器 EP 的位 n 来请求通道 n 的服务，但该位已设置（意味着通道 n 已挂起）时会发生通道溢出，。 这可能来自溢出/欠载情况。
&emsp;&emsp;仅当 DMA 请求是脉冲时才可能进行这种检测，因为基于电平的 DMA 请求在得到服务之前保持高电平，即使发生欠载或溢出情况，从而防止再次检测 DMA 请求的边沿。
&emsp;&emsp;通道溢出信息保存在 32 位 CHNERR 寄存器中（每个通道 1 位）。 您可以配置 SDMA 以在 CHNERR 中有 1 时触发 Arm 平台的中断。 CHNERR 的每一位都被 INTRMASK 的相应位屏蔽，如果它给出 1，则 INTR 的相应位被设置，触发中断。 
###### 46.4.2.3.5 Runnable Channels Evaluation 可运行通道评估
&emsp;&emsp;EP 寄存器与其他几个 32 位寄存器一起使用，以确定可运行的通道。
&emsp;&emsp;寄存器 EO、DO、HO 和 HE 由 Arm 平台控制。 EP 由 DMA 请求及其到通道的映射控制。
&emsp;&emsp;在任何给定时间都可以运行多个通道。 当（且仅当）以下条件为真时，第 i 个通道是可运行的： 

......

###### 46.4.2.3.6 Next Channel Decision Tree
&emsp;&emsp;下一个通道号是根据可运行通道列表、当前通道号及其各自的优先级计算得出的。
&emsp;&emsp;它在每个周期重新评估，但仅在当前通道通过执行 yield、yielge 或 done 指令让出或终止时使用。
&emsp;&emsp;决策树基于选择具有最高优先级的可运行通道。
&emsp;&emsp;根据以下规则选择优先级最高的通道： 
* 可运行通道按优先级排序。
* 如果具有最高优先级的通道之一已被具有更高优先级的通道抢占，但不想让步给具有相同优先级的通道（例如，它执行了 yield，而不是 yieldge），则它被选为下一个通道。
* 属于最高优先级组的通道按其编号排序，该组中编号最高的通道成为下一个通道。 例如，如果优先级相同，则将先选择通道 31，然后再选择通道 30。 
&emsp;&emsp;当当前通道需要使用 yield(ge) 或完成指令重新调度时，上下文切换决策基于指令参数、当前通道号和优先级以及下一个通道号和优先级。 可能的情况都列在下表中。 灰色单元格对应于在 SDMA 的典型使用中不应发生的异常情况。 

......

##### 46.4.2.4 Context Switching
&emsp;&emsp;在执行 done 或 yield(ge) 指令时，当前通道可能会改变，或者因为它已经完成（这必然发生在执行 done 指令时），或者它被更高优先级的通道抢占（这是可能的但不是执行 yield(ge) 时的系统性）。
&emsp;&emsp;在通道改变时，SDMA 会经历一个上下文切换过程。
&emsp;&emsp;当当前通道让步或结束时，该通道的上下文将保存到该通道的上下文 RAM 位置。当下一个通道开始运行时，它的上下文首先从 RAM 中恢复。
&emsp;&emsp;由于上下文 RAM 尚未通过复位初始化，因此在复位后运行的第一个通道（引导加载通道）开始时不会进行上下文恢复。预计引导加载通道将用于初始化所有其他通道的上下文。当引导加载通道完成运行或退出时，SDMA 将进入其 SAVE 状态并将该通道的上下文保存到 RAM 中。然后，如果稍后再次调用引导加载通道，则当通道再次启动时，上下文将从 RAM 中恢复。 
&emsp;&emsp;每个通道的上下文结构在上下文切换编程和表 46-11 中定义。 将为每个通道保留一个上下文区域。 当通道结束或退出时，SDMA 内核寄存器会自动保存到上下文 RAM 中，然后在下一次运行通道时从上下文 RAM 中恢复。 为 32 通道上下文保留的总 RAM 空间为 3K 或 4K，具体取决于是否在 CHN0ADDR 寄存器中设置了 SMSZ 位，这为每个上下文启用了额外的 8 个字的暂存 RAM。 
###### 46.4.2.4.1 Context Switch Modes
&emsp;&emsp;保存旧通道上下文和恢复新通道上下文的确切过程取决于 Arm 平台在 CONFIG 控制寄存器中选择的上下文切换模式。
&emsp;&emsp;以下是上下文切换模式： 
* 默认情况下，设置了“动态”上下文切换。此模式在平均八个周期内提供最有效的上下文切换，以停止当前通道、保存其上下文、恢复下一个通道上下文并恢复其执行。它包括在后台保存当前通道的修改寄存器（例如，在通道执行期间）——当决定切换时，只剩下很少的寄存器可以保存——尽快恢复下一个通道的执行（例如，当最小的寄存器集被恢复时），并在此执行期间继续恢复阶段。
* 在“动态无循环”模式下，遵循相同的原则，只是修改的寄存器仅在未设置循环标志时保存在后台。此模式提供与前一种模式几乎相同的效果，但它会阻止系统在循环期间访问 RAM 以节省电力。当循环体很短时，这是一种高效上下文切换的推荐模式。
* 在“动态功耗”模式下，不执行后台保存，从而将功耗降至最低。修改后的寄存器仅在上下文切换开始时保存。恢复阶段与之前相同。这是以较慢的上下文切换为代价实现最佳功耗的模式。
* 在“静态”上下文切换中，当决定进行上下文切换时保存所有寄存器，并在开始执行新通道之前恢复所有寄存器。此模式启用上下文切换的可预测行为，因为所有寄存器都在通道启动之前恢复，并且所有寄存器在通道终止之后保存。 

&emsp;&emsp;注意：静态上下文模式应用于复位后调用的第一个通道，以确保该通道的所有上下文 RAM 在通道完成或退出时的上下文 SAVE 阶段初始化。 对同一通道或不同通道的后续调用可以使用任何动态上下文模式。 这将确保引导加载通道的所有上下文位置都已初始化，并防止在稍后重新启动通道时在上下文恢复期间加载上下文 RAM 中的未定义值。 

###### 46.4.2.4.2 Context Switch Procedure
&emsp;&emsp;程序控制单元进入保存状态，当前上下文溢出到内存中，根据 Arm 平台选择的上下文切换模式恢复下一个通道上下文。 
&emsp;&emsp;上下文切换过程如下：
1. 加载当前上下文的溢出基地址。
2. 通道运行时，根据选择的上下文切换模式将当前通道的修改寄存器溢出到内存中。
在导致通道抢占的 done 或 yield(ge) 时，PCU 进入保存状态。静态模式下，保存所有寄存器；而在任一动态模式下，都会保存已修改但尚未保存的寄存器，最后保存 PCU 寄存器和标志。
3. 使 SDMA 内核进入睡眠状态并等待新通道的服务。如果在保存当前通道时有待处理的通道，则跳过此步骤。
只要有至少一个未决通道，PCU 就会进入其恢复状态以恢复调度程序选择的通道的上下文。
一旦选择了一个通道，它就会保持当前通道，直到其脚本使用 done 或 yield(ge) 指令请求重新调度操作。这意味着 Arm 平台无法修改当前通道，即使它不再可运行或者其优先级已被修改。
但是，Arm 平台可以通过在 CONFIG 寄存器中写入相应的位来强制重新调度，这与脚本执行完成指令的效果相同。该功能应仅用于在紧急情况下停止 SDMA。
4. 加载新通道的上下文基地址。在“静态”模式下，所有寄存器都被恢复。在任一“动态”模式下，仅恢复 PCU 寄存器。
新频道正在运行。在“静态”模式下，不再执行有关上下文恢复或保存的活动。在任一“动态”模式下，每次可以访问上下文 RAM 时，都会在后台恢复寄存器，并优先恢复下一条要执行的指令所需的寄存器。当一个寄存器尚未恢复并且下一条指令需要它时，该指令将停止，直到寄存器恢复。 
在“动态”和“无循环动态”模式下，每次可以访问上下文 RAM 并且上下文切换模式允许访问时，都会执行脏寄存器的后台保存。 

......

#### 46.4.8 初始化信息 
本节讨论以下内容： 
* 硬件复位
* 通道脚本执行
* 初始化和 脚本执行设置序列

##### 46.4.8.1 硬件复位
&emsp;&emsp;复位后，程序 RAM、上下文 RAM、数据 RAM 和包含通道使能寄存器 (CHNENBLn) 的 RAM 具有不可预测的内容。
&emsp;&emsp;活动寄存器组分配给通道 0，PC 初始化为全零。 但是，由于通道使能寄存器全为零，因此没有活动通道，并且 SDMA 停止，等待引导通道启动。
&emsp;&emsp;Arm 平台必须设置 SDMA 才能启动它。 必须初始化 CONFIG 寄存器以确定 DMA/内核时钟比率（1 或 2）。 Channel Enable
Registers 也必须初始化。 
&emsp;&emsp;为了启动 SDMA，Arm 平台首先在 Arm 平台内存中为引导通道（通道 0）创建一些通道控制块（CCB）和缓冲区描述符（BD），然后将通道 0 指针寄存器（SDMA_MC0PTR）初始化为第一个控制块的地址。 Data Structures for Boot Code and Channel Scripts 概述了 CCB 和 BD 的数据结构。然后根据可运行通道评估配置 SDMA_HSTART、SDMA_HOSTOVR 和 SDMA_EVTOVR 寄存器以允许通道 0 运行。
&emsp;&emsp;启用后，SDMA 开始执行位于程序存储器中通道 0 引导地址寄存器 (SDMA_CHN0ADDR) 指示的地址的脚本。 SDMA_CHN0ADDR 的复位值指向 ROM 中的默认引导加载脚本。此 ROM 脚本将读取通道 0 指针寄存器 (SDMA_MC0PTR) 以确定通道控制块 (SDMA_CCB) 在 Arm 平台内存中的位置。然后脚本将开始通过 DMA 获取第一个通道控制块，其中包含指向位置通道 0 缓冲区描述符链的指针，该指针也通过 DMA 获取。如果缓冲区描述符包含有效命令，则脚本解释每个缓冲区描述符中的命令并继续执行命令并继续执行下一个缓冲区描述符控制块。通道零的缓冲区描述符命令通常设置为加载 SDMA 的程序 RAM、数据 ​​RAM 和通道上下文的初始值。一些通道脚本期望传递特定的参数。
&emsp;&emsp;有两种方法可以在用户定义的脚本上启动 SDMA。 OnCE（通过其 JTAG 接口或 Arm 平台控制接口）可用于下载 SDMA RAM 中的任何代码并强制 SDMA 在该代码上启动。 此外，可以修改 Arm 平台编程模型中的 SDMA_CHN0ADDR 寄存器以指向 RAM 中的用户代码，这些代码需要通过 ONCE 或默认引导加载例程（例如在软件复位之前）加载。 
##### 46.4.8.2 Channel Script Execution
&emsp;&emsp;SDMA 脚本的执行取决于构成该脚本的指令、其操作所依据的数据上下文以及允许进入缓冲区的命令或参数。在允许执行脚本之前，必须初始化所有这些项目。
&emsp;&emsp;32 个通道中的每一个都有一个单独的上下文，但可以共享数据 RAM 中的脚本和位置。
&emsp;&emsp;通道由 Arm 平台初始化，方法是使用通道 0 下载任何所需的脚本和数据值以及通道初始上下文。上下文包含 SDMA 内核寄存器的所有初始值。这包括程序计数器 (PC)，它设置为 SDMA 程序存储器中所需脚本的开头。
&emsp;&emsp;Arm 平台通过配置 SDMA_CHNENBL、SDMA_HOSTOVR 和 SDMA_EVTOVR 寄存器来选择通道启动必须发生的触发条件。触发事件包括 Arm 平台设置 HE (SDMA_HSTART) 或硬件 DMA 请求将事件输入置为 SDMA。当所选触发器导致可运行信道中描述的条件评估为真实时，该信道可以根据其优先级与其他可运行的通道相比变得有效。
&emsp;&emsp;要传递给缓冲区描述符或上下文中每个脚本的特定参数记录在每个脚本的软件文档中。请参阅 SDMA 脚本以获取完整的脚本文档。缓冲区描述符格式提供了缓冲区描述符格式的概述。 
##### 46.4.8.3 初始化和脚本执行设置顺序
&emsp;&emsp;总之，设置SDMA和运行通道脚本至少需要以下步骤。
* 执行硬件重置。 复位后，程序 RAM、上下文 RAM、数据 RAM 和 SDMA_CHNENBLn 寄存器具有不可预测的内容。 
* 初始化 SDMA_CHNENBLn 寄存器以将 DMA 请求事件映射到所需通道。
* 配置 SDMA_CHNPRIn 寄存器以选择可运行通道的优先级。 通道运行需要非零优先级。 
* 配置 SDMA_CONFIG 寄存器以选择 DMA 与 SDMA 内核时钟比率。
* 在 Arm 平台中设置通道控制块和缓冲区描述符，以指定要使用的每个 SDMA 通道的 SDMA 程序 RAM 和通道上下文的加载。引导代码和通道脚本的参考数据结构。
* 将SDMA_MC0PTR 寄存器配置为Arm 平台通道控制块基地址的基地址。
* 初始化SDMA_CHNENBLn 寄存器以将DMA 请求事件映射到相关通道。参考将 DMA 请求映射到挂起的通道。
* 配置SDMA_CHNPRIn 寄存器以设置每个要运行的通道的优先级。
* 对于要运行的每个通道，配置 SDMA_HOSTOVR (HO) 和 SDMA_EVTOVR (EO) 寄存器以选择必须发生哪些事件（硬件和/或软件触发事件）才能使通道可运行。参考可运行通道评估。
* 设置 SDMA_HSTART 寄存器的位 0 以设置 HE[0] 并允许通道 0 运行（假设 EO[0] 和 DO[0] 均在上一步中设置）。这将导致 SDMA 加载先前配置的程序 RAM 和通道上下文。
* 等待通道0 完成运行。这由 SDMA_SDMA_INTR 寄存器中的 HI[0]=1 或 Arm 平台的可选中断指示。
* 设置 SDMA_SDMA_LOCK 寄存器中的 LOCK 位以防止未经授权将数据上传到 SDMA RAM。
* 现在可以通过根据可运行通道评估启用选定的软件或硬件触发事件来运行其他通道脚本。 

#### 46.4.9 SDMA Programming Model
&emsp;&emsp;本节介绍 SDMA RISC 引擎的编程模型，包括其处理器、内存和内部控制寄存器。
&emsp;&emsp;所有地址都与内部 SDMA 内存映射相关，这与 Arm 平台的内存映射完全不同。 Arm 平台处理器无法访问所描述的任何硬件资源，除非这些资源在 Arm 平台内存映射和控制寄存器摘要中有所描述。
##### 46.4.9.1 State and Registers Per Channel
&emsp;&emsp;SDMA 可以看作是一组 32 个相同的设备，每个设备能够执行一个数据传输通道。 一次只能工作一个通道，但每个通道状态随时可用。
&emsp;&emsp;本章列出了每个通道状态的组成部分。 
##### 46.4.9.2 General Purpose Registers
&emsp;&emsp;每个通道有 8 个 32 位的通用寄存器供脚本使用。 通用寄存器 0 具有循环指令的专用功能，但可用于任何目的。 
##### 46.4.9.3 Functional Unit State
&emsp;&emsp;每个通道上下文都有一些状态，它是功能单元的一部分。
&emsp;&emsp;该状态的具体分配是 Burst DMA Unit Programming, Peripheral DMA Unit Programming 中描述的功能单元定义的一部分。
&emsp;&emsp;此状态必须在上下文切换时保存/恢复。 
###### 46.4.9.3.1 Program Counter Register (PC)
&emsp;&emsp;PC是14位的。 由于指令宽度为 16 位，而 SDMA 中的所有存储器宽度均为 32 位，因此 PC 的低位选择 32 位字的哪一半包含当前指令。
&emsp;&emsp;零的低位选择字的最高有效半部分。 

























## 第四十八章 SNVS 安全非易失性存储
### 48.1 概述
&emsp;&emsp;智能直接内存访问 (SDMA) 控制器提供极具竞争力的 DMA 功能以及基于软件的虚拟 DMA 灵活性。 它支持外围 I/O 设备和内部/外部存储器之间的数据传输。
&emsp;&emsp;SDMA 控制器通过在动态数据路由中卸载 Arm 内核来帮助最大限度地提高系统性能。 


## 第五十二章 Temperature Monitor 温度监测器
### 52.1 概述
&emsp;&emsp;温度传感器模块基于与温度相关的电压到时间的转换来实现温度传感/转换功能。 
&emsp;&emsp;该模块具有报警功能，如果温度高于两个高温阈值和低于一个低温阈值，可以发出独立的中断信号。这些温度阈值是可编程的，并指定为低、高和紧急温度。紧急阈值是一个特殊的可编程阈值，因为如果温度升高到该值以上并且在系统复位控制器中启用了温度紧急复位中断，则硬件将假定软件不再控制热情况并启动芯片复位。 
&emsp;&emsp;为了避免错误的紧急温度启动复位，在连续四个转换周期满足温度紧急条件之前，紧急警报不会触发。也可以对自重复模式进行编程，该模式基于可编程的延迟执行温度感测操作。 
&emsp;&emsp;由于高温和低温阈值是可编程的，因此它们形成了一个可根据应用需求量身定制的滑动温度支架。 例如，在启动时，软件可以将低温阈值设置为系统的最低温度代码，将高温阈值设置为系统的最高工作温度。
&emsp;&emsp;然后，系统可以使用该模块来监控片上温度，并在设置高温中断时采取适当的措施，例如节流内核频率。 一旦设置了高温中断，系统就可以将低温阈值编程为所需的冷却温度。 然后系统将切换到监测低温警报并等待其中断被设置。 通过这种方案，一旦设置了低温中断，软件就可以确保温度已经冷却到安全水平，并且可以重复该过程。 
&emsp;&emsp;如上图所示，温度传感器使用并假设带隙参考、480MHz PLL 和 32KHz RTC 模块已正确编程并完全稳定以进行正确操作。 
### 52.2 软件使用指南
&emsp;&emsp;在系统正常运行期间，软件可以使用温度传感器计数器的输出 (TEMP_CNT) 和熔断器温度校准数据来确定片上运行温度或将过温中断警报设置在几°C 以内。
&emsp;&emsp;根据校准，可通过设备上的保险丝获得两组温度和计数器值。 这些数据点将对应于下面曲线中的点 (N1, T1) 和 (N2, T2)。 
&emsp;&emsp;在一次温度测量周期之后，软件应结合使用校准点和 TEMPMON_TEMPSENSE0[TEMP_CNT] 位域中的温度编码值，使用以下公式计算设备的温度： 
$$T_{meas} = T_2 - (N_{meas} - N_2) * ((T_2 - T_1)/(N_1 - N_2))$$
&emsp;&emsp;同样，为了确定要写入 TEMPMON_TEMPSENSE0 寄存器中的警报计数器值，用于基于温度的中断，可以根据所需的温度触发器对应使用的 $N_{meas}$ 值求解上述等式。
&emsp;&emsp;OCOTP_ANA1 寄存器中提供了温度校准点保险丝值。 在产品测试过程中，每个部件的温度校准值都是单独融合的。 下表描述了该寄存器的字段。 
### 52.3 TEMPMON 寄存器定义
#### 52.3.1 Tempsensor Control Register 0
&emsp;&emsp;此寄存器定义了温度传感器的基本控制位，除了在 tempsensor 中定义的采样频率。
* 31-20 ALARM_VALUE 温度计数值（原始传感器的输出），此值可以产生警告中断。
* 19-8 TEMP_CNT 上次的温度计数值。
* 2 FINISHED 表明上次采样有效。每次监测开始之后，sensor应该清空此位
  * 0 INVALID 上次监测还未准备好
  * 1 VALID 上次监测有效
* 1 MEASURE_TEMP 开始监测过程。如果在 TEMPSENSE1 寄存器中监测频率是0，此结果是单次转换。
  * 0 STOP 不开始监测过程
  * 1 START 开始监测过程
* 0 POWER_DOWN 此位控制传感器的电源开关
  * 0 POWER UP
  * 1 POWER DOWN
#### 52.3.2 Tempsensor Control Register 1
&emsp;&emsp;该寄存器定义了温度传感器的自动重复时间。 
#### 52.3.3 Tempsensor Control Register 2
* 27-16 PANIC_ALARM_VALUE 
* 11-0 LOW_ALARM_VALUE

## imx_thermal.c文件分析









