## 第十三章 ADC
### 13.1 概述
&emsp;&emsp;模数转换器（ADC）是一种逐次逼近ADC，设计用于在集成微控制器片上系统内操作。

#### 13.1.1 特点
ADC 的特点如下：
* 32 bit，字对齐，字节使能寄存器，（不支持字节和半字访问）。
* 线性逐次逼近算法，分辨率高达12位，精度为10/11位。
* 多达10个ENOB（专用单端信道）
* 高达1MS/s采样率
* 最多16个单端外部模拟输入
* 单次或连续转换（单次转换后自动返回空闲状态）
* 输出模式：（右对齐无符号格式）
  * 12-bit
  * 10-bit
  * 8-bit
* 可配置的采样时间和转换速度/功率
* 转换完成和硬件平均完成标志和中断
* 最多可从四个源中选择输入时钟
* 用于低噪声操作的异步时钟源，可选择输出时钟
* 带硬件通道选择的可选异步硬件转换触发器
* 可选电压参考、内部、外部或备用
* 自动与小于、大于或等于、在范围内或超出范围的可编程值的中断进行比较
* 在低功率模式下运行，以降低噪音
* 硬件平均功能
* 自校准模式

#### 13.1.4 ADC 模块接口
&emsp;&emsp;ADC连接到许多接口，如时钟和复位、访问总线、电压参考、中断控制器、硬件触发器、ADC引脚控制和模拟I/F，如下图所示。

#### 13.1.5 操作模式
&emsp;&emsp;默认情况下，ADC处于禁用模式。在此状态下，不会发生转换或其他操作。在此状态下，所有ADC控制寄存器均可通过访问总线接口访问。要启用ADC，应通过编程ADC配置寄存器来完成所需的配置。

### 13.2 外部信号
ADC1_IN0~9: GPIO_IO0~9
ADC2_IN0~9: GPIO_IO0~9

ADC输入信号连接到GPIO[0:9]。为keeper启用GPIO默认配置。keeper在ADC中导致不希望的跳转行为。为避免此问题，请在启动ADC之前禁用keeper。有关keeper的详细信息，请参阅GPIO块。

### 13.3 功能描述
ADC 模块可以处于三种状态：
1. disabled 状态
2. Idle 状态
3. 正在执行转换

**disabled 状态**: 在复位、停止模式期间（如果未选择内部时钟作为时钟源），或当硬件控制（ADC_HCn）寄存器的ADCH位均为高电平时，禁用ADC模块。
**Idle 状态**: 当一次转换完成而另一次转换尚未启动时，模块处于空闲状态。当空闲且异步时钟输出启用被禁用（ADACKEN=0）时，模块处于其最低功率状态。
**转换状态**: ADC可以在任何软件可选通道上执行模数转换。所有模式都通过逐次逼近算法进行转换。

&emsp;&emsp;为了满足精度规范，必须使用片上校准功能校准ADC模块。建议在任何重置后进行校准。
&emsp;&emsp;转换完成后，将结果放入数据结果寄存器（ADC_Rn）中。如果已启用相应的转换完成中断（ADC_HCn[AIEN]=1），则设置硬件状态寄存器中的转换完成标志（COCOn）字段，并生成中断。
&emsp;&emsp;ADC模块具有自动将转换结果与比较值寄存器的内容进行比较的能力。通过在ADC通用控制寄存器中设置ACFE（ADC比较功能启用）来启用比较功能。
&emsp;&emsp;ADC模块具有自动平均多次转换结果的能力。通过在ADC通用控制寄存器中设置AVGE来启用硬件平均功能。

#### 13.3.3 硬件触发和通道选择
&emsp;&emsp;ADC模块具有一个触发输入（称为备用触发），当ADC配置寄存器（ADC_CFG）中的ADTRG位被设置且任何外部硬件触发选择为高时，该触发输入提供异步硬件转换触发。
&emsp;&emsp;为了可靠地捕获，交替触发脉冲必须高足够的时间以满足捕获触发器的时钟要求，并且外部硬件触发选择事件必须在交替触发脉冲的正边缘之前和之后设置足够的时间，以满足捕获触发的设置/保持要求。
&emsp;&emsp;若外部硬件触发器选择事件在转换过程中被断言，则它必须保持断言状态，直到当前转换结束，并保持设置状态，直到收到替代触发器以启动新的转换。
&emsp;&emsp;当备用触发源可用且硬件触发已启用（ADC_CFG[ADTRG]=1）时，在外部硬件触发选择事件发生后，在备用触发的上升沿启动转换。
&emsp;&emsp;如果在触发器的上升沿发生时正在进行转换，则忽略该上升沿。在连续转换配置中，仅观察到启动连续转换的初始上升沿，直到转换中止，ADC将继续在启动转换的同一ADC硬件触发控制寄存器上进行转换。硬件触发功能与任何转换模式和配置一起工作。
&emsp;&emsp;为转换选择的信道将取决于启用的外部硬件触发器的活动硬件触发器寄存器字段ADC_HCn[ADCH]的设置。
**注意**：同时断言多个外部硬件触发选择信号将导致未知结果。为了避免这种情况，在下一次预期转换之前，只选择一个外部硬件触发选择信号。
&emsp;&emsp;当转换完成时，结果被放置在与接收到的外部硬件触发器相关联的数据寄存器中（活动触发器选择ADC_Rn）。然后设置与接收到的外部硬件触发相关联的转换完成标志（ADC_HS[COCOn]），并且如果相应的转换完成中断已被启用（ADC_HCn[AIEN]＝1），则生成中断。

#### 13.3.4 转换控制
&emsp;&emsp;转换由ADC_CFG[MODE]字段确定。
&emsp;&emsp;转换可以通过软件或硬件触发器启动。此外，ADC可以被配置用于低功率操作、长采样时间、连续转换、硬件平均以及转换结果与预定值的自动比较。

##### 13.3.4.1 启动转换
一次转换按如下方式启动：
* 写入ADC_HC0（ADCHn位不全为1）后，如果选择了软件触发操作（ADTRG=0）。
* 如果选择了硬件触发操作（ADTRG=1）并且发生了外部硬件触发选择事件，则在硬件触发事件之后。所选择的信道将取决于激活触发选择信号激活选择ADC_HC1；如果两者都不活动，则选择关闭条件）。
**注意**：在转换完成之前选择一个以上的外部硬件触发选择信号（ext_hwts[n]）将产生未知结果。为了避免这种情况，在转换完成之前只选择一个硬件触发选择信号（ext_hwts[n]）。
* 当启用连续转换时（ADC_GC寄存器中的ADCO=1），将结果传输到数据寄存器。

&emsp;&emsp;如果启用了连续转换，则在当前转换完成后自动启动新的转换。在软件触发操作（ADTRG=0）中，在ADC_HC0写入后开始连续转换，直到中止。在硬件触发操作中（ADTRG=1，并且发生了一个外部硬件触发选择事件），在硬件触发事件之后开始连续转换，直到中止。
&emsp;&emsp;如果启用了硬件平均，则在当前转换完成后自动启动新的转换，直到完成正确的转换次数。在软件触发操作中，ADC_HC0写入后开始转换。在硬件触发操作中，转换在硬件触发后开始。如果还启用了连续转换，则将在所选转换次数的最后一次之后启动一组新的平均转换。

##### 13.3.4.2 完成转换
&emsp;&emsp;当转换结果被传送到数据结果寄存器时，转换完成。（如果禁用了比较功能和硬件平均值），这通过COCOn的设置来指示。如果启用了硬件平均，则仅当所选转换数的最后一个完成时，才设置COOn。如果启用了比较功能，则仅当比较条件为真时，COCOn设置并传输转换结果数据。如果同时启用了硬件平均和比较功能，则仅当所选转换数的最后一个完成且比较条件为真时，COCOn才会设置。如果在设置COCOn时ADC_HCn[AIEN]为高电平，并且如果设置了DMAEN，如果设置了COCOn，则会产生中断。当COOn为低时，这两个请求都会被取消断言，清除，这在读取数据时发生。
&emsp;&emsp;在所有模式下，如果先前的数据正在读取过程中，则阻止机制可防止新结果覆盖ADC_Rn中的先前数据。当阻塞激活时（ADC_CFG中OVWREN=0），转换结果数据传输被阻塞，COCOn未设置，新结果丢失。在所有其他操作情况下，当转换结果数据传输被阻止时，无论ADCO的状态如何（启用单个或连续转换），都会启动另一个转换。
**注意**：如果启用连续转换，阻塞机制可能会导致特定时间点发生数据丢失。为了避免此问题，数据读取周期必须少于ADC转换时间，考虑到中断或软件轮询循环延迟。如果启用了单次转换，则阻塞机制可能会导致多次丢弃转换和过度功耗。为避免此问题，在启动单个转换后，在转换完成之前，不得读取数据寄存器。

##### 13.3.4.3 正在退出转换
在以下情况下，任何正在进行的转换都将中止：
* MCU在ADACK未启用的情况下进入停止模式。
* 在软件触发模式下，当ADC_HC0正在（已经）主动控制转换时，写入ADC_HC0寄存器，中止当前转换。由于ADC_HC1-ADC_HCn寄存器中的任何一个都不用于软件触发操作，因此，写入它们中的任何寄存器既不会启动新的转换，也不会中止软件触发的活动转换。
* 在硬件触发模式下，写入ADC_HC0-ADC_HCn寄存器中的任何一个，而该特定ADC_HC0-ADC_HCn寄存器正在主动控制转换，则中止当前转换。
* 除了ADC_HC0:ADC_HCn寄存器之外，还会发生对任何ADC寄存器的写入。这表明操作模式发生了变化，因此电流转换无效。

#### 13.3.6 校准功能
&emsp;&emsp;ADC 包含实现指定精度所需的自校准功能。在启动任何转换之前，应在通电和系统重置后（因为重置断言时将重置校准寄存器）使用指定设置运行校准或写入有效校准值。校准功能在运行 ADC_CAL 寄存器中的完整校准序列结束时设置校准值。用户必须在开始校准过程之前正确配置ADC，并且必须通过检查 ADC_GC[CAL] 和 ADC_GS[CALF] 的状态来允许该过程运行完整的校准序列，以便可以加载生成的校准值。
&emsp;&emsp;校准前，用户必须根据应用程序的时钟源可用性和需求配置 ADC 的时钟源和频率、低功率配置、电压参考选择、采样时间、平均值和高速配置。如果应用程序在多种配置中使用 ADC，则应选择需要最高精度的配置，或者可以针对不同配置进行多次校准。校准过程中，输入通道、转换模式、连续功能和比较功能均被忽略。
&emsp;&emsp;要启动校准，用户设置 CAL 位，如果 ADTRG 位=0，校准将自动开始。如果ADTRG=1，将不会设置CAL位，并且将设置校准失败标志（CALF）。当校准激活时，不能写入ADC寄存器，也不能进入停止模式，否则校准例程将中止，导致CAL位清零，CALF位置位。
&emsp;&emsp;在校准序列结束时，将设置 ADC_HS 寄存器的 COCO[0] 位。ADC_HCn[AIEN] 位可用于允许在校准序列结束时发生中断。如果在校准例程结束时未设置 CALF 位，则自动校准例程成功完成。
&emsp;&emsp;要完成校准，用户必须遵循以下步骤：
* 使用实际操作值配置ADC_CFG以获得最大精度。
* 配置 ADC_GC 值以及 CAL 位
* 检查 ADC_GS 中 CALF 位和 ADC_GC 中 CAL 位的状态
* 当CAL位变为“0”时，检查 CALF 状态和 COCO[0] 位状态

&emsp;&emsp;完成后，用户可以根据需要重新配置并使用ADC。
&emsp;&emsp;如果需要，也可以通过清除并再次设置CAL位来执行第二次校准
&emsp;&emsp;总的来说，校准程序可能需要14000个ADCK周期和100个总线周期，这取决于结果和选择的时钟源。

#### 13.3.7 用户定义的 offset 功能
&emsp;&emsp;ADC偏移校正寄存器（ADC_OFS）包含用户配置的偏移值。此寄存器为13位宽。MSB（第13位）中的值是操作位，如果此位为“0”，则将剩余12位中的值与转换后的结果值相加，以生成要加载到ADC_Rn中的最终结果；如果此位是“1”，则从转换后的值中减去此字段，以生成最终结果（ADC_Rn）。如果最终结果高于最大值或低于最小结果值，则强制将其设置为当前操作模式的适当限制。对于12位模式，如果超过则强制为0x0FFF，如果低于则强制为0x0000。
&emsp;&emsp;校准期间，偏移值对最终结果没有影响。
&emsp;&emsp;ADC偏移寄存器的格式与数据结果寄存器（ADC_Rn）不同，以保持值的分辨率，而不考虑所选的转换模式。在低分辨率模式下，低阶位被忽略。例如，在8b单端模式中，当位OFS[12]（符号位）为“1”时，从D[7:0]中减去位OFS[11:4]；指示减法，并且忽略位OFS[4:0]。对于12b单端模式，当OFS[12]（符号位）为“1”时，直接从转换结果数据CDATA[11:0]中减去OFS[11:0]位。类似的是当OFS[12]（符号位）为0时的加法运算。
&emsp;&emsp;完成自校准序列（CAL清除）后，根据用户要求手动设置ADC_OFS。用户必须使用所需值写入ADC_OFS。
&emsp;&emsp;**注意**：用户可以设置偏移值的有效限制。如果偏移量太大，则转换结果将限制在极限值。
&emsp;&emsp;用户可以使用偏移功能来去除应用偏移或DC偏置值。导致超出范围值的偏移校正将强制为最小值或最大值。
&emsp;&emsp;对于可能在操作过程中重复更改偏移的应用程序，建议将初始偏移值存储在闪存中，以便可以将其恢复并添加到任何用户偏移调整值和ADC_OFS寄存器中存储的总和中。




### 13.4 初始化信息
&emsp;&emsp;本节给出了一个示例，为如何初始化和配置ADC模块提供了一些基本指导。用户可以将模块配置为8位、10位、12位分辨率、单次或连续转换、轮询或中断方法等多种选项。

#### 13.4.2 ADC 模块初始化示例
本节介绍初始化序列和伪代码。

##### 13.4.1.1 初始化序列
在ADC模块可用于完成转换之前，必须执行初始化过程。典型的顺序如下：
* 按照校准功能中的校准说明校准ADC
* 更新配置寄存器（ADC_CFG）以选择输入时钟源和用于生成内部时钟ADCK的分频比。该寄存器还用于选择采样时间和低功耗配置。
* 更新通用控制寄存器（ADC_GC），以选择转换是连续还是仅完成一次（ADCO），并选择是否执行硬件平均等。
* 更新触发控制寄存器（ADC_HCn）以选择转换触发（硬件或软件，即配置ADTRG位）并比较功能选项（如果启用）。


### 13.6 内存映射和寄存器定义
&emsp;&emsp;ADC Digital包含32位、字对齐、字节启用寄存器；不支持字节或半字访问。所有配置寄存器均可通过32位访问总线接口访问。对保留位置的写访问没有影响，而对保留位置读访问始终返回0。
**注意**: 没有可用的保护或指示机制（例如，以地址偏移值0x01或0x02或0x03开始的32位访问）。ADC不会检查寄存器中编程值的正确性，程序员必须确保写入的值正确。




















## 第十五章 AHB-to-APBH Bridge with DMA (APBH-Bridge-DMA)
### 15.1 概述
&emsp;&emsp;AHB-to-APBH 桥接器为芯片提供了在 AHB 的 HCLK 上运行的廉价外设连接总线。 （APBH 中的 H 表示 APBH 与 HCLK 同步。）  
&emsp;&emsp;如下图所示，AHB-to-APBH 桥包括 AHB-to-APB PIO 桥，用于到 APB 设备的内存映射 I/O，以及用于该总线上的设备的中央 DMA 设施和一个 Arm内核的向量中断控制器。 每个 APB 外设，包括向量中断控制器，都在各自的章节中进行了记录。  
&emsp;&emsp;DMA 控制器使用 APBH 总线向每个外设传输读写数据。 这些设备没有单独的 DMA 总线。 DMA 对 APBH 总线的使用与 AHB 到 APB 桥功能对 APBH 的使用之间的争用由内部仲裁逻辑调解。 对于这两个单元之间的竞争，DMA 受到青睐，AHB 从设备将通过其 HREADY 输出报告“未准备好”，直到桥接传输完成。 仲裁器跟踪重复的锁定并反转优先级，保证 APB 上每四次传输一次 Arm 平台。 
### 15.2 时钟
&emsp;&emsp;此处的表格描述了 APBH 的时钟源。 有关时钟设置、配置和门控信息，请参阅时钟控制器模块 (CCM)。 
### 15.3 APBH DMA
&emsp;&emsp;DMA 支持四个通道的 DMA 服务，如下表所示。 共享 DMA 资源允许每个独立通道遵循简单的链式命令列表。 命令链使用通用结构构建，如图 15-2 所示。 
&emsp;&emsp;单个命令结构体或通道命令字指定由 DMA 执行以支持给定设备的许多操作。 因此，Arm 平台可以设置大型工作单元，将许多 DMA 通道命令字链接在一起，将它们传递给 DMA，并且在 DMA 完成中断发生之前不再关心设备。 目标是在 DMA 和设备中具有足够的智能，以将来自任何设备的中断频率保持在 1 KHz 以下（到达间隔长于 1 ms）。 
&emsp;&emsp;单个命令结构可以使用相同的 APB 总线向相关设备中的关键寄存器发出 32 位 PIO 写操作，并控制它用于将 DMA 数据字节写入设备。 例如，这允许向 GPMI 控制器发出一系列操作，以发送 NAND 命令字节、地址字节和数据传输，其中命令和地址结构完全受软件控制，但该传输的管理是由 DMA 自主处理的。 每个 DMA 结构可以附加 0-15 个 PIO 字。 CMDPIOWORDS 字段（如果非零）指示 DMA 引擎将这些字复制到 APB，从外设的第一个寄存器地址偏移量开始，并在每个周期递增寄存器偏移量。 
&emsp;&emsp;DMA 主机仅生成到 APBH 的正常读/写传输。 它不会生成设置、清除或切换 (SCT) 传输。 
&emsp;&emsp;在任何请求的 PIO 字传输到外设后，DMA 检查通道命令结构中的两位命令字段。 表 15-3 显示了 DMA 实现的四个命令。 
&emsp;&emsp;DMA_WRITE 操作将数据字节从相关外设复制到系统存储器（片上 RAM 或 SDRAM）。 
&emsp;&emsp;DMA_READ 操作将数据字节从系统存储器复制到 APB 外设。 DMA 引擎包含一个共享字节对齐器，用于对齐来自系统存储器和外设的字节。 外设总是假设小端对齐的数据到达或离开它们的 32 位 APB。 DMA_READ 传输使用命令结构中的 BUFFER_ADDRESS 字指向要由 DMA_READ 命令读取的 DMA 数据缓冲区。
&emsp;&emsp;NO_DMA_XFER 命令用于将 PIO 字写入设备而不执行任何 DMA 数据字节传输。 此命令在激活 NAND 设备 CHECKSTATUS 操作等应用中很有用。 检查状态命令从 NAND 设备读取状态字节，对作为 PIO 传输的一部分提供的预期值执行 XOR 和 MASK。 读取检查完成后（请参阅 NAND 读取状态轮询示例），NO_DMA_XFER 命令完成。 外设中的结果是其感测线由比较结果驱动。 感测触发器仅由执行的设备的 CHECKSTATUS 更新。 在未来的某个时刻，该链包含具有第四个也是最后一个命令值的 DMA 命令结构，即 DMA_SENSE 命令。 
&emsp;&emsp;随着每个 DMA 命令完成，它会触发 DMA 加载链中的下一个 DMA 命令结构。 DMA命令的正常流列表是通过跟踪DMA命令结构中的NEXTCMD_ADDR指针找到的。 DMA_SENSE 命令使用命令结构的 DMA 缓冲区指针字指向备用 DMA 命令结构链或列表。 DMA_SENSE 命令检查相关外设的检测线。 如果检测线为假，则 DMA 遵循找到的标准列表，其下一个命令是从命令结构的 NEXTCMD_ADDR 字中的指针中找到的。 如果检测线为真，则 DMA 遵循备用列表，其下一个命令是从 DMA_SENSE 命令结构的 DMA 缓冲区指针字中的指针中找到的（见图 15-2）。 检测命令忽略 CHAIN 位，因此当 DMA 发出检测命令时，两个指针都必须有效。  
&emsp;&emsp;如果在命令结构中设置了等待结束命令位 (WAIT4ENDCMD)，则 DMA 通道通过切换 endcmd 信号等待设备发出命令完成信号，然后再继续加载和执行下一个命令结构。 然后，如果设置了 DECREMENT_SEMAPHORE，则在看到结束命令后减少信号量。  
&emsp;&emsp;下表显示了 DMA 命令结构的详细位字段视图，其中显示了一个字段，该字段指定此 DMA 命令要传输的字节数。 传输计数机制在相关外设中复制，作为外设中的隐含或指定计数。  
&emsp;&emsp;Freq_i图 15-2 还显示了命令结构的第二个字的位 2 中的 CHAIN 位。 如果 NEXT_COMMAND_ADDRESS 包含指向另一个 DMA 命令结构的指针，则该位设置为 1。 如果将空指针 (0) 加载到 NEXT_COMMAND_ADDRESS 中，则 DMA 硬件不会检测到它。 只有 CHAIN 位指示在当前结构之外是否存在有效列表。  
&emsp;&emsp;如果在命令结构中设置了 IRQ_COMPLETE 位，则 DMA 在加载下一条命令之前的最后一个动作是设置当前通道对应的中断状态位。 DMA CSR 中的粘滞中断请求位保持置位，直到被软件清除。 它可以用来中断ARM平台。  
&emsp;&emsp;NAND_LOCK 位由 DMA 通道仲裁器监控。 在其 NAND_LOCK 位设置的仲裁器中成功，然后仲裁器忽略其他 NAND 通道，直到完成未设置 NAND_LOCK 的命令。 请注意，这里的语义是 NAND_LOCK 状态是限制非锁定 DMA 的调度。 当 NAND_LOCK 位置位时，DMA 通道可以在命令开始时在仲裁器中从解锁状态变为锁定状态。 当原子序列的最后一个 DMA 命令完成时，应该解除锁定。 为此，最后一条命令没有 NAND_LOCK 位。 命令启动时，它仍然被锁定在仲裁器内部的原子状态，因此它是唯一可以执行的 NAND 命令。 最后，它从仲裁器中的原子状态下降。  
&emsp;&emsp;NAND_WAIT4READY 位对 GPMI 通道（从通道到通道）也有特殊用途，即 NAND 设备通道。 GPMI 外设提供来自 NAND 设备的就绪行的样本。 该就绪值用于延迟该位设置的命令，直到就绪行断言为 1。一旦仲裁器看到设置了等待就绪的命令，它就会延迟该通道，直到断言就绪。  
&emsp;&emsp;接收 HALTONTERMINATE (HOT) 的 IRQ 是 APBH DMA 描述符中的一项功能，它允许 GPMI 向 DMA 引擎发送已发生错误的信号。 如果命令由于错误而停止，则从外设向 DMA 引擎发送 HOT 信号，并在终止正在执行的 DMA 描述符后引发 IRQ。  
&emsp;&emsp;因此，建议软件按如下方式使用该信号： 
* 在 DMA 描述符中始终将 HALTONTERMINATE 设置为 1。 这样，如果外设发出 HOT 信号，传输将结束，使外设块和 DMA 引擎保持同步（但在命令结束时）。 
* 当接收到来自 APBH 通道的 IRQ，并且确定该 IRQ 是由于错误（与 IRQONCOMPLETE 中断相反）导致的，软件应该： 
  * 复位通道；
  * 根据外设模块中的错误报告确定错误，然后以该设备存在的任何适当方式（软件恢复、设备复位、模块复位等）管理连接到该通道的外设中的错误。 

&emsp;&emsp;每个通道都有一个八位计数信号量，用于控制它是否处于空闲状态。 当信号量不为零时，通道已准备好运行、处理命令并执行 DMA 传输。 每当命令完成其 DMA 传输时，它都会检查 DECREMENT_SEMAPHORE 位。 如果设置，它会减少计数信号量。 如果信号量因此变为 0，则通道进入空闲状态并保持在那里，直到信号量被软件递增。 当信号量变为非零且通道处于空闲状态时，它使用 APBH_CHn_NXTCMDAR 寄存器（下一个命令地址寄存器）中的值来获取指向下一个要处理的命令的指针。 
&emsp;&emsp;注意：这是一个双重间接案例。 这种方法允许软件在计数信号量的保护下附加到一个正在运行的命令列表。  
&emsp;&emsp;第一次开始处理时，软件会创建要处理的命令列表。 它将第一个命令的地址写入 APBH_CHn_NXTCMDAR 寄存器，然后将 1 写入 APBH_CHn_SEMA 中的计数信号量。 DMA 通道加载 APBH_CHn_CURCMDAR 寄存器，然后进入正常状态机处理下一条命令。 当软件向计数信号量写入一个值时，它会被硬件添加到信号量计数中，以保护硬件和软件都试图在同一时钟沿更改信号量的情况。  
&emsp;&emsp;软件可以随时检查 APBH_CHn_CURCMDAR 的值以确定当前正在处理的命令结构的位置。 

### 15.5 寄存器定义
#### 15.5.1 AHB 到 APBH 桥接控制和状态寄存器 0（APBH_CTRL0n）
&emsp;&emsp;APBH CTRL 0 提供对 AHB 到 APBH 桥接和 DMA 的整体控制。  
&emsp;&emsp;该寄存器包含模块软复位、时钟门控、通道时钟门控/冻结位。 

| 位               | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 31 SFTRST        | 将此位设置为零以启用正常的 APBH DMA 操作。 将此位设置为 1（默认）以禁用 APBH DMA 的时钟并将其保持在其复位（最低功耗）状态。 该位可以打开然后关闭，以将 APBH DMA 块重置为其默认状态。（软件复位） |
| 30 CLKGATE       | 该位必须设置为零才能正常运行。 当设置为 1 时，它会关闭模块的时钟。 |
| 29 AHB_BURST8_EN | 将此位设置为 1（默认）以使能 AHB 8-beat burst。设置为 0 失能 AHB 上的 8-beat burst。 |
| 28 APB_BURST_EN  | 将此位设置为 1 可在设备请求 burst dma 时使能 apb 主机进行连续传输。 设置为 0 会将 burst dma 请求视为 4/8 个单独的请求。 |
| 27 RSVD0         |                                                              |
| CLKGATE_CHANNEL  | 为了每个通道的正常操作，这些位必须设置为零。 当设置为 1 时，它们会关闭通道的各个时钟。<br>0x0001    NAND0<br>0x0002    NAND1<br>0x0004    NAND2<br>0x0008    NAND3<br>0x0010    NAND4<br>0x0020    NAND5<br>0x0040    NAND6<br>0x0080    NAND7<br>0x0100    SSP |

#### 15.5.2 AHB 到 APBH 桥接控制和状态寄存器 1（APBH_CTRL1n）
&emsp;&emsp;APBH CTRL 1 提供对 AHB 对 APBH DMA 产生的中断的整体控制。 该寄存器包含每个通道的中断状态位和每个通道的中断使能位。 每个通道在向量中断控制器中都有一个专用的中断向量。 

| 位                      | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 31 CH15_CMDCMPLT_IRQ_EN | 设置该位可以使能 APBH DMA 通道 15 生成中断的请求。           |
| ......                  |                                                              |
| 15 CH15_ CMDCMPLT_ IRQ  | APBH DMA 通道 15 的中断请求状态位。该粘性位由 DMA 硬件设置并由软件复位。 它与相应的使能位进行“与”运算以产生中断。 |
| ......                  |                                                              |

#### 15.5.3 AHB 到 APBH 桥接控制和状态寄存器 2（APBH_CTRL2n）
&emsp;&emsp;APBH CTRL 2 将 AHB 生成的通道错误中断提供给 APBH DMA。 该寄存器包含每个通道的中断状态位和每个通道的中断使能位。 每个通道在向量中断控制器中都有一个专用的中断向量。 

| 位                    | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| 31 CH15_ERROR_ STATUS | APBH DMA 通道 15 的错误状态位。当相应的 Error IRQ 被设置时有效。<br>1：AHB bus error<br>0：通道提前终止。<br>0x0    TERMINATION：设备提前终止会导致错误 IRQ。<br>0x1    BUS_ERROR：AHB 总线错误导致错误 IRQ。 |
| .......               |                                                              |
| 15 CH15_ERROR_ IRQ    | APBH DMA 通道 15 的错误中断状态位。该粘性位由 DMA 硬件设置并由软件复位。 它与相应的 cmdcmplt irq 进行 OR 运算以生成 ARM 的 irq。 |
| ......                |                                                              |

#### 15.5.4 AHB 到 APBH 桥接通道寄存器（APBH_CHANNEL_CTRLn）
&emsp;&emsp;APBH CHANNEL CTRL 提供每个 DMA 通道的复位/冻结控制。 该寄存器包含单独的通道复位/冻结位。 

| 位                  | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| 31-16 RESET_CHANNEL | 在该字段中设置一个位会导致 DMA 控制器通过其复位状态获取相应的通道。 清除通道资源后，该位复位。<br>0x0001    NAND0<br/>0x0002    NAND1<br/>0x0004    NAND2<br/>0x0008    NAND3<br/>0x0010    NAND4<br/>0x0020    NAND5<br/>0x0040    NAND6<br/>0x0080    NAND7<br/>0x0100    SSP |
| FREEZE_CHANNEL      | 在该字段中设置一个位将冻结与其关联的 DMA 通道。 该字段是 DMA 通道仲裁器的直接输入。 冻结时，通道被定义为访问中央 DMA 资源。<br>0x0001    NAND0<br/>0x0002    NAND1<br/>0x0004    NAND2<br/>0x0008    NAND3<br/>0x0010    NAND4<br/>0x0020    NAND5<br/>0x0040    NAND6<br/>0x0080    NAND7<br/>0x0100    SSP |
#### 15.5.5 AHB 到 APBH DMA 设备分配寄存器 
&emsp;&emsp;没用
#### 15.5.6 AHB 到 APBH DMA burst size（APBH_DMA_BURST_SIZE）
&emsp;&emsp;当发出 DMA burst 请求时，该寄存器对 APBH DMA 设备的 apbh burst size 进行编程。
&emsp;&emsp;该寄存器提供了一种分配设备的机制。 

| 位        | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| 17–16 CH8 | DMA burst size for SSP.<br>0x0    BURST0<br>0x1    BURST4<br>0x2    BURST8 |
| 15–14 CH7 | GPMI 通道 7 的 DMA burst 大小。不要更改。 GPMI 仅支持 burst 大小 4。 |
|           |                                                              |

#### 15.5.7 AHB to APBH DMA Debug 寄存器 (APBH_DEBUG)
&emsp;&emsp;该寄存器用于调试目的。
&emsp;&emsp;调试寄存器仅供内部使用。 不推荐客户使用。 

#### 15.5.8 APBH DMA 通道 n 当前命令地址寄存器 (APBH_CHn_CURCMDAR) 
&emsp;&emsp;APBH DMA 通道 n 当前命令地址寄存器指向当前正在执行的多字命令。 命令在命令地址上线程化。
&emsp;&emsp;APBH DMA 通道 n 由可变大小的命令结构控制。 该寄存器指向当前正在执行的命令结构。 

| 位       | 描述                                        |
| -------- | ------------------------------------------- |
| CMD_ADDR | 指向当前正在为通道 n 处理的命令结构的指针。 |

#### 15.5.9 APBH DMA 通道 n 下一个命令地址寄存器 (APBH_CHn_NXTCMDAR) 
&emsp;&emsp;APBH DMA 通道 n 下一个命令地址寄存器包含要执行的下一个多字命令的地址。 命令在命令地址上线程化。 在 DMA 命令字中将 CHAIN 设置为 1 以处理命令列表。
&emsp;&emsp;APBH DMA 通道 n 由可变大小的命令结构控制。 软件将第一个命令结构的地址加载到该寄存器以进行处理，并增加通道 n 信号量以开始处理。 该寄存器指向当前命令完成时要执行的下一个命令结构。 

| 位       | 描述                                        |
| -------- | ------------------------------------------- |
| CMD_ADDR | 指向下一条为通道 n 处理的命令结构的指针。 |

#### 15.5.10 APBH DMA 通道 n 命令寄存器 (APBH_CHn_CMD) 
&emsp;&emsp;APBH DMA 通道 n 命令寄存器指定要为当前命令链项执行的 DMA 事务。
&emsp;&emsp;命令寄存器控制该通道的每个 DMA 命令的整体操作。 它包括传输到设备或从设备传输的字节数、包含在此命令结构中的 APB PIO 命令字的数量、是否在命令完成时中断、是否将附加命令链接到该命令的末尾以及此传输是否是读或写 DMA 传输。 

| 位                | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| 31-16 XFER_COUNT  | 该字段指示与 GPMI0 设备中适当的 PIO 寄存器之间传输的字节数。 值 0 表示 64 KB 传输。 |
| 15–12 CMDWORDS    | 该字段指示要发送到 GPMI0 的命令字的数量，从 GPMI0 控制寄存器的 PIO 基地址开始并从那里递增。 零表示无传输命令字 |
| 11-9 reserved     |                                                              |
| 8 HALTONTERMINATE | 值 1 表示如果设置了终止信号，通道将立即终止当前描述符并停止 DMA 通道。 如果设置了终止信号，值 0 仍将导致通道立即终止，但通道将继续运行，就好像计数已用完一样，这意味着它将遵循 IRQONCMPLT、CHAIN、SEMAPHORE 和 WAIT4ENDCMD。 |
| 7 WAIT4ENDCMD     | 值 1 表示通道将等待命令结束信号从 APBH 设备发送到 DMA，然后再开始下一个 DMA 命令。 |
| 6 SEMAPHORE       | 值 1 表示通道将在当前命令结构完成时减少其信号量。 如果信号量减为零，则此通道停止，直到软件再次增加它。 |
| 5 NANDWAIT4READY  | 值 1 表示 NAND DMA 通道将等到 NAND 设备报告“就绪”后再执行命令。 对于非 NAND DMA 通道，它会被忽略。 |
| 4 NANDLOCK        | 值 1 表示 NAND DMA 通道将在仲裁器中保持“锁定”状态，但会牺牲其他 NAND DMA 通道。 对于非 NAND DMA 通道，它会被忽略。 |
| 3 IRQONCMPLT      | 值 1 表示通道将在当前命令完成后（即 DMA 传输完成后）设置中断状态位。 |
| 2 CHAIN           | 值 1 表示另一个命令链接到当前命令结构的末尾。 当前命令完成后，该通道将跟随 APBH_CHn_CMDAR 中的指针寻找下一条命令。 |
| COMMAND           | 该位域指示当前命令的类型： <br>0x0    NO_DMA_XFER：执行任何请求的 PIO 字传输，但在任何 DMA 传输之前终止命令。 <br>0x1    DMA_WRITE：执行任何请求的 PIO 字传输，然后从外设执行指定字节数的 DMA 传输。 <br>0x2    DMA_READ：执行任何请求的 PIO 字传输，然后针对指定字节数执行到外设的 DMA 传输。 <br>0x3    DMA_SENSE：执行任何请求的 PIO 字传输，然后执行条件分支到下一个链接设备。 如果外围意义为真，则跟随 NEXCMD_ADDR 指针。 如果外围检测线为假，则将 BUFFER_ADDRESS 作为链指针。 |

#### 15.5.11 APBH DMA Channel n Buffer Address Register (APBH_CHn_BAR)
&emsp;&emsp;APBH DMA 通道 n 缓冲区地址寄存器包含一个指向用于传输的数据缓冲区的指针。 对于立即数形式，数据取自该寄存器。 这是一个字节地址，这意味着传输可以从任何字节边界开始。 
&emsp;&emsp;该寄存器保存指向系统内存中数据缓冲区的指针。 在命令值被读入 DMA 控制器和由该通道控制的设备之后，DMA 传输将开始，传输到或来自该寄存器指向的缓冲区。

| 位      | 描述                                               |
| ------- | -------------------------------------------------- |
| ADDRESS | 要通过 AHB 总线读取或写入的系统内存缓冲区的地址 。 |

#### 15.5.12 APBH DMA Channel n Semaphore Register (APBH_CHn_SEMA)
&emsp;&emsp;APBH DMA Channel n 信号量寄存器用于同步 Arm 平台指令流和 DMA 链处理状态。
每个 DMA 通道都有一个 8 位计数信号量，用于在程序流和 DMA 链处理之间进行同步。 DMA 处理将继续，直到 DMA 尝试减少已达到零值的信号量。 进行尝试时，DMA 通道会停止，直到软件增加信号量计数。 

| 位              | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| 31-24 reserved  |                                                              |
| 23-16 PHORE     | 此只读字段显示信号量计数器的当前（瞬时）值。                 |
| 15-8 reserved   |                                                              |
| INCREMENT_ SEMA | 写入此字段的值以原子方式添加到信号量计数中，从而保护在同一时钟上同时发生的软件添加和 DMA 硬件减法。 该位字段读回值 0x00。 写入 0x02 值会使信号量计数增加 2，除非 DMA 通道在同一时钟上减少计数，否则计数会增加净 1。 |

## 第四十章 PWM
### 40.1 概述
&emsp;&emsp;脉冲宽度调制 (PWM) 有一个 16 位计数器，并经过优化以从存储的样本音频图像中生成声音，它还可以生成音调。 它使用 16 位分辨率和 4 x 16 数据 FIFO。
本节概述了 PWM。 PWM 模块的框图如下图所示。 
&emsp;&emsp;PWM 具有以下特点： 
* 带时钟源选择的 16 位递增计数器 
* 4 x 16 FIFO 以最小化中断开销 
* 用于时钟分频的 12 位预分频器 
* 声音和旋律生成 
* 高电平有效或低电平有效配置输出 
* 可以编程为在低功耗模式下处于活动状态 
* 可以编程为在调试模式下处于活动状态 
* 比较和翻转时的中断 
### 40.2 外部信号 
&emsp;&emsp;PWM 在与处理器内核接口时遵循 IP 总线协议。 除了来自时钟控制模块 (CCM)、系统复位控制器 (SRC) 的时钟和复位输入以及处理器中断处理程序的中断信号外，PWM 与芯片内的任何其他模块没有任何接口信号。 有一个单一的输出信号。
&emsp;下表概述了外部信号。 

| Signal   | 描述                                                         | Pad            | Mode | 描述 |
| -------- | ------------------------------------------------------------ | -------------- | ---- | ---- |
| PWM1_OUT | 这是 PWM 的 PWM1 功能输出。 在此引脚上观察到模块的调制信号。 它可以看作是一个时钟信号，其周期和占空比可以随着 50% 周期的不同设置而变化。 | ENET1_RX_DATA0 | ALT2 | O    |
|          |                                                              | GPIO1_IO08     | ALT0 |      |
|          |                                                              | LCD_DATA00     | ALT1 |      |
| ......   |                                                              |                |      |      |
| PWM8_OUT |                                                              |                |      |      |

### 40.3 时钟
&emsp;&emsp;此处的表格描述了 PWM 的时钟源。 有关时钟设置、配置和门控信息，请参阅时钟控制器模块 (CCM)。   
&emsp;&emsp;可以从以下选项中选择预分频器的时钟： 
* 高频参考时钟 (ipg_clk_highfreq) pat_ref 或 CKIH 
  这是一个高频时钟，由时钟控制模块 (CCM) 提供。 当 ipg_clk 关闭时，该时钟应在低功耗模式下打开。 因此，PWM 可以在低功耗模式下在该时钟上运行。 CCM 预计在正常功能模式下将其同步到 ahb_clk 后提供此时钟，然后在低功耗模式下切换到非同步版本。  
* 低频参考时钟 (ipg_clk_32k, CKIL) 
  这是由 CCM 提供的 32 KHz 低频参考时钟。 当 ipg_clk 关闭时，该时钟应在低功耗模式下打开。 因此，PWM 可以在低功耗模式下在该时钟上运行。 CCM 预计在正常功能模式下将其同步到 ahb_clk 后提供此时钟，然后在低功耗模式下切换到非同步版本。 
* 外设时钟 (ipg_clk) 
  此时钟应在正常操作中打开。 在低功耗模式下，可以将其关闭。
* 外设访问时钟 (ipg_clk_s) 
  该时钟用于寄存器读/写。

&emsp;&emsp;时钟输入源由 PWM 控制寄存器字段 PWM_CR[CLKSRC] 确定。要更改 CLKSRC 值需要先失能 PWM。
&emsp;&emsp;控制寄存器的 PRESCALER 字段值的变化会立即反映在其输出时钟频率上。  

### 40.4 功能描述
&emsp;&emsp;下面的章节描述了 PWM 的操作和功能。
#### 40.4.1 操作
&emsp;&emsp;PWM 的输出是一个切换信号，其频率和占空比可以通过编程适当的寄存器来调制。 它有一个 16 位向上计数器，从 0x0000 开始计数，直到计数器值等于 PWM_PR + 1。匹配发生后，计数器重置为 0x0000。
&emsp;&emsp;在计数周期开始时，PWMO 引脚设置为 1（默认），计数器从 0x0000 开始向上计数。 在预分频器时钟的每个计数上比较采样 FIFO 中的采样值。 当采样值和计数值匹配时，PWMO 信号设置为 0（默认）。 计数器继续计数，直到周期匹配发生，随后另一个周期周期开始。
&emsp;&emsp;当 PWM 使能时，计数器开始运行并生成一个输出，其周期和采样值使用寄存器中复位时的值。 建议在启用 PWM 之前对这些寄存器进行编程。
&emsp;&emsp;硬件复位会导致所有 PWM 计数和采样寄存器被清除，FIFO 被刷新。 控制寄存器显示 FIFO 为空，可写入，PWM 关闭。 软件复位具有相同的结果，但是控制寄存器中的 DBGEN、STOPEN、DOZEN 和 WAITEN 位的状态不受影响。 即使 PWM 处于禁用状态，也可以断言软件复位。
##### 40.4.1.1 FIFO
&emsp;&emsp;数字采样值可以作为 16 位字加载到脉宽调制器中。可以使用控制寄存器的 BCTR 和 HCTR 位更改字节顺序。 4 字（16 位）FIFO 将中断开销降至最低。当数据字数低于控制寄存器中 FWM 字段设置的水位时，会产生可屏蔽中断。
&emsp;&emsp;如果 FIFO 未满，写入 PWM_SAR 采样寄存器会导致值被存储到 FIFO 中。 FIFO 满时写入会设置状态寄存器中的 FWE（FIFO 写入错误）位，并且 FIFO 内容保持不变。 FIFO 可以随时写入，但只能在 PWM 使能时读取。 PWM_SR[FIFOAV] 字段显示 FIFO 中当前包含多少数据字以及是否可以写入。
&emsp;&emsp;对采样寄存器的读取产生当前 FIFO 值，PWM 正在使用或将使用该值来生成输出信号。因此，对样本寄存器的写入和后续读取可能会导致获得不同的值。 
##### 40.4.1.2 翻转和比较事件 
&emsp;&emsp;在其值等于PWM_PR[周期]+1后，计数器重置为0x0000，然后继续计数。此事件称为滚动。例如，如果PWM_PR[PERIOD]=0x0000，则计数器在等于0x0001时复位。当PWM_PR[周期]=0xFFFF或0xFFFE时，计数器在等于0xFFFF时复位。有关更多信息，请参阅PWM周期寄存器（PWM_PR）说明。
&emsp;&emsp;在滚动事件期间，通过 control register 的 POUTC 字段来设置为set(default), reset或no effect。如果在控制寄存器中设置了相应的中断启用位，则此事件也会生成中断。
&emsp;&emsp;当计数器值达到采样值时，根据控制寄存器 POUTC 字段的编程，PWM 输出复位（默认）、置位或无效。此事件称为比较事件。如果在控制寄存器中设置了相应的中断启用位，则此事件也会生成中断。
&emsp;&emsp;如果翻滚事件设置PWM输出信号，则比较事件将对其进行重置，反之亦然，用于 POUTC 字段的特定编程配置。
##### 40.4.1.3 低功耗模式行为
&emsp;&emsp;在低功耗模式下，如果来自所选时钟源的时钟可用，则 PWM 计数器继续运行并产生输出，具体取决于是否设置了该模式的控制位。 在没有时钟本身的情况下，或者如果控制寄存器中相应的低功耗位为 0，则计数器复位并在退出低功耗模式时恢复计数。 
##### 40.4.1.3 Debug 模式行为
&emsp;&emsp;在调试模式下，PWM 可以选择继续运行或停止。 如果 PWM_PWMCR 中的 DBGEN 位未设置，则 PWM 停止。 如果 DBGEN 位置位，那么 PWM 将继续在调试模式下运行。 
### 40.5 使能PWM操作序列
1. 失能PWM（PWMx_PWMCR[0]=0），再设置所需要的PWM控制寄存器（PWMx_PWMCR）。
2. 在PWM中断寄存器（PWMx_PWMIR）中启用所需的中断。
3. 一到三个初始样本可写入PWM样本寄存器（PWMx_PWMSAR）。即使PWM尚未启用，初始采样值也将加载到PWM FIFO中。不要写入第四个样本，因为FIFO将变满并触发FIFO写入错（FWE）。一旦启用，该错误将阻止PWM启动。
4. 检查PWM状态寄存器（PWMx_PWMSR）中的FIFO写入错误状态位（FWE）、比较状态位（CMP）和翻滚状态位（ROV），确保它们都为零。任何非零状态位都应通过向其写入1来清除。
5. 将所需周期写入PWM周期寄存器（PWMx_PWMPR）。
6. 通过将1写入PWM启用位PWMx_PWMCR[0]来启用PWM，同时将其他寄存器位保持在其先前配置的状态。
### 40.6 失能PWM操作序列
&emsp;&emsp;通过清除PWM使能位PWMx_PWMCR[0]至0，可随时禁用PWM。
&emsp;&emsp;禁用PWM后，FIFO中剩余的任何数据将不会在PWM输出处产生，并将保留在FIFO中，直到再次启用PWM。软件复位（将PWMx_PWMCR[3]设置为1）或硬件复位将清除FIFO，所有剩余数据将丢失。
### 40.7 PWM 寄存器
&emsp;&emsp;一共有8个PWM，每个PWM有6个寄存器。
#### 40.7.1 PWM Control Register (PWMx_PWMCR)
&emsp;&emsp;PWM 控制寄存器 (PWM_PWMCR) 用于配置 PWM 的操作设置。 它包含时钟分频的预分频器。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-28 reserved |                                                              |
| 27-26 FWM      | FIFO Water Mark。这两位被用于设置“FIFO 中的数据为多少时 FIFO empty flag 被设置”，且产生相应的中断<br>00    当 FIFO 中有 ≥ 1 空槽时，设置 FIFO empty<br>01    当 FIFO 中有 ≥ 2 空槽时，设置 FIFO empty<br>10    当 FIFO 中有 ≥ 3 空槽时，设置 FIFO empty<br>11    当 FIFO 中有 ≥ 4 空槽时，设置 FIFO empty |
| 25 STOPEN      | 使能 stop mode。 该位在停止模式下保持 PWM 功能。 当该位清零时，输入时钟在停止模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在停止模式下无效 <br>1    在停止模式下有效 |
| 24 DOZEN       | 使能 doze mode（打盹模式）。 该位使 PWM 在 doze 模式下保持功能。 当该位清零时，输入时钟在 doze 模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在 doze 模式下无效<br>1    在 doze 模式下有效 |
| 23 WAITEN      | 使能等待模式。 该位使 PWM 在等待模式下保持功能。 当该位清零时，输入时钟在等待模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。<br>0    在等待模式下有效<br>1    在等待模式下无效 |
| 22 DBGEN       | 使能调试模式。 该位使 PWM 在调试模式下保持功能。 当该位清零时，输入时钟在调试模式下被关闭。 该位不受软件复位的影响。 由硬件复位清除。 <br>0    在调试模式下有效<br>1    在调试模式下无效 |
| 21 BCTR        | 字节数据交换控制。 该位决定 16 位数据从采样寄存器进入 FIFO 时的字节顺序。 <br>0    保持相同的字节序<br>1    字节序反转 |
| 20 HCTR        | 半字数据交换控制。 该位决定将来自 32 位 IP 总线接口的哪个半字数据写入采样寄存器的低 16 位。 <br>0    半字交换不发生<br>1    交换写数据总线的半个字 |
| 19-18 POUTC    | PWM 输出配置。 该位确定输出引脚上 PWM 输出的模式。 <br>00    输出引脚在翻转时设置并在比较时清除 <br>01    输出引脚在翻转时清零并在比较时设置  <br>10    PWM输出断开  <br>11    PWM输出断开 |
| 17-16 CLKSRC   | 选择时钟源。 这些位确定将选择哪个时钟输入来运行计数器。 复位后选择系统功能时钟。 如果这些位设置为 00，也可以关闭输入时钟。该字段值仅应在失能 PWM 时更改 <br>00    关闭时钟<br>01    ipg_clk<br>10    ipg_clk_highfreq<br>11    ipg_clk_32k |
| 15–4 PRESCALER | 计数器时钟预分频器值。 该位字段确定时钟在进入计数器之前将被分频的值。 <br>0x000    1 分频<br>0x001    2 分频<br>0xfff    4096分频 |
| 3 SWR          | 软件复位。当此位设置为 1 时 PWM 复位。它是一个自清除位。向该位写 1 是一个等待状态的写周期。 当模块处于复位状态时，该位被设置，并在复位过程结束时被清除。 设置该位会将所有寄存器复位为其复位值，但该控制寄存器中的 DBGEN、STOPEN、DOZEN 和 WAITEN 位除外。 <br>0    PWM 未复位<br>1    PWM PWM 正在复位 |
| 2-1 REPEAT     | 采样重复次数。 该位字段确定使用 FIFO 中每个采样值的次数。 <br>00    使用每个采样值 1 次<br>01    使用每个采样值 2 次<br>10    使用每个采样值 4 次<br>11    使用每个采样值 8 次 |
| 0 EN           | PWM 使能。 该位使能 PWM。 如果该位未使能，则时钟预分频器和计数器复位。 当 PWM 使能时，它开始一个新的周期，输出引脚设置为开始一个新的周期，同时释放预分频器和计数器并开始计数。 <br>要使 PWM 与软复位和使能/失能一起工作，用户可以通过设置 SWR 位进行软件复位，等待软件复位完成，配置寄存器，然后通过将该位设置为“1”来启用 PWM <br>如果 PWM 想要使用相同的寄存器配置停止和恢复，用户还可以使能/失能 PWM。 <br>0    PWM 失能<br>1    PWM 使能 |

#### 40.7.2 PWM Status Register (PWMx_PWMSR)
&emsp;&emsp;PWM 状态寄存器 (PWM_PWMSR) 包含 7 个位，用于显示 FIFO 的状态以及翻转和比较事件的发生。 FIFOAV 位是只读的，但其他四位可以通过向它们写入 1 来清除。 FE、ROV 和 CMP 位分别与 FIFO-Empty、Roll-over 和 Compare 中断相关联。 

| 位            | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 31-7 Reserved |                                                              |
| 6 FWE         | FIFO 写错误状态。 该位表示已尝试在 FIFO 已满时对其进行写入。 <br>0    没有发生 FIFO 写错误<br>1    发生了 FIFO 写错误 |
| 5 CMP         | 比较状态位。此位表明发生了一个比较事件。<br>0    没有发生比较事件<br>1    发生了比较事件 |
| 4 ROV         | 反转状态位。 该位表明发生了一个翻转事件。<br>0    没有发生反转事件<br>1    发生了反转事件 |
| 3 FE          | FIFO 空状态位。 该位指示 FIFO 数据级别与控制寄存器中 FWM 字段设置的水位的比较。 <br>0    Data level is above water mark<br>1    When the data level falls below the mark set by PWM field |
| FIFOAV        | FIFO 可用。 这些只读位指示 FIFO 中剩余的数据级别。 尝试写入这些位不会影响它们的值，并且不会产生传输错误。<br>000    没有有效数据<br>001    FIFO 中有一个 word 的数据 <br>010    FIFO 中有两个 word 的数据<br>011    FIFO 中有三个 word 的数据<br>100    FIFO 中有四个 word 的数据<br>101    未使用<br>110    未使用<br>111    未使用 |

#### 40.7.3 PWM Interrupt Register (PWMx_PWMIR)
&emsp;&emsp;PWM 中断寄存器 (PWM_PWMIR) 包含三个位，用于控制比较、翻转和 FIFO 空中断的产生。 

| 位            | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| 31-3 reserved |                                                              |
| 2 CIE         | 比较中断使能位。此位控制比较中断的产生<br>0    比较中断未使能<br>1    比较中断使能 |
| 1 RIE         | 翻转中断使能位。此位控制翻转中断的产生<br>0    翻转中断未使能<br>1    翻转中断使能 |
| 0 FIE         | FIFO 空中断使能。此位控制 FIFO 空中断的产生<br>0    使能 FIFO 空中断<br>1    使能 FIFO 空中断 |

#### 40.7.4 PWM Sample Register (PWMx_PWMSAR)
&emsp;&emsp;PWM 采样寄存器 (PWM_PWMSAR) 是 FIFO 的输入。 16 位字被加载到 FIFO。 FIFO 可以随时写入，但只能在 PWM 使能时读取。 如果 FIFO 的所有值都已被使用，PWM 将以最后设置的占空比设置运行，直到重新加载 FIFO 或禁用 PWM。 当写入新值时，占空比会在当前周期结束后发生变化。
&emsp;&emsp;采样寄存器中的零值将导致 PWMO 输出信号始终为低/高（POUTC = 00 为低，POUTC = 01 为高），不会产生输出波形。 如果此寄存器中的值高于 PERIOD + 1，则输出将永远不会根据 POUTC 值设置/重置。

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| SAMPLE         | 样本值。 这是 4x16 FIFO 的输入。 该寄存器中的值表示当前正在使用的样本的值。 |

 

#### 40.7.5 PWM Period Register (PWMx_PWMPR)
&emsp;&emsp;PWM 周期寄存器 (PWM_PWMPR) 决定 PWM 输出信号的周期。 计数器值与 PERIOD + 1 匹配后，计数器复位以开始另一个周期。 
PWMO (Hz) = PCLK(Hz) / (period +2)
&emsp;&emsp;PWM_PWMPR 中的零值将导致输出信号的周期为两个时钟周期。 向该寄存器写入 0xFFFF 将获得与写入 0xFFFE 相同的结果。
&emsp;&emsp;由于写入 PWM_PWMPR 而导致的周期值变化会导致计数器重置为零并开始新的计数周期。 
注意：当 PWMx_PWMCR REPEAT 位设置为非零值时，将 PWM_PWMPR 设置为 0xFFFF 是不允许的。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| PERIOD         | 周期值。 这些位确定计数周期的周期。 计数器计数到 [Period Value] +1，然后重置为 0x0000。 |

#### 40.7.6 PWM Counter Register (PWMx_PWMCNR)  
&emsp;&emsp;只读脉冲宽度调制器计数器寄存器 (PWM_PWMCNR) 包含当前计数值，可随时读取而不会干扰计数器。 

| 位             | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 31-16 reserved |                                                              |
| COUNT          | 计数器值。 这些位是计数器寄存器的值，表示计数器寄存器的当前计数状态。 |




## 第四十六章 SDMA
### 46.1 概述
&emsp;&emsp;智能直接内存访问 (SDMA) 控制器提供极具竞争力的 DMA 功能以及灵活的基于软件的虚拟 DMA。 它支持外围 I/O 设备和内部/外部存储器之间的数据传输。
&emsp;&emsp;SDMA 控制器通过在动态数据路由中卸载 Arm 内核来帮助最大限度地提高系统性能。 
#### 46.1.1 框图 
&emsp;&emsp;下图显示了 SDMA 控制器的框图。 它包括自定义 RISC 内核及其 RAM、ROM、DMA 单元和调度程序。 


&emsp;&emsp;SDMA核心执行<u>执行DMA传输</u>的短例程；这些例程称为脚本。SDMA核心通过SDMA系统总线连接到自己的内存。SDMA系统总线支持32位数据路径和16位地址总线。系统总线数据路径用于16位指令（程序）内存访问和32位数据访问。DMA单元通过功能单元总线与核心接口，并使用专用寄存器执行DMA传输。
&emsp;&emsp;SDMA内存包含一个 ROM 和一个 RAM 。ROM包含启动脚本（例如，启动代码）和其他公用工具，它们由驻留在 RAM 中的脚本引用。内部 RAM 分为上下文区域和脚本区域（有关此映射的更多详细信息，请参阅指令内存映射和数据内存映射）。
&emsp;&emsp;每个传输通道在不活动时都需要一个上下文区域来保持所有内核和单元寄存器的内容。通道脚本由 SDMA 使用在引导序列期间启动的专用通道下载到内部 RAM。使用 Arm 平台提供的命令和指针调用下载。每个通道都包含位于 RAM 和/或 ROM 中的相应通道脚本，可以根据需要独立重新配置。通道脚本可以存储在外部存储器中，并在需要时下载。SDMA 可以配置任何脚本组合，以实现支持服务的无限组合。 
&emsp;&emsp;调度程序监视和检测 DMA 请求，将它们映射到通道，并将各个通道映射到预先配置的优先级。在任何给定点，调度程序都会向 SDMA 内核提供需要服务的最高优先级的通道。一个特殊的 SDMA 核心指令用于“有条件地将正在执行的当前通道”让给需要服务的合格通道。如果（且仅当）有一个合格的通道待处理，当前通道执行将会被抢占。
&emsp;&emsp;有两个 yield 指令以不同的方式确定合适的通道： 在第一个版本中，合适通道是待处理的通道，其优先级严格高于当前通道优先级。在第二个版本（yieldge）中，符合条件的通道是优先级大于或等于当前通道优先级的待处理通道。调度程序通过其 48 个 DMA 请求输入检测需要服务的设备。在检测到请求后，调度程序确定由该请求触发的通道并将其标记为“通道未决（EP）”寄存器中的未决。所有未决通道的优先级不断评估，以更新最高的未决优先级。传输完成后，通道脚本会清除通道挂起标志。 
&emsp;&emsp;Arm 平台控制块包含用于配置 32 个单独通道的控制寄存器。有 48 个通道使能寄存器，每个寄存器将一个 DMA 请求映射到任何所需的通道组合。 32 个优先级寄存器用于为每个可能的通道分配可编程的 7 级优先级。该块还包含 Arm 平台可以访问的所有其他控制寄存器。
&emsp;&emsp;连接到调度程序的 48 个 DMA 请求来自多种来源。 UART 和 USB 端口中的“接收寄存器满”和“发送寄存器空”信号是可以连接到 SDMA 的 DMA 请求的典型示例。这些请求可用于触发特定的 SDMA 通道或多个通道。
&emsp;&emsp;有一个用于产品开发的 OnCE 兼容调试端口。 OnCE 包括对设置断点、单步和跟踪以及寄存器转储功能的支持。此外，所有内存位置都可以从调试端口访问。 
#### 46.1.2 特征 
以下是 SDMA 功能： 
* 支持多达 32 个时分复用 DMA 通道的多通道 DMA 
* 每个通道的硬件或软件驱动触发器 
* 48 个硬件驱动的触发器，可以映射到任何通道。 
* 存储器访问，包括线性寻址、FIFO 寻址和 2D 寻址 
* 具有两级、基于优先级的抢占式多任务的快速上下文切换 
* 16 位指令集 micro-RISC 引擎（SDMA 内核） 
* 具有以下部分或全部功能的两个 DMA 单元： 
  * 自动刷新和预取功能 
  * 灵活的地址管理（递增、递减，源地址和目标地址不变） 
  * 未对齐的数据传输支持 
  * 单向和双向流（复制模式） 
  * 多达 8 个字的缓冲区，用于可配置的突发传输 
* 支持字节交换 
* 可用的 API 和脚本库 
* 小端和大端模式
* 用于低功耗进入序列的硬件握手 
* 安全支持锁定 SDMA 脚本 RAM 的内容。 
* 4 KB ROM，包含启动脚本（例如，引导代码）和其他可由位于 RAM 的脚本引用的常用实用程序 
* 8 KB RAM 区域分为处理器上下文区域和代码空间区域，用于存储从系统内存下载的通道脚本 
* 调试支持，包括 OnCE 端口、实时监视器和嵌入式交叉触发事件 
* 进程中支持的时钟频率： 
  * SDMA 内核和 Arm 平台 DMA 单元的可配置时钟选项 
    * 1:2 比率，最大 SDMA 内核以 Arm 平台外设总线速度运行，DMA 以最大 DMA 频率运行。 
    * 当 SDMA 内核和 Arm 平台 DMA 时钟都设置为 Arm 平台外设总线速度时，比率为 1:1。 
* Arm 平台用于配置寄存器编程的外设总线接口 
* SDMA RISC 引擎（算术和逻辑运算），称为“SDMA 核心”。 
* 连接到共享外设总线接口 (SPBA) 的内部外设总线，可以访问多达 14 个共享外设。 SDMA 支持对字外设的 32 位访问和对半字外设的 16 位访问。 
* 连接到 Arm 平台 Crossbar Switch 以服务 Arm 外设的外设 DMA 单元 
* 突发 DMA 单元能够对外部存储器执行突发访问 
* 所有的 DMA 单元都是 32 位 AHB 主机。 它们连接到不同的总线，从而允许并发访问。 
### 46.4 功能描述
&emsp;&emsp;下图显示了 SDMA 拓扑，由以下组件组成： 

&emsp;&emsp;功能单元总线提供 SDMA 内核对 DMA 单元的访问。系统总线提供对 SDMA 内部存储器的访问，并且还支持多达 14 个外设。 
#### 46.4.1 SDMA Core
&emsp;&emsp;SDMA 内核是一种定制的类似 RISC 的处理器，专门开发用于控制 DMA 单元并执行 L1 任务，如字节填充或成帧。 
&emsp;&emsp;SDMA 内核包含使用 OnCE 的片上调试功能。
&emsp;&emsp;SDMA 内核基于具有 16 位指令的 32 位寄存器架构。 有八个通用 32 位寄存器、四个标志（T、LM、SF 和 DF）和四个 PCU 寄存器（PC、RPC、SPC 和 EPC），可寻址 16,384 条 16 位指令。 
##### 46.4.1.1 SDMA Core Structure
&emsp;&emsp;此处找到的图显示了 SDMA 内核的结构。 它还显示了不同的寄存器、计算资源和可能的数据移动。 
* 程序控制单元 (PCU) 在程序控制单元 (PCU) 中进行了描述。 它处理内核的状态并生成指令获取地址。 指令从指令总线 (IBUS) 中检索，并在解码之前存储在 SDMA 核心指令寄存器中。 PCU 包含以下寄存器： 
  * 程序计数器 (PC) 包含当前指令的地址。 
  * 返回程序计数器 (RPC) 包含跳转到子程序之后的指令地址。 
  * 起始程序计数器 (SPC) 包含当前硬件循环的第一条指令的地址。 
  * 结束程序计数器 (EPC) 包含当前硬件循环的最后一条指令的地址。 
* 其他核心寄存器是通用寄存器 (GREGn) 和标志。 
  * 通用寄存器可用于保存数据和地址。 它们可以加载立即值（例如，指令中编码的 8 位数据）、使用 ALU 执行的计算结果、来自存储器或通过数据存储器总线的外围设备的 32 位数据（ DMBUS），通过功能单元总线 (FUBUS) 或其他通用寄存器来自 DMA 的 32 位数据。 它们的内容可以是 ALU 的操作数、要在任一总线（DMBUS 或 FUBUS）上发送的数据，或指向内存的指针（DMBUS 地址）。 
  * 通用寄存器 0 (GREG0) 也是硬件循环计数器。 在硬件循环中，它不能用于任何其他目的。 该寄存器使用图 46-3 中所示的专用递减单元 (DECR)。 
  * flags 反映了操作的状态： 
    * 当任一总线（FUBUS 或 DMBUS）上的最后加载或存储接收到错误响应时，设置 SF 和 DF。 
    * 当内核在硬件循环内执行指令时设置 LM。 
    * 当 ALU 运算结果为 0 或循环计数器达到 0 时设置 T（后者在 ALU 运算是硬件循环的最后一条指令时占优势）。 
* ALU 有两个操作数：任何通用寄存器和第二个通用寄存器或立即值。 结果总是存储在第一个通用寄存器中。 NOP 函数可以通过将寄存器的内容移动到自身中来使用（例如，指令：mov R0,R0）。 
* 16 位指令通过指令总线 (IBUS) 获取，其地址由 PC 驱动。 SDMA RAM 和 ROM 通过该接口作为 16 位设备对内核可见。 
* 通过 DMBUS 访问内存（RAM 和 ROM）、内存映射寄存器和外围设备。 地址总是取自一个通用寄存器，其内容被添加到一个 5 位立即数上。 这是唯一可用的寻址模式。 DMBUS 是 32 位数据总线。 除 SDMA 外部的外设外，地址精度为 32 位字（例如，地址加 1 指向下一个字，而不是下一个字节）。 
* 通过 FUBUS 连接访问功能单元。 数据与任何通用寄存器交换，但地址（实际上是指令和功能单元的选择器）来自相应加载或存储的8位字段。 
##### 46.4.1.2 Program Control Unit (PCU)
&emsp;&emsp;SDMA 内核的这一部分专门用于控制 RISC 引擎，正如执行的指令所暗示的那样。它的行为由指令类型和 SDMA 的输入决定。
&emsp;&emsp;它包含 SDMA 核心结构中描述的 PC、RPC、SPC 和 EPC 寄存器。 
......
##### 46.4.1.3 SDMA Core Memory
&emsp;&emsp;SDMA 有两个存储空间：一个用于指令，一个用于数据。由于两个空间共享相同的资源（ROM 和 RAM 设备），当内核访问相同资源进行指令读取和数据读取或写入时，系统总线管理可能发生的冲突。
&emsp;&emsp;地址空间中进一步描述了程序和数据存储器。
&emsp;&emsp;16 位宽的指令存储在 32 位宽的设备中，可以作为数据访问。映射为 Big Endian：偶数指令地址（以 0 结尾）访问 32 位数据（位 [31:16]）的最高有效部分，奇数指令地址（以 1 结尾）访问最低有效部分的 32 位数据（位 [15:0]）。指令可以从内部 ROM 或 RAM 中取出。
&emsp;&emsp;可以从 ROM、RAM、内存映射寄存器和外围设备读取数据，并将数据写入相同的设备（ROM 除外）。
&emsp;&emsp;ROM 包含引导加载脚本、通道脚本和公共子例程，它们可能被 ROM 或 RAM 中其他地方的通道脚本引用。
&emsp;&emsp;RAM分为上下文区和代码空间区，可用于存储通道脚本。RAM 在硬件复位后包含未定义的值。使用为引导加载功能保留的通道 0 将通道脚本和初始上下文值下载到 RAM 中。 
#### 46.4.2 Scheduler
所有通道调度硬件都包含在调度程序中。 
##### 46.4.2.1 主要功能
&emsp;&emsp;调度器是一种基于硬件的设计，用于协调 SDMA 内核根据通道状态和优先级及时执行 32 个虚拟 DMA 通道。
&emsp;&emsp;调度程序执行以下功能： 
* 监视、检测和记录 48 个 DMA 请求中任何一个的发生 
* 将特定请求链接到通道或通道组（通道映射）
* 忽略未映射到先前配置的通道的请求 
* 维护请求服务的所有频道的列表 
* 为每个请求服务的通道分配一个预编程的优先级（7 个中的 1 个） 
* 检测并标记溢出/欠载情况 
##### 46.4.2.2 Channels and DMA Requests
###### 46.4.2.2.1 Channels
&emsp;&emsp;虚拟通道（以下简称为通道）管理通过 SDMA 的数据流。 流动通常是单向的。
&emsp;&emsp;SDMA 最多可以同时运行 32 个通道，编号从 0 到 31。通道 0 通常专用于控制 SDMA 脚本下载。 所有通道都可以通过 Arm 平台软件进行分配。 
###### 46.4.2.2.2 DMA Requests
&emsp;&emsp;DMA 请求是由外部（例如，SDMA 外部）控制条件（例如，UART 接收 FIFO 达到阈值）引起的。 SDMA 当前最多支持 48 个 DMA 请求。 
###### 46.4.2.2.3 Mapping from DMA Requests to Channels and Priorities
&emsp;&emsp;通道可能会停止等待单个 DMA 请求。 单个 DMA 请求可以唤醒多个通道（实际上，任何请求都可以唤醒任何通道组合）。
&emsp;&emsp;DMA 请求和通道之间的映射是由程序控制的。 为 48 个请求中的每一个分配了一个存储元素，其中包含由事件唤醒的通道的位图表。
&emsp;&emsp;每个通道还有一个三位寄存器，用于指示其优先级。 
##### 46.4.2.3 Scheduler 功能描述
&emsp;&emsp;调度器概述描述了 SDMA 调度器的行为——从通道启用条件到最高优先级的未决通道选择。 
###### 46.4.2.3.1 Scheduler Overview
&emsp;&emsp;调度程序算法内置于硬件中。 它为 Arm 平台提供了控制其行为的可能性。
&emsp;&emsp;调度程序处理传入的 DMA 请求，将检测到的请求映射到 0 个、一个或多个通道，维护请求服务的通道列表（待处理通道），识别最高优先级及其关联通道，并在当前通道结束时选择下一个活动的通道。
&emsp;&emsp;下图显示了功能概览。 

###### 46.4.2.3.2 DMA Requests Scanning
&emsp;&emsp;调度器包含一个 48 位边沿检测设备，它检测每个 DMA 请求的上升沿并将请求号传送到下一级。
&emsp;&emsp;假设 DMA 请求在与 SDMA 内核时钟相同的参考时钟上生成； 一旦信号从 1 到 n 周期的低状态变为 1 到 m 周期的高状态，它们就会被检测到。
&emsp;&emsp;该系统能够检测单周期脉冲以及基于电平的 DMA 请求，例如 FIFO 阈值交叉。 在这种情况下，SDMA 提供了一个内存映射寄存器，通道脚本可以使用该寄存器来监视 DMA 请求行，从而确定数据传输是否完成，然后继续传输或关闭通道。
&emsp;&emsp;当同时检测到多个 DMA 请求时，它们会以每个周期一个请求的速率转发到下一个调度程序阶段。 没有请求丢失。


&emsp;&emsp;DMA 请求输入连接到取决于 SoC 的各种源。 DMA 请求输入的确切列表及其相关编号可在每个项目特定的章节中找到。 
###### 46.4.2.3.3 Mapping DMA Requests to Pending Channels
&emsp;&emsp;每当第一阶段检测到 DMA 请求时，其编号将在第二阶段用于确定必须激活的通道。
&emsp;&emsp;这是通过 48 个 32 位宽的寄存器阵列执行的：有 48 个通道启用寄存器 (CHNENBLn)，<u>每个 DMA 请求</u>对应一个寄存器。 DMA 请求号选择 Channel Enable Registers，这个 32 位寄存器的每一位表示为 1 时必须激活相应的通道。 
&emsp;&emsp;该信息在 EP 寄存器上传递。 对于通道启用寄存器的每一位被置位，EP 寄存器的相应位也被置位，而 EP 的其余位保持不变。 EP 的变换由以下等式总结：
EP = EP 或 CHNENBLn
&emsp;&emsp;EP 寄存器用于了解哪些通道需要服务，因为它们收到了 DMA 请求。
&emsp;&emsp;CHNENBLn 寄存器的典型内容都是 0，除了单个位设置。 例如，一个 DMA 请求触发一个通道，但可能是全 0 或几个 1。 一个 DMA 请求可以激活多个通道，通道执行顺序可以由通道优先级和编号控制，如下一节所述。 下表说明了一个示例配置。 
&emsp;&emsp;注意：从表中可以看出，DMA 请求 0 被编程为同时触发通道 0、1 和 31。此外，此示例中未使用 DMA 请求 30-47。 其余通道 2 到 30 分别配置为由 DMA 请求 29 到 1 触发。 
###### 46.4.2.3.4 Channel Overflow
&emsp;&emsp;当 DMA 请求通过设置寄存器 EP 的位 n 来请求通道 n 的服务，但该位已设置（意味着通道 n 已挂起）时会发生通道溢出。 这可能来自溢出/欠载情况。
&emsp;&emsp;仅当 DMA 请求是脉冲时才可能进行这种检测，因为基于电平的 DMA 请求在得到服务之前保持高电平，即使发生欠载或溢出情况，从而防止再次检测 DMA 请求的边沿。
&emsp;&emsp;通道溢出信息保存在 32 位 CHNERR 寄存器中（每个通道 1 位）。 您可以配置 SDMA 以在 CHNERR 中有 1 时触发 Arm 平台的中断。 CHNERR 的每一位都被 INTRMASK 的相应位屏蔽，如果它给出 1，则 INTR 的相应位被设置，触发中断。 
###### 46.4.2.3.5 Runnable Channels Evaluation 可运行通道评估
&emsp;&emsp;EP 寄存器与其他几个 32 位寄存器一起使用，以确定可运行的通道。
&emsp;&emsp;寄存器 EO、DO、HO 和 HE 由 Arm 平台控制。 EP 由 DMA 请求及其到通道的映射控制。
&emsp;&emsp;在任何给定时间都可以运行多个通道。 当（且仅当）以下条件为真时，第 i 个通道是可运行的： 
(HE[i] or HO[i]) and (DO[i]) and (EP[i] or EO[i])
&emsp;&emsp;复位后，HE[i]、HO[i]、EP[i] 和 EO[i] 位全部清零，而 DO[i] 位全部设置。 与 DO 相关的功能不适用于此设备。 当 DO[i] 被设置，此时调度器条件变为： 
(HE[i] or HO[i]) and (EP[i] or EO[i])
&emsp;&emsp;此等式中的寄存器由下面的内容控制：
* Arm 平台（主机）通道启用标志 HE[i] 可以由 Arm 平台使用 HSTART 和 STOP_STAT 寄存器设置或清除。 也可以通过第 i 个通道脚本清除。
  典型用法是 Arm 平台设置此标志以激活通道。 当传输完成时，该标志由 SDMA 内核清除。 
* 当通道被 DMA 请求激活时，外部触发通道挂起标志 EP[i] 由调度程序设置。 可以通过第 i 个通道脚本清除。
* Arm 平台通道覆盖标志 HO[i] 可以由 Arm 平台设置或清除。 设置后，它可以让第 i 个通道在没有 Arm 平台参与的情况下运行。
  典型用法是 Arm 平台为不需要 Arm 平台监督的通道设置此标志，例如由 DMA 请求事件 (EP) 控制的通道。 
* DO 应始终设置为 1，以便可运行通道评估仅考虑 HO、HE、EP 和 EO。 
* Arm 平台可以设置或清除外部触发的通道覆盖标志 EO[i]。 设置后，它会防止第 i 个通道在传入外设 DMA 请求时停止和停止。 当通道不处理外设的数据传输（例如，内存到内存的传输）时，就会出现这种情况。 

&emsp;&emsp;SDMA 可以通过 done 或 notify 指令清除 HE[i] 和 EP[i] 位。 done 指令导致重新调度； 因此 done 指令会启用另一个通道来抢占当前通道，而 notify 指令不会。 done 和 notify 指令可以清除 HE[i] 或 EP[i]（一次不超过一个）。 

| 寄存器 | set by                                   | cleared by                                                   |
| ------ | ---------------------------------------- | ------------------------------------------------------------ |
| HO     | Write to HOSTOVR register                | Write to HOSTOVR register                                    |
| HE     | Write to HSTART register                 | Write to STOP_STAT register or by the channel script with the done or notify instructions. |
| DO     | Write to DSPOVR register                 | Write to DSPOVR register                                     |
| EO     | Write to EVTOVER register                | Write to EVTOVER register                                    |
| EP     | Set by external DMA request event input. | By the channel script with the done or notify instructions   |

###### 46.4.2.3.6 Next Channel Decision Tree
&emsp;&emsp;下一个通道号是根据可运行通道列表、当前通道号及其各自的优先级计算得出的。
&emsp;&emsp;它在每个周期重新评估，但仅在当前通道通过执行 yield、yielge 或 done 指令让出或终止时使用。
&emsp;&emsp;决策树基于选择具有最高优先级的可运行通道。
&emsp;&emsp;根据以下规则选择优先级最高的通道： 
* 可运行通道按优先级排序。
* 如果具有最高优先级的通道之一已被具有更高优先级的通道抢占，但不想让步给具有相同优先级的通道（例如，它执行了 yield，而不是 yieldge），则它被选为下一个通道。
* 属于最高优先级组的通道按其编号排序，该组中编号最高的通道成为下一个通道。 例如，如果优先级相同，则将先选择通道 31，然后再选择通道 30。 
  

&emsp;&emsp;当当前通道需要使用 yield(ge) 或 done 指令重新调度时，上下文切换决策基于指令参数、当前通道号和优先级以及下一个通道号和优先级。 可能的情况都列在下表中。 灰色单元格对应于在 SDMA 的典型使用中不应发生的异常情况。 


&emsp;&emsp;最后，当 SDMA 处于 IDLE 模式并且一个可运行的通道被选为下一个通道时，它的上下文立即恢复并且脚本执行恢复。 
&emsp;&emsp;组合决策树支持 EP、EO、HE、HO 和 DO 标志的动态修改以及通道优先级的动态修改。 Scheduler Pipeline Timing Diagram 详细介绍了传播时间。 
&emsp;&emsp;决策树状态在不断更新的 PSW 寄存器中可用。 它包含下一个通道优先级、下一个通道号、当前通道优先级和当前通道号。 当优先级读为 0 时，表示通道不可运行。 
&emsp;&emsp;下面给出了一些决策示例： 
* 通道 31 以优先级 5 运行，通道 13 和 24 以相同的优先级 5 挂起； 从 24 > 13 开始，通道 24 有资格作为下一个通道。 
* 通道 31 以优先级 7 运行，通道 13 和 24 以优先级 5 挂起； 通道 31 是下一个通道，因为它的优先级高于其他待处理的通道。 
* 通道 7、23 和 29 以相同的优先级挂起。 通道 7 处于活动状态并运行 yieldge； 它被通道 29 抢占。一段时间后，通道 29 运行一个让步，然后被选择的通道 23 抢占，因为通道 29 是当前通道。 稍后，通道 23 运行一个 yieldge 并被通道 29 抢占。通道 23 和 29 将在每个 yieldge 之后继续切换，直到其中一个终止。 只有在那个时候，通道 7 才再次符合条件。 
* 通道 11 以优先级 3 运行，通道 15 以优先级 4 挂起。当通道 31 脚本执行 yield 指令时，它被通道 15 抢占； 然后优先级为 3 的通道 6 和 18 变为待处理。 因为通道 11 在执行 yield 后被抢占，并且没有具有严格更高优先级的挂起通道，所以它有资格作为下一个通道（尽管它的编号 11 < 18）。 

###### 46.4.2.3.7 Scheduler State Diagram
&emsp;&emsp;图 46-7 总结了 SDMA 调度器的行为，详细介绍了优先级决策树的确切机制。 重要的是要了解调度器是硬连线管道，这意味着每个周期同时执行所有阶段，但是任何给定阶段的更改都会在调度器流水线时序图中显示的延迟后反映在下一个阶段。 
###### 46.4.2.3.8 调度器流水线时序图 
&emsp;&emsp;DMA 请求和控制寄存器修改的 SDMA 调度程序过程不是立即的。
&emsp;&emsp;下图显示了所有任务的确切延迟。 参考时钟是 SDMA 内核时钟。 


&emsp;&emsp;从这个时序图中可以推断出两个数字。 首先，从 DMA 请求更新下一个通道需要六个 SDMA 内核时钟周期。 其次，任何处理器直接修改条件寄存器（EP、DO、HE 或 HO）都需要三个 SDMA 内核时钟周期来更新下一个通道。 可以修改这些位的处理器包括具有完成指令的 SDMA 或具有通过其各自外围总线上的相应控制端口进行写访问的 Arm 平台。 

###### 46.4.2.3.9 通道-DMA 请求映射
&emsp;&emsp;SDMA 调度程序的 48 个 DMA 请求输入列在 project-specific 的章节中。 有关此信息，请参阅相应章节。
###### 46.4.2.3.10 示例：如何启动一个通道 
&emsp;&emsp;当以下等式对通道 i 成立时，可以启动通道： 
(HE[i] or HO[i]) and (DO[i]) and (EP[i] or EO[i])  
&emsp;&emsp;一旦这个等式成立，调度器就可以根据所有未决通道的优先级启动这个通道。 下面列出了几个配置示例： 
1. 要启动由 Arm 平台软件触发的通道： 
   1. 首先，使用表 46-5 中指示的寄存器配置 HO[i]=0、DO[i]=1 和 EO[i]=1。
   2. Arm 平台软件通过写入 HSTART 寄存器设置 HE[i]=1 来触发通道，从而将上述等式设置为真。 
2. 启动由 DMA 请求事件触发的通道。 
   1. 首先，使用表 46-5 中指示的寄存器配置 HO[i]=1、DO[i]=1 和 EO[i]=0。
   2. DMA 请求通过设置EP[i]=1 来触发通道，这使得上述等式成立。 

##### 46.4.2.4 Context Switching
&emsp;&emsp;在执行 done 或 yield(ge) 指令时，当前通道可能会改变，或者因为它已经完成（这必然发生在执行 done 指令时），或者它被更高优先级的通道抢占（这是可能的但不是执行 yield(ge) 时的系统性）。
&emsp;&emsp;在通道改变时，SDMA 会经历一个上下文切换过程。
&emsp;&emsp;当当前通道让步或结束时，该通道的上下文将保存到该通道的上下文 RAM 位置。当下一个通道开始运行时，它的上下文首先从 RAM 中恢复。
&emsp;&emsp;由于上下文 RAM 尚未通过复位初始化，因此在复位后运行的第一个通道（引导加载通道）开始时不会进行上下文恢复。预计引导加载通道将用于初始化所有其他通道的上下文。当引导加载通道完成运行或退出时，SDMA 将进入其 SAVE 状态并将该通道的上下文保存到 RAM 中。然后，如果稍后再次调用引导加载通道，则当通道再次启动时，上下文将从 RAM 中恢复。 
&emsp;&emsp;每个通道的上下文结构在上下文切换编程和表 46-11 中定义。 将为每个通道保留一个上下文区域。 当通道结束或退出时，SDMA 内核寄存器会自动保存到上下文 RAM 中，然后在下一次运行通道时从上下文 RAM 中恢复。 为 32 通道上下文保留的总 RAM 空间为 3K 或 4K，具体取决于是否在 CHN0ADDR 寄存器中设置了 SMSZ 位，这为每个上下文启用了额外的 8 个字的暂存 RAM。 
###### 46.4.2.4.1 Context Switch Modes
&emsp;&emsp;保存旧通道上下文和恢复新通道上下文的确切过程取决于 Arm 平台在 CONFIG 控制寄存器中选择的上下文切换模式。
&emsp;&emsp;以下是上下文切换模式： 
* 默认情况下，设置了“动态”上下文切换。此模式在平均八个周期内提供最有效的上下文切换，以停止当前通道、保存其上下文、恢复下一个通道上下文并恢复其执行。它包括在后台保存当前通道的修改寄存器（例如，在通道执行期间）——当决定切换时，只剩下很少的寄存器可以保存——尽快恢复下一个通道的执行（例如，当最小的寄存器集被恢复时），并在此执行期间继续恢复阶段。
* 在“动态无循环”模式下，遵循相同的原则，只是修改的寄存器仅在未设置循环标志时保存在后台。此模式提供与前一种模式几乎相同的效果，但它会阻止系统在循环期间访问 RAM 以节省电力。当循环体很短时，这是一种高效上下文切换的推荐模式。
* 在“动态功耗”模式下，不执行后台保存，从而将功耗降至最低。修改后的寄存器仅在上下文切换开始时保存。恢复阶段与之前相同。这是以较慢的上下文切换为代价实现最佳功耗的模式。
* 在“静态”上下文切换中，当决定进行上下文切换时保存所有寄存器，并在开始执行新通道之前恢复所有寄存器。此模式启用上下文切换的可预测行为，因为所有寄存器都在通道启动之前恢复，并且所有寄存器在通道终止之后保存。 

&emsp;&emsp;注意：静态上下文模式应用于复位后调用的第一个通道，以确保该通道的所有上下文 RAM 在通道完成或退出时的上下文 SAVE 阶段初始化。 对同一通道或不同通道的后续调用可以使用任何动态上下文模式。 这将确保引导加载通道的所有上下文位置都已初始化，并防止在稍后重新启动通道时在上下文恢复期间加载上下文 RAM 中的未定义值。 

###### 46.4.2.4.2 Context Switch Procedure
&emsp;&emsp;程序控制单元进入保存状态，当前上下文溢出到内存中，根据 Arm 平台选择的上下文切换模式恢复下一个通道上下文。 
&emsp;&emsp;上下文切换过程如下：
1. 加载当前上下文的溢出基地址。
2. 通道运行时，根据选择的上下文切换模式将当前通道的修改寄存器溢出到内存中。
在导致通道抢占的 done 或 yield(ge) 时，PCU 进入保存状态。静态模式下，保存所有寄存器；而在任一动态模式下，都会保存已修改但尚未保存的寄存器，最后保存 PCU 寄存器和标志。
3. 使 SDMA 内核进入睡眠状态并等待新通道的服务。如果在保存当前通道时有待处理的通道，则跳过此步骤。
只要有至少一个未决通道，PCU 就会进入其恢复状态以恢复调度程序选择的通道的上下文。
一旦选择了一个通道，它就会保持当前通道，直到其脚本使用 done 或 yield(ge) 指令请求重新调度操作。这意味着 Arm 平台无法修改当前通道，即使它不再可运行或者其优先级已被修改。
但是，**Arm 平台可以通过在 CONFIG 寄存器中写入相应的位来强制重新调度**，这与脚本执行完成指令的效果相同。该功能应仅用于在紧急情况下停止 SDMA。
4. 加载新通道的上下文基地址。在“静态”模式下，所有寄存器都被恢复。在任一“动态”模式下，仅恢复 PCU 寄存器。
新频道正在运行。在“静态”模式下，不再执行有关上下文恢复或保存的活动。在任一“动态”模式下，每次可以访问上下文 RAM 时，都会在后台恢复寄存器，并优先恢复下一条要执行的指令所需的寄存器。当一个寄存器尚未恢复并且下一条指令需要它时，该指令将停止，直到寄存器恢复。 
在“动态”和“无循环动态”模式下，每次可以访问上下文 RAM 并且上下文切换模式允许访问时，都会执行脏寄存器的后台保存。 
&emsp;&emsp;注意：上下文 RAM 中的通道上下文空间的内容取决于所选的上下文切换模式。 在“动态”和“无循环动态”模式下，上下文 RAM 的内容往往与 SDMA 寄存器的内容相匹配（除了从未在后台保存的 PCU 寄存器和标志）。 在“动态功率”和“静态”模式下，上下文 RAM 的内容保持不变，直到通道以完成或被抢占而终止。 

###### 46.4.2.4.3 内存中的上下文映射 
&emsp;&emsp;参见 Context Switching-Programming.

#### 46.4.3 Functional Units
&emsp;&emsp;功能单元是 SDMA 内核用来处理内核与 SDMA 外部总线域之间的数据传输的小型系统。
&emsp;&emsp;SDMA 内核能够通过 FUBUS 向功能单元的寄存器发送指令和读取或写入数据，从而控制这些系统并与这些系统交换数据。 这是通过 ldf 和 stf 指令完成的。
&emsp;&emsp;以下部分介绍了可用的功能单元。 功能单元编程模型提供了功能单元行为的描述。 
##### 46.4.3.1 Burst DMA Unit
&emsp;&emsp;Burst DMA 单元使 SDMA 内核能够执行与 Arm 平台内存之间的数据传输。
&emsp;&emsp;它针对访问类似 SDRAM 的设备进行了优化。 它不提供为 DMA 访问分配特权级别的控制。 突发 DMA 单元为 SDMA 提供了执行以下操作的方法： 
* 对 Arm 平台内存执行高达 8 拍的读写突发，这在访问 SDRAM 类型设备时优化了吞吐量，因为有一个内部的 36 字节 FIFO
* 以 SDMA 核心频率的一倍或两倍访问 Arm 平台内存
* 以 Arm 平台总线速度将数据从一个 Arm 平台内存位置复制到另一个 Arm 平台内存位置，从而提供非常高的吞吐量
* 控制 Arm 平台内存的寻址方式（地址自动递增或冻结地址——前者旨在访问类似RAM的内存，后者旨在访问单地址FIFO）
* 从 Arm 平台内存读取数据时启用或禁用自动预取。选择预取模式时，突发 DMA 自动触发外部突发填充其 FIFO，无需等待 SDMA 内核请求相应数据，大大提高了吞吐量。
* 当有足够的数据生成 8 拍突发到 Arm 平台内存时，依靠 DMA 自动刷新其 FIFO 内容。或者，当数据传输必须终止时，它会强制刷新。
* 在前一种情况下，SDMA 内核可能仅在尝试写入数据且 FIFO 中没有足够空间时才会停止。在后一种情况下，内核会停止，直到数据有效地写入 Arm 平台内存。
在自动刷新模式下，当数据有效写入 Arm 平台内存时，内核会收到不反映实际错误状态的确认。通过稍后访问突发 DMA 来检索此错误状态。使用强制刷新命令终止写入数据传输可确保捕获到 Arm 平台内存的任何总线错误。
* 处理Arm 平台内存映射和SDMA 内核数据之间的地址对齐问题。这使内核能够从突发 DMA 读取或写入 32 位数据，而相应的 Arm 平台地址不是 32 位对齐的。这极大地提高了 SDMA 脚本的效率，因为可以使用一次传输 32 位的相同循环，而不管 Arm 平台内存空间中的开始和结束地址如何。 

&emsp;&emsp;此单元结构和寄存器在 Burst DMA Structure 和 Burst DMA
Registers 中进行了描述。 

###### 46.4.3.1.1 Burst DMA Structure
&emsp;&emsp;突发 DMA 本质上由一个 36 字节的 FIFO、地址寄存器和一个控制状态机组成。 36 字节的 FIFO 支持地址对齐的 8-word 缓冲，状态机在需要时管理时钟适配。
&emsp;&emsp;突发 DMA 如下图所示。

###### 46.4.3.1.2 Burst DMA Registers
&emsp;&emsp;有四个寄存器可以从 SDMA 内核访问，如下所示： 
* MSA（内存源地址）——在 Arm 平台内存映射中保存源字节地址，用于从该位置读取数据。每次内核从 FIFO 读取新数据时，都会自动修改该寄存器。
* MDA（内存目标地址）——在 Arm 平台内存映射中保存目标字节地址，用于将数据写入该位置。每次内核将新数据写入 FIFO 时，都会自动修改该寄存器。
* MD（内存数据）- 标记 36 字节 FIFO 访问点：从 MD 读取字节、半字或字分别检索 FIFO 的前 1、2 或 4 个字节（例如，首先存储的字节从 Arm 平台内存传输数据时由 DMA 状态机执行）。
* 当 FIFO 不能容纳 SDMA 内核所需的字节数时，内核会停止，直到从 Arm 平台存储器中读取丢失的字节。在预取模式的情况下，DMA 控制器决定何时开始突发到 Arm 平台内存，以降低未来访问内核所需数据的风险。当没有预取时，当所需数据在 FIFO 中不可用时触发突发。
将一个字节、半字或字写入 MD 分别在 FIFO 的末尾存储 1、2 或 4 个字节（例如，这些字节在之前存储在 先进先出）。 当 FIFO 没有足够的空间来保存写入的数据时，SDMA 内核会停止，直到有足够数量的 FIFO 内容被刷新到 Arm 平台内存中。 当 FIFO 中有足够的字节对 Arm 平台内存执行最大允许突发时，刷新由 DMA 控制器决定（确切大小取决于突发起始地址和 AHB 1 KB 边界规则）。 但是，SDMA 内核能够在任何时候强制刷新操作，例如，在数据传输结束时，在通道关闭之前。 
* MS (Memory Setup) - 包含突发 DMA 控制的状态，定义每个地址寄存器是否在每次访问外部存储器后递增的两个标志，以及在发生总线错误时设置的另一个标志。 

###### 46.4.3.1.3 Burst DMA Data Transfers
&emsp;&emsp;已经确定了涉及突发 DMA 的三种典型用法：数据传输起点、终点或两者兼而有之。
&emsp;&emsp;每种情况都需要不同的程序，如以下部分所列：

1. 46.4.3.1.3.1 从 Arm 平台内存中检索数据 
&emsp;&emsp;以下步骤使用突发 DMA 单元从 Arm 平台内存中检索数据： 
* 设置 MS 标志以反映源地址的模式（根据访问设备的类型递增或冻结：内存或外设 FIFO），然后初始化源地址寄存器本身（MSA）。
* 根据需要多次使用 ldf MD 指令从FIFO 中读取数据。 如果在从 Arm 平台存储器读取期间发生错误，则 DMA 控制标记数据上的错误状态，并在从 FIFO 读取该数据时设置 SDMA 内核 SF 标志。 

2. 46.4.3.1.3.2 将数据存储到 Arm 平台内存中 
&emsp;&emsp;以下步骤使用突发 DMA 单元从 Arm 平台内存中存储数据： 
* 设置 MS 标志以反映目标地址的模式（根据访问设备的类型递增或冻结：内存或外设 FIFO），然后初始化目标地址寄存器本身 (MDA)。
* 根据需要多次使用 stf MD 指令将数据存储到FIFO。
* 传输完成后，如果 DMA 在自动刷新模式下工作，则强制刷新 FIFO。 该指令会停止，直到所有 FIFO 数据有效发送到 Arm 平台内存并且传输的错误状态在 DF 标志中可用。 

3. 46.4.3.1.3.3 在两个 Arm 平台内存位置之间传输数据突发 DMA 单元 
&emsp;&emsp;以下步骤使用突发 DMA 单元在两个 Arm 平台内存位置之间复制数据：
* 设置 MS 标志以反映源地址和目标地址的模式（所有组合都是可能的），然后初始化源地址寄存器 (MSA) 和目标地址寄存器 (MDA)。 两个地址都必须是字对齐的。
* 根据需要使用尽可能多的带有COPY 标志的stf MD 指令。 每条指令都会触发从源地址中对给定数量的字进行突发读取（该数量通过 SDMA 内核通用寄存器提供给突发 DMA，该寄存器在 stf 指令中引用）。 将所有数据加载到 FIFO 后，DMA 会使用相同计数的写入突发将其清空到目标地址。 DMA 在指令完成之前进行确认，这可以释放 SDMA 内核以执行其他任务，而不会产生延迟成本。
* 传输完成后，应最终访问突发 DMA 以检查错误状态。 

##### 46.4.3.2 Peripheral DMA Unit
&emsp;&emsp;外设 DMA 单元是将 SDMA 连接到 Arm 平台内存的第二个功能单元。
&emsp;&emsp;与突发 DMA 不同，它不支持突发传输，并且针对访问外设进行了优化。 它不提供为 DMA 访问分配特权级别的控制。 其功能列表包括以下内容： 
* 以 SDMA 核心频率的一倍或两倍访问 Arm 平台外设或内存
* 以内存总线速度将数据从一个 Arm 平台内存位置复制到另一个 Arm 平台内存位置，从而提高吞吐量
* 控制 Arm 平台内存的寻址方法（地址或冻结地址的自动递增或递减，第一个旨在访问类似 RAM 的内存，最后一个旨在访问单地址 FIFO）
* 从 Arm 平台内存读取数据时可选择自动预取。在预取模式下，外设 DMA 会在其数据寄存器为空时自动获取另一个数据，而无需等待 SDMA 内核请求它，从而提高吞吐量
* 可选择的自动冲洗。在此模式下，SDMA 内核可能仅在尝试写入数据且之前的写入操作尚未完成时才会停止；而在强制刷新模式下，内核会停止，直到数据有效地写入 Arm 平台内存。
* 在自动刷新模式下，当数据有效写入Arm 平台存储器或外设时，内核会收到不反映实际错误状态的确认。通过稍后访问外设 DMA 来检索此错误状态。使用强制刷新命令终止写入数据传输可确保捕获到 Arm 平台内存的任何总线错误。

&emsp;&emsp;外设 DMA 结构和外设 DMA 寄存器中描述了该单元结构和寄存器。 

###### 46.4.3.2.1 外设 DMA 结构 
&emsp;&emsp;外设 DMA 由一个 32 位数据寄存器、两个地址寄存器和一个控制状态机组成。 状态机在需要时管理时钟适配。
&emsp;&emsp;如下图所示。 

###### 46.4.3.2.2 外设 DMA 寄存器 
&emsp;&emsp;根据图 46-10，外设 DMA 有四个寄存器可以由 SDMA 内核读取或写入：
* PD（外设数据）是 DMA 32 位数据寄存器。
* PSA（外设源地址）在 Arm 平台内存映射中保存源字节地址，用于从该位置读取数据。 每次内核从 PD 读取新数据时，都会自动修改该寄存器。 
* PDA（外设目标地址）在 Arm 平台内存映射中保存目标字节地址，用于将数据写入该位置。 每次内核向 PD 写入新数据时，都会自动修改该寄存器。
* PS (Peripheral Setup) 包含外设 DMA 控制的状态、定义每次数据访问后修改地址寄存器方式的两个配置字段、定义访问源和目标设备的数据大小的两个附加配置字段，以及另一个 包含最新传输错误状态的字段。

###### 46.4.3.2.3 外设 DMA 数据传输
&emsp;&emsp;涉及外设 DMA 的典型用途有三种，无论是数据传输起点、终点还是两者兼而有之。 
&emsp;&emsp;Every case requires a different procedure, as described in Data Retrieval from the Arm platform Memory or Peripheral, Storing Data into the Arm platform Memory or Peripheral, and Transferring Data Between Two Arm platform Memory LocationsPeripheral DMA Unit.

1. 46.4.3.2.3.1 从 Arm 平台内存或外设检索数据 
&emsp;&emsp;以下步骤使用外设 DMA 单元从 Arm 平台内存中检索数据： 
* 设置 PS 字段以反映源的模式和数据大小（递增、递减或冻结地址寄存器；8 位、16 位或 32 位数据传输），然后初始化源地址寄存器本身（ PSA），其地址与编程数据大小对齐。
* 根据需要多次使用ldf PD 指令从PD 读取数据。 如果在从 Arm 平台存储器或外设读取期间发生错误，则 DMA 控制标记数据上的错误状态，并且在从 PD 读取此数据时设置 SDMA 内核 SF 标志。

2. 46.4.3.2.3.2 将数据存储到 Arm 平台内存或外设 
&emsp;&emsp;以下步骤使用外设 DMA 单元将数据存储到 Arm 平台内存： 
* 设置 PS 字段以反映目标的模式和数据大小（递增、递减或冻结地址寄存器；8 位、16 位或 32 位数据传输），然后初始化目标地址寄存器本身（ PDA），其地址与编程数据大小对齐。
* 根据需要多次使用stf PD 指令将数据存储到PD 中。
* 当传输完成并且外设DMA 工作在自动刷新模式时，强制刷新PD。 在 PD 内容有效发送到 Arm 平台存储器或外设之前，该指令会停止，并且传输的错误状态在 DF 标志中可用。 

3. 46.4.3.2.3.3 在两个 Arm 平台内存位置之间传输数据外设 DMA 单元 
&emsp;&emsp;以下步骤使用外设 DMA 单元在两个 Arm 平台内存位置之间复制数据：
* 设置 PS 字段以反映源地址和目标地址的模式和数据大小（寻址模式的所有组合都是可能的，但两种数据大小必须相同），然后初始化源地址寄存器 (PSA) 和目标地址 地址寄存器（PDA）。 两个地址都必须与编程的数据大小对齐。
* 根据需要使用尽可能多的带有COPY 标志的stf PD 指令。 每条指令都会触发一次从源地址读取； 紧随其后的是接收到的数据的单次写入。 DMA 在指令完成之前进行确认，这可以释放 SDMA 内核以执行其他任务，而不会产生延迟成本。
* 传输完成后，应最终访问外设 DMA 以检查错误状态。

#### 46.4.4 SDMA 安全支持 
&emsp;&emsp;SDMA 为 SDMA 软件提供支持，以阻止对 RAM 中的脚本进行未经授权的更新。
&emsp;&emsp;SDMA 支持以下安全模式：
* 开放模式：完全控制将脚本和上下文加载到 SDMA RAM。 这是默认模式。
* 锁定模式：Arm 平台在启动时加载脚本和通道上下文，此时它仍在执行已知的安全软件。 完成后，它会锁定 SDMA 以防止进一步更新 RAM 和选定的寄存器。Locked Mode 中描述的更多细节。 
##### 46.4.4.1 Locked Mode
&emsp;&emsp;SDMA_LOCK 寄存器中的 LOCK 位支持 SDMA 脚本在初始引导加载例程之后冻结 RAM 内容，以防止将来对 SDMA RAM 进行未经授权的更新。
&emsp;&emsp;上传初始 RAM 内容后，Arm 平台软件可以设置 LOCK 位以保护 RAM 内容，以防止未来被未经授权的更新。向 LOCK 位写入 1 后，SDMA 将“锁定”直到复位。
&emsp;&emsp;LOCK 位可以在 SDMA 的内部存储器映射中的 LOCK 寄存器中读取（参见 SDMA LOCK (SDMAARM_SDMA_LOCK) 部分）。将信息加载到 RAM 的 SDMA 脚本可以检查 LOCK 位的值以确定是否允许上传到 RAM。如果不允许，脚本可以拒绝允许将数据复制到 RAM 中的请求继续进行。 SDMA 软件文档中将描述 SDMA 脚本中 LOCK 位用于安全控制的确切用途（请参阅 SDMA 脚本）。
&emsp;&emsp;当 SDMA 被锁定时，写入 SDMA_LOCK、CHN0ADR、ILLINSTADDR 和 ONCE_ENB 寄存器的尝试将被忽略。所有寄存器保持可读。仍然允许写入其他寄存器。
&emsp;&emsp;一旦 SDMA 被锁定，LOCK 位只能通过复位清除。硬件复位将始终清除 LOCK 位。仅当 SDMA_LOCK 寄存器中的 SRESET_LOCK_CLR 位置位时，通过写入 RESET 寄存器启动的软件复位才会清除 LOCK 位。由于 SDMA_LOCK 寄存器在 SDMA 被锁定时无法更新，因此必须在设置 LOCK 位之前配置 SRESET_LOCK_CLR 位。
SREST_LOCK_CLR 位也将被清除 LOCK 位的复位清除。
&emsp;&emsp;SDMA RISC 内核使用 ILLINST 和 CHN0ADDR 寄存器作为指针来确定在非法指令后或复位后引导时跳转到哪里。 LOCK 位防止对这些寄存器进行更新，以防止对这些指针进行未经授权的更改。
&emsp;&emsp;当 SDMA 被锁定时，不能写入 ONCE_ENB 寄存器以防止 Arm 平台控制下的 OnCE 被用于访问 SDMA 内部存储器。如果在设置 LOCK 位之前启用了对 OnCE 的 Arm 平台控制，则在设置 LOCK 后，Arm 平台可以使用 ONCE 进行调试。 

......

#### 46.4.7 Software Interface
&emsp;&emsp;附录 A 全面描述了 SDMA 应用程序编程接口 (API)。 

#### 46.4.8 初始化信息 
本节讨论以下内容： 
* 硬件复位
* 通道脚本执行
* 初始化和 脚本执行设置序列

##### 46.4.8.1 硬件复位
&emsp;&emsp;复位后，程序 RAM、上下文 RAM、数据 RAM 和包含通道使能寄存器 (CHNENBLn) 的 RAM 具有不可预测的内容。
&emsp;&emsp;活动寄存器组分配给通道 0，PC 初始化为全零。 但是，由于通道使能寄存器全为零，因此没有活动通道，并且 SDMA 停止，等待引导通道启动。
&emsp;&emsp;Arm 平台必须设置 SDMA 才能启动它。 必须初始化 CONFIG 寄存器以确定 DMA/内核时钟比率（1 或 2）。 Channel Enable Registers 也必须初始化。 
&emsp;&emsp;为了启动 SDMA，Arm 平台首先在 Arm 平台内存中为引导通道（通道 0）创建一些通道控制块（CCB）和缓冲区描述符（BD），然后将通道 0 指针寄存器（SDMA_MC0PTR）初始化为第一个控制块的地址。 Data Structures for Boot Code and Channel Scripts 概述了 CCB 和 BD 的数据结构。然后根据可运行通道评估配置 SDMA_HSTART、SDMA_HOSTOVR 和 SDMA_EVTOVR 寄存器以允许通道 0 运行。
&emsp;&emsp;启用后，SDMA 开始执行位于程序存储器中通道 0 引导地址寄存器 (SDMA_CHN0ADDR) 指示的地址的脚本。 SDMA_CHN0ADDR 的复位值指向 ROM 中的默认引导加载脚本。此 ROM 脚本将读取通道 0 指针寄存器 (SDMA_MC0PTR) 以确定通道控制块 (SDMA_CCB) 在 Arm 平台内存中的位置。然后脚本将开始通过 DMA 获取第一个通道控制块，其中包含指向位置通道 0 缓冲区描述符链的指针，该指针也通过 DMA 获取。如果缓冲区描述符包含有效命令，则脚本解释每个缓冲区描述符中的命令并继续执行命令并继续执行下一个缓冲区描述符控制块。通道零的缓冲区描述符命令通常设置为加载 SDMA 的程序 RAM、数据 ​​RAM 和通道上下文的初始值。一些通道脚本期望传递特定的参数。
&emsp;&emsp;有两种方法可以在用户定义的脚本上启动 SDMA。 OnCE（通过其 JTAG 接口或 Arm 平台控制接口）可用于下载 SDMA RAM 中的任何代码并强制 SDMA 在该代码上启动。 此外，可以修改 Arm 平台编程模型中的 SDMA_CHN0ADDR 寄存器以指向 RAM 中的用户代码，这些代码需要通过 ONCE 或默认引导加载例程（例如在软件复位之前）加载。 
##### 46.4.8.2 Channel Script Execution
&emsp;&emsp;SDMA 脚本的执行取决于构成该脚本的指令、其操作所依据的数据上下文以及允许进入缓冲区的命令或参数。在允许执行脚本之前，必须初始化所有这些项目。
&emsp;&emsp;32 个通道中的每一个都有一个单独的上下文，但可以共享数据 RAM 中的脚本和位置。
&emsp;&emsp;通道由 Arm 平台初始化，方法是使用通道 0 下载任何所需的脚本和数据值以及通道初始上下文。上下文包含 SDMA 内核寄存器的所有初始值。这包括程序计数器 (PC)，它设置为 SDMA 程序存储器中所需脚本的开头。
&emsp;&emsp;Arm 平台通过配置 SDMA_CHNENBL、SDMA_HOSTOVR 和 SDMA_EVTOVR 寄存器来选择通道启动必须发生的触发条件。触发事件包括 Arm 平台设置 HE (SDMA_HSTART) 或硬件 DMA 请求将事件输入置为 SDMA。当所选触发器导致可运行信道中描述的条件评估为真实时，该信道可以根据其优先级与其他可运行的通道相比变得有效。
&emsp;&emsp;要传递给缓冲区描述符或上下文中每个脚本的特定参数记录在每个脚本的软件文档中。请参阅 SDMA 脚本以获取完整的脚本文档。缓冲区描述符格式提供了缓冲区描述符格式的概述。 
##### 46.4.8.3 初始化和脚本执行设置顺序
&emsp;&emsp;总之，设置SDMA和运行通道脚本至少需要以下步骤。
* 执行硬件重置。 复位后，程序 RAM、上下文 RAM、数据 RAM 和 SDMA_CHNENBLn 寄存器具有不可预测的内容。 
* 初始化 SDMA_CHNENBLn 寄存器以将 DMA 请求事件映射到所需通道。
* 配置 SDMA_CHNPRIn 寄存器以选择可运行通道的优先级。 通道运行需要非零优先级。 
* 配置 SDMA_CONFIG 寄存器以选择 DMA 与 SDMA 内核时钟比率。
* 在 Arm 平台中设置通道控制块和缓冲区描述符，以指定要使用的每个 SDMA 通道的 SDMA 程序 RAM 和通道上下文的加载。参考引导代码和通道脚本的数据结构。
* 将SDMA_MC0PTR 寄存器配置为Arm 平台通道控制块基地址的基地址。
* 初始化SDMA_CHNENBLn 寄存器以将DMA 请求事件映射到相关通道。参考将 DMA 请求映射到挂起的通道。
* 配置SDMA_CHNPRIn 寄存器以设置每个要运行的通道的优先级。
* 对于要运行的每个通道，配置 SDMA_HOSTOVR (HO) 和 SDMA_EVTOVR (EO) 寄存器以选择必须发生哪些事件（硬件和/或软件触发事件）才能使通道可运行。参考可运行通道评估。
* 设置 SDMA_HSTART 寄存器的位 0 以设置 HE[0] 并允许通道 0 运行（假设 EO[0] 和 DO[0] 均在上一步中设置）。这将导致 SDMA 加载先前配置的程序 RAM 和通道上下文。
* 等待通道0 完成运行。这由 SDMA_SDMA_INTR 寄存器中的 HI[0]=1 或 Arm 平台的可选中断指示。
* 设置 SDMA_SDMA_LOCK 寄存器中的 LOCK 位以防止未经授权将数据上传到 SDMA RAM。
* 现在可以通过根据可运行通道评估启用选定的软件或硬件触发事件来运行其他通道脚本。 

#### 46.4.9 SDMA Programming Model
&emsp;&emsp;本节介绍 SDMA RISC 引擎的编程模型，包括其处理器、内存和内部控制寄存器。
&emsp;&emsp;所有地址都与内部 SDMA 内存映射相关，这与 Arm 平台的内存映射完全不同。 Arm 平台处理器无法访问所描述的任何硬件资源，除非这些资源在 Arm 平台内存映射和控制寄存器摘要中有所描述。
##### 46.4.9.1 State and Registers Per Channel
&emsp;&emsp;SDMA 可以看作是一组 32 个相同的设备，每个设备能够执行一个数据传输通道。 一次只能工作一个通道，但每个通道状态随时可用。
&emsp;&emsp;本章列出了每个通道状态的组成部分。 
##### 46.4.9.2 General Purpose Registers
&emsp;&emsp;每个通道有 8 个 32 位的通用寄存器供脚本使用。 通用寄存器 0 具有循环指令的专用功能，但可用于任何目的。 
##### 46.4.9.3 Functional Unit State
&emsp;&emsp;每个通道上下文都有一些状态，它是功能单元的一部分。
&emsp;&emsp;该状态的具体分配是 Burst DMA Unit Programming, Peripheral DMA Unit Programming 中描述的功能单元定义的一部分。
&emsp;&emsp;此状态必须在上下文切换时保存/恢复。 
###### 46.4.9.3.1 Program Counter Register (PC)
&emsp;&emsp;PC是14位的。 由于指令宽度为 16 位，而 SDMA 中的所有存储器宽度均为 32 位，因此 PC 的低位选择 32 位字的哪一半包含当前指令。
&emsp;&emsp;零的低位选择字的最高有效半部分。 

................................

##### 46.4.9.4 Context Switching-Programming
&emsp;&emsp;每个通道都有一个单独的上下文，由八个通用寄存器和表示功能单元状态的附加寄存器组成。
&emsp;&emsp;活动寄存器和功能单元包含活动通道的上下文。非活动通道的上下文存储在 SDMA RAM 中，它是 SDMA 地址空间的一部分。
&emsp;&emsp;在所选择的上下文切换模式（Context Switching）的功能中，程序修改的寄存器可以在程序运行时保存在通道RAM空间中。在每个周期中，都可以对 RAM 进行写访问。
&emsp;&emsp;在 done 或 yield(ge) 指令上，SDMA 进入“真正的”上下文切换。在其中一种动态模式中，先前未保存的修改寄存器以及 PC-Loop 寄存器存储到将要关闭的通道的上下文区域中。新的 PCLoop 寄存器从新通道的上下文区域加载。所有其他寄存器在程序执行时被恢复，优先考虑被解码指令使用的寄存器。因此，在最好的情况下，在这个上下文切换阶段只需要保存和恢复 PC 和循环寄存器，只需要五个 SDMA 周期。
&emsp;&emsp;在静态模式下，上下文切换将所有寄存器存储在旧通道 RAM 空间中，并从新通道 RAM 空间中恢复所有寄存器。它需要 26 个 SDMA 周期。
&emsp;&emsp;通道 i 的上下文存储器的地址是 CONTEXT_BASE + 24*i 或 CONTEXT_BASE + 32*i，其中 CONTEXT_BASE 等于 0x0800。下表展示了内存中通道上下文的布局： 

| offset | 31                     | 30   | 29-16 | 15   | 14   | 13-0 |
| ------ | ---------------------- | ---- | ----- | ---- | ---- | ---- |
| 0      | SF                     | -    | RPC   | T    | -    | PC   |
| 1      | LM                     |      | EPC   | DF   | -    | SPC  |
| 2      | GR0                    |      |       |      |      |      |
| 3      | GR1                    |      |       |      |      |      |
| 4      | GR2                    |      |       |      |      |      |
| 5      | GR3                    |      |       |      |      |      |
| 6      | GR4                    |      |       |      |      |      |
| 7      | GR5                    |      |       |      |      |      |
| 8      | GR6                    |      |       |      |      |      |
| 9      | GR7                    |      |       |      |      |      |
| 10     | MDA(burst DMA)         |      |       |      |      |      |
| 11     | MSA(burst DMA)         |      |       |      |      |      |
| 12     | MS(burst DMA)          |      |       |      |      |      |
| 13     | MD(burst DMA)          |      |       |      |      |      |
| 14     | PDA (peripheral DMA)   |      |       |      |      |      |
| 15     | PSA (peripheral DMA)   |      |       |      |      |      |
| 16     | PS (peripheral DMA)    |      |       |      |      |      |
| 17     | PD (peripheral DMA)    |      |       |      |      |      |
| 18     |                        |      |       |      |      |      |
| 19     |                        |      |       |      |      |      |
| 20     | Reserved1              |      |       |      |      |      |
| 21     | Reserved1              |      |       |      |      |      |
| 22     | Reserved1              |      |       |      |      |      |
| 23     | Reserved1              |      |       |      |      |      |
| 24     | Scratch RAM (optional) |      |       |      |      |      |
| 25     | Scratch RAM (optional) |      |       |      |      |      |
| 26     | Scratch RAM (optional) |      |       |      |      |      |
| 27     | Scratch RAM (optional) |      |       |      |      |      |
| 28     | Scratch RAM (optional) |      |       |      |      |      |
| 29     | Scratch RAM (optional) |      |       |      |      |      |
| 30     | Scratch RAM (optional) |      |       |      |      |      |
| 31     | Scratch RAM (optional) |      |       |      |      |      |

......

### 46.7 Application Notes
#### 46.7.1 Data Structures for Boot Code and Channel Scripts
&emsp;&emsp;SDMA 引导代码下载不同的通道上下文和<u>在 application 期间将在 SDMA 通道上执行的脚本</u>。
&emsp;&emsp;当 ARM 平台启动通道 0，并复位后，引导代码运行。引导代码也称为通道 0 脚本。
&emsp;&emsp;引导代码基于通道控制块 (CCB) 和缓冲区描述符 (BD) 机制，它们是位于 ARM 平台内存空间中的数据结构。使用这些数据结构，可以指示 SDMA 下载脚本和上下文，也可以将上下文或脚本转储到目标数据缓冲区。通道脚本还使用 CCB 和 BD 数据结构来传递指令和/或指向要复制的数据的指针。
&emsp;&emsp;CCB 和 BD 的格式、处理和字段定义完全由软件脚本而不是 SDMA 硬件定义和执行。此处提供了格式和结构的概述，但有关完整详细信息，请参阅 SDMA 软件文档（请参阅 SDMA 脚本）。
&emsp;&emsp;CCB 和 BD 数据结构由 SDMA 使用 DMA 访问并由 SDMA 脚本处理。 ROM 包含用于处理这些数据结构的公共子程序，这些数据结构可以由引导加载和通道脚本调用。 



&emsp;&emsp;上图显示了如何链接这些数据结构以将命令和指针传递给数据缓冲区的示例。 SDMA 的 MC0PTR 寄存器保存通道 0 控制块 (CCB0) 的基地址。 通道 0 控制块保存指向缓冲区描述符数组的指针。 缓冲区描述符用于告诉通道 0（引导通道）做什么，如缓冲区描述符格式所述。 
##### 46.7.1.1 Buffer Descriptor Format
&emsp;&emsp;缓冲区描述符的大小为三个 long（32 位字），如图所示。
&emsp;&emsp;缓冲区描述符描述了它指向的数据缓冲区的属性。 缓冲区描述符可用于 ARM 平台处理器内存中的线性或循环数据缓冲区。 CCB 包含一个指向基本 BD 以及当前 BD 的指针。 

| Field         | Description                                                  |
| ------------- | ------------------------------------------------------------ |
| 31-24 Command | 命令。 当脚本访问此特定缓冲区描述符时，命令字段用于区分脚本内执行的操作。 该字段的使用可以由脚本定义。 为引导加载脚本定义的命令值在引导加载脚本的缓冲区描述符命令中定义。 有关其他脚本的命令字段定义，请参阅 SDMA 脚本中脚本库文档中的单个脚本定义。 |
| 23            | reserved                                                     |
| 22            | reserved                                                     |
| 21 L          | Last Buffer Descriptor：该位在 SDMA IPC 脚本中设置，以向接收内核指示传输已结束。 每当源完成传输它要传输的计数时，它会在目标BD中设置LAST_BIT，以让目标知道传输结束。该位还告诉目标软件，当它处理目标BD时，在设置了 LAST_BIT 的 BD 之后,它们不需要处理任何 BD 。例如，当 DSP 准备一个计数等于 25 的单个缓冲区描述符，而 ARM 平台准备一个计数等于 100 的单个缓冲区描述符时。当 25 个字节已从 DSP 传输到 ARM 平台时， DSP 缓冲区描述符通常关闭，而 ARM 平台缓冲区描述符将设置 L 位并将字节数更新为 25。 |
| 20 R          | 错误。 指示通道的缓冲区描述符请求命令发生错误。 某些脚本可能会使用指示错误来源的错误代码覆盖命令字段。<BR>0 No Error<BR>1 Error |
| 19 I          | Interrupt. 当 SDMA 完成处理附加到此缓冲区描述符的数据传输时，向 ARM 平台发送中断。<BR>0 No Interrupt<br>1 Interrupt the processor when BD is complete |
| 18 C          | 连续。 该缓冲区允许接收多个发送缓冲区或允许发送到多个接收缓冲区。连续位在 BD 处理结束时被解码，以确定 SDMA 脚本是否必须打开一个新的 BD 以潜在地继续数据传输。<br>0 没有更多的缓冲区描述符<br>1 SDMA 应移至此之后的下一个缓冲区描述符 |
| 17 W          | wrap. 指示此缓冲区描述符是否是通道控制块的最后一个。 当遇到此位设置时，SDMA 脚本会更新 CurrentBD 指针以指向数组的第一个缓冲区描述符。 如果 ARM 平台想要以循环方式（如环）组织 BD 数组，则设置该位。 当所有 BD 都已处理完毕并且如果在最后一个 BD 中设置了 Wrap 位和 CONtinuous 位，则 SDMA 脚本将回绕并尝试重新打开第一个 BD。<br>0 No Error<br>1 在处理完第一个缓冲区描述符后包装到第一个缓冲区描述符。 |
| 16 D          | D - “完成”：第 16 位：表示缓冲区描述符的“所有权”。 当 D=0 时，主机拥有缓冲区描述符； 当 D=1 SDMA 拥有缓冲区描述符。 在通道 0 的情况下，D=1 表示 SDMA 尚未处理此缓冲区，D=0 表示 SDMA 已处理此缓冲区。<br>0 ARM platform owns the buffer.<br>1 SDMA owns the buffer |
| 15-0 Count    | count. 计数字段（位 15-0）表示要传输的数据的大小，缓冲区描述符指向的数据缓冲区的大小。 SDMA 存储器结构对于程序存储器（16 位短/半字）和数据存储器（32 位长）是不同的。 对于通道 0 缓冲区描述符，计数在寻址 PM 时以 16 位半字表示，而在寻址 DM 时以 32 位字表示。 对于其他通道脚本，计数通常以字节表示，但单位取决于脚本。 |
| 31-0          | 缓冲区地址。 指向数据缓冲区的地址指针。                      |
| 31-0          | 扩展缓冲区地址。 某些脚本所需的附加指针或其他信息。          |


&emsp;&emsp;缓冲区描述符形成一个可编程大小的数组。如果最后一个缓冲区描述符由 Wrap 标志位 W=1 标记，则缓冲区描述符数组被视为一个环，其中一些逻辑上连续的部分由 ARM 平台拥有，D=0，其余部分由 SDMA 拥有D=1。缓冲区描述符的计数字段指示已经传输了多少数据。
&emsp;&emsp;如果 ARM 平台准备了 3 个缓冲区供 SDMA 脚本填充，它也准备了 3 个 BD，每个缓冲区一个。 Cont 和 Wrap 位用于以循环方式组织缓冲区。例如，CONTinous 位在前 2 个 BD 中设置为 1，在第 3 个 BD 中设置 Wrap。 SDMA 脚本打开并处理 BD#1。由于此 BD 设置了 CONTinous 位，因此 SDMA 将打开第二个 BD 并对其进行处理。每次处理 BD 时，其 Done 位都会由 SDMA 复位。在第 3 个 BD 之后，如果
没有设置CONTinous，如果设置了Wrap，SDMA脚本就停在这里，下次触发通道时，脚本会打开CCB的currentBDptr指针指向的BD，对应第一个缓冲区描述符。
&emsp;&emsp;如果在第 3 个 BD 中同时设置了 CONtinous 位和 Wrap 位，脚本将关闭它并尝试打开第一个 BD。如果 BD#1 已经被处理并且其 Done 位为 0，则此时可能会发生错误。SDMA 脚本无法处理 Done 位为 0 的 BD。这意味着 BD 尚未准备好进行处理。为避免这种情况，如果设置了 Wrap，则不应为最后一个 BD 设置 CONtinous 位，并且必须为最后一个 BD 设置中断标志。它将警告 BD 的所有者所有 BD 已被处理，如果它希望 SDMA 再次填充它们，它必须将所有 BD 的 Done 位重新设置为 1。基本上，如果 ARM 平台希望 SDMA 以循环方式填充缓冲区，那么 ARM 平台有责任在适当的时间设置缓冲区描述符的 Done 位。 


&emsp;&emsp;上图显示了一个示例缓冲区描述符流。 当传入的数据被存储并填充第一个 25 字节的缓冲区时，SDMA 脚本会打开第二个 BD，因为设置了 CONTinuous 位。 然后将下一个传入数据放入第二个缓冲区。 在接收到 50 个字节后，第二个缓冲区描述符也被关闭。 Done 位被复位，第三个 BD 被打开。 在接收到另外 25 个字节后，第三个缓冲区已满，并且向 ARM 平台发送一个中断，因为第 3 个 BD 中设置了中断标志。 CONtinuous 标志不存在，传输结束。 下次触发脚本时，要打开的 BD 将是自第 3 个 BD 中设置 Wrap 标志以来的第一个缓冲区描述符。 如果要使用相同的缓冲区，则设置所有 BD 的 Done 位是 ARM 平台的责任。 
##### 46.7.1.2 Buffer Descriptor Commands for Bootload scripts
&emsp;&emsp;缓冲区描述符的命令字段为每个脚本单独定义。
&emsp;&emsp;下表列出了为通道 0 引导加载脚本定义的缓冲区描述符命令。 


&emsp;&emsp;通道 0 引导加载命令总结如下： 
* C0_SET_[PM-DM]：在“扩展缓冲区地址”字段指向的地址处加载SDMA本地内存中的缓冲区描述符数据。 SDMA RAM 可以看作是程序存储器（PM，16 位地址）或数据存储器（DM 32 位地址）。 当使用 C0_SET_PM 时，计数字段以“shorts”（16 位半字）表示，该命令可用于下载脚本。 当使用 C0_SET_DM 时，计数字段以“long”（32 位字）表示，该命令可用于将通道上下文下载到 RAM 中的上下文通道区域。 
* C0_GET_[PM-DM]：将 SDMA 本地存储器的内容从“扩展缓冲区地址”字段指向的地址写入缓冲区描述符的数据缓冲区，长度由缓冲区描述符中的计数定义。 C0_GET_PM 用于转储程序存储器的某些部分（可能用于转储通道的上下文），因此计数以“shorts”表示； 而 C0_GET_DM 用于转储到缓冲区描述符的数据缓冲区，因此计数字段为“longs”。 
* C0_SETCTX：加载一个上下文到 SDMA 上下文页面区域。 处理脚本从缓冲区描述符的命令字段的 5 MSB 解码通道号。 使用通道号，脚本计算通道的上下文数据指针相对于上下文页面基址的偏移量，以用作 SDMA 内存中的目标地址。 然后调用上面解释的 C0_SET_DM 命令从内存加载 SDMA RAM。 计数器指示上下文结构的字大小。 
* Command value：（二进制）cccc c111，其中 ccccc 是通道号（5 位）。 例如，0x0F 表示为通道 1 设置上下文，0xFF 表示为通道 31 设置上下文。 
* C0_GETCTX：将SDMA上下文页面区域的内容写入缓冲区描述符的数据缓冲区。 处理脚本从缓冲区描述符的命令字段的 5 MSB 解码通道号。 使用此通道号，脚本计算通道的上下文数据指针相对于上下文页面基址的偏移量，以用作副本的源地址。 然后调用上面解释的 C0_GET_DM 命令将上下文复制到内存。 计数器指示上下文结构的字大小。 
* Command value：（二进制）：cccc c011，其中ccccc为通道号（5位）。 例如，0x03 表示获取通道 1 的上下文，0xFB 表示获取通道 31 的上下文。 

&emsp;&emsp;注意：要下载通道上下文，可以使用 C0_SETDM 和 C0_SETCTXT 命令，但第二个更容易，因为通道号嵌入在命令字段中，而使用 C0_SETDM，指向通道上下文区域的指针必须写入扩展缓冲区地址字段 缓冲区描述符。 

##### 46.7.1.3 Example of Buffer Descriptors for Channel 0.
&emsp;&emsp;图 43-19 说明了在执行引导代码之前必须在 ARM 平台内存空间中设置的缓冲区描述符，以下载通道 1、4 和 10 的上下文和脚本。在引导代码执行之后，SDMA 内存将填充 不同的上下文和脚本如下图所示。 


##### 46.7.1.4 Channel Context
&emsp;&emsp;本地保存区指针指向 32 个通道上下文内存结构。 这些通道上下文内存结构是固定的。
SDMA 中的脚本根据结构长度和通道号计算给定通道的内存偏移量。 下图显示了通道上下文的结构，因为它保存在 SDMA 本地存储器 (RAM) 中。
&emsp;&emsp;一个通道上下文包含 24 个字，每个寄存器一个。 每个通道总共保留 32 个字。 额外的 8 个字称为暂存 RAM，它们专用于每个通道。 该内存区域通常用于堆栈管理。
&emsp;&emsp;该结构分为4个区域： 
* 通道状态寄存器
* 通用寄存器
* 反映 ARM 平台 DMA 状态的功能单元状态寄存器（突发和外设 DMA）。
* 暂存 RAM 

&emsp;&emsp;通道上下文状态寄存器的详细信息如下图所示。
&emsp;&emsp;第一个长寄存器的 PC 字段必须指向将在通道上执行的脚本所在的 SDMA RAM 地址，该值等于使用 C0_SETPM 命令存储在缓冲区描述符的扩展缓冲区地址中的值。 

#### 46.7.2 Typical Data Transfer Supported by SDMA DMA Units
&emsp;&emsp;本节介绍了一个 SDMA 脚本库，这些脚本通过外设 DMA 和突发 DMA 单元执行数据传输。
&emsp;&emsp;ARM 平台内存和外设是外设 DMA 或突发 DMA 可以访问的设备。 这些脚本是为外设 DMA 提供的，当涉及内部存储器时，其地址寄存器以递增模式编程。 有关摘要，请参见下表。 

注意：这些脚本作为如何使用 DMA 块执行所需数据传输的示例提供：它们不是“官方”程序。 

##### 46.7.2.1 External Memory to External Memory
&emsp;&emsp;本节介绍在外部存储器中执行数据移动的 SDMA 脚本。
&emsp;&emsp;对于这种特定的数据传输，仅使用突发 DMA。 它在复制模式下编程，因此没有数据通过 SDMA 通用寄存器传输。 
&emsp;&emsp;SDMA 内核只监控数据传输状态。 假设源地址和目标地址值已经存在于两个 SDMA 通用寄存器（r1 和 r2）中。 对于此示例，还假设源到目标地址的 32 位字移动存在于 r0 中并且等于 64。
&emsp;&emsp;外部存储器中的数据移动 



&emsp;&emsp;所有指令都在一个周期内执行（跳转除外）。 指令 7 触发复制传输：开始 8 字的读突发访问，数据在 MD 中暂存，然后执行 8 字的写突发。 指令 8、9、5 和 6 在突发访问过程中执行。 如果在第二次执行指令 7 时此访问未完成，只要先前的复制传输未结束，SDMA 就会停止该指令。 在这种情况下，指令不再是单周期指令。
&emsp;&emsp;在主循环 (MAIN_XFER) 期间，r1 始终等于 8，因此突发长度为 8 个字。 在最后一条 ldf |CPY 指令 (10) 上，r1 等于 r0 的提示除以 8； 因此，在复制模式下触发的突发长度等于 r1 值，介于 1 和 7 之间。 

##### 46.7.2.2 Peripheral to Peripheral Transfer
&emsp;&emsp;对于此数据传输，仅使用外设 DMA。
&emsp;&emsp;它被编程为复制模式，因此不会通过 ldf 指令中使用的 SDMA 通用寄存器传输任何数据，但通用寄存器的内容会丢失。 SDMA 内核只监视传输。 
###### 43.7.2.2.1 Source and Destination Target Have the Same Data Path Width
&emsp;&emsp;当源和目标目标具有相同的数据路径宽度时，以下情况为真： 
* 源目标是位于地址 0x1002 的半字（16 位）外设。 
* 目标是位于地址 0x2006 的半字（16 位）外设。 

&emsp;&emsp;假设地址值已经存在于两个 SDMA 通用寄存器 (r1, r2) 中。 传输10个半字的脚本如下：
&emsp;&emsp;源和目标的相同数据路径宽度 


&emsp;&emsp;如果必须在两个字外设之间进行数据传输，则只需更新设置部分。 传输本身始终由硬件循环指令执行。
&emsp;&emsp;所有指令都在一个周期内执行（流程改变除外）。 在指令 6 上，触发单次读取访问，读取数据暂存于 PD 中，并执行写入目标。 当传输正在进行时，SDMA 可以并行执行下一条指令。 如果执行复制传输的指令 6 在前一次访问未结束时执行，则 SDMA 停止并且指令 ldf 是多周期指令。 

###### 46.7.2.2.2 Source and Destination Target Have a Different Data Path Width
&emsp;&emsp;当源目标和目标目标具有不同的数据路径宽度时，不能使用复制模式，并且任何启动复制传输的尝试都会立即引发错误，该错误存储在 SF 标志中。
&emsp;&emsp;以下示例显示了可以将 10 个字从字（32 位）外设传输到半字外设的 SDMA 代码，该半字外设的地址是初步的并存储在 r1 和 r2 中。 
&emsp;&emsp;源和目标的不同数据路径宽度 
&emsp;&emsp;在指令 1 上，当源地址寄存器被编程并且需要数据预取时，执行读访问。并行地，SDMA 执行指令 2 到 5。在指令 6 上，SDMA 尝试读取指令 1 获取的数据。如果数据准备好，ldf 将是一个单周期指令；否则，只要读取访问未完成，SDMA 就会停止。然后，读取数据的 16 LSB 存储在 PD 中并自动刷新到目标外设。 SDMA 并行执行轮换指令（8、9），并将读取数据的 16 MSB 存储到 PD 中。如果先前的写访问完成，则指令 10 将是一个单周期指令。
&emsp;&emsp;主循环传输可能看起来效率低下，但由于每次执行外部访问时都会对外设 DMA 施加等待状态，因此软件流水线就位。在刷新 PD 所需的时间内，SDMA 执行移动和旋转操作。 SDMA 与 DMA 访问并行执行指令。 

##### 46.7.2.3 Transfer Between Peripheral and External Memory
###### 46.7.2.3 Transfer Between Peripheral and External Memory
&emsp;&emsp;从外设到外部存储器控制器的传输涉及外设 DMA 和突发 DMA。
&emsp;&emsp;将 100 个字从字外设传输到外部存储器的代码如下：
&emsp;&emsp;外设到外部存储器的传输 



&emsp;&emsp;在指令 1 上，外设 DMA 的源地址寄存器被编程并获取数据。 该数据存储在 PD 中，并且 SDMA 在指令 7 期间读取 PD，这是一个完成读取访问的单周期指令。 在同一条指令 (7) 上，需要数据预取并执行对源外设的读取访问。 并行地，SDMA 将先前读取的数据存储到 MD 的数据寄存器中。 当 MD（八字 FIFO）已满时，会执行一次突发写访问以清空 FIFO。 只要接下来的 SDMA 指令不访问突发 DMA，它们就会是 onecycle 指令。 下图显示了外设 DMA 和突发 DMA 如何并行工作。 


&emsp;&emsp;如上图所示，由 ldf PD 指令触发的读访问在进行时用蓝条表示。 在等待状态之后，读取的数据（数据 0，数据 1）在 clk 上升沿存储在 PD 中。 在边沿 2，数据 0 在 PD 中可用，因此可以将其传输到 SDMA 通用寄存器 r1，然后存储在 MD FIFO 中。 在边 3 上，数据 1 不在 PD 中； 因此，SDMA 在持续两个周期的 ldf 指令上停止。 下图显示了当 MD FIFO 充满数据时的示例。


&emsp;&emsp;在上图中，写入条表示突发 DMA 正在执行写入突发访问。 第一次写确认的延迟是四个周期。 SDMA 在指令 stf 上停止，因为没有接收到确认，MD FIFO 已满，并且没有用于存储数据 9 的空槽。当突发 DMA 对确认进行采样时，FIFO 被移位并写入数据 8。 只要 MD FIFO 中至少有一个空槽，stf MD 指令就会持续一个周期。 


###### 46.7.2.3.2 External Memory to Peripheral Transfer
&emsp;&emsp;从外部存储器到外设的传输涉及外设 DMA 和突发 DMA。
&emsp;&emsp;将 100 个字从外部存储器传输到字外设的代码如下：
&emsp;&emsp;外部存储器到外设传输 


&emsp;&emsp;在指令 1 上，开始了 8 个字的读取突发。 读取数据暂存到 MD 中。 在指令 7 上（如果数据在 MD 中可用），32 位被复制到 r1。 然后指令 8 将它们写入 PD 并执行自动刷新。 SDMA 内核、外设 DMA 和突发 DMA 可以并行工作，只要没有 SDMA 指令尝试在外设 DMA 上开始新的写访问，而前一次访问仍在进行中，或者只要在 MD 中有数据时 SDMA 尝试读取它。 

##### 46.7.2.4 Transfer Between External Memory and Internal Memory
&emsp;&emsp;由于内部存储器（ARM 平台 RAM）是通过外设 DMA 访问的，而外部存储器是通过突发 DMA 访问的，所以可以重用在外设和外部存储器之间传输中描述的 SDMA 脚本。 例外是外设 DMA 地址寄存器（PSA 或 PDA，取决于脚本）应该在递增模式而不是冻结模式下编程。 
###### 46.7.2.4.1 Internal Memory to Internal Memory
&emsp;&emsp;内部存储器只能通过外设 DMA 访问，因此外设到外设传输中描述的脚本可以通过对外设 DMA 地址寄存器的不同编程来重用。 
###### 46.7.2.4.2 Transfer Between Peripheral and Internal Memory
&emsp;&emsp;对于此传输，外设 DMA 也用于复制模式。
&emsp;&emsp;除了外设 DMA 地址寄存器编程外，SDMA 脚本与外设到外设传输中描述的脚本非常相似。 

### 46.8 ARM Platform Memory Map and Control Register Definitions
&emsp;&emsp;ARM 平台通过几个接口寄存器控制 SDMA。 这些寄存器在当前部分中进行了描述。
&emsp;&emsp;所有寄存器都使用 SDMA 时钟进行计时（这意味着 ARM 平台必须确保在要访问任何寄存器时 SDMA 时钟正在运行）。 
#### 43.8.1 ARM platform Channel 0 Pointer (SDMAARM_MC0PTR)

Address: 20E_C000h base + 0h offset = 20E_C000h  

| field  | description                                                  |
| ------ | ------------------------------------------------------------ |
| MC0PTR | 通道 0 指针包含通道 0 控制块（引导通道）在 ARM 平台内存中的 32 位地址。 附录 A 全面描述了 SDMA 应用程序编程接口 (API)。 ARM 平台具有读/写访问权限，而 SDMA 具有只读访问权限。 |

#### 43.8.2 Channel Interrupts (SDMAARM_INTR)  

Address: 20E_C000h base + 4h offset = 20E_C004h  

| field    | description                                                  |
| -------- | ------------------------------------------------------------ |
| HI[31:0] | ARM 平台中断寄存器包含 32 个 HI[i] 位。 如果设置了任何位，将导致 ARM 平台中断。 该寄存器是 ARM 平台的“可写”寄存器。 当 ARM 平台在该寄存器中设置一个位时，相应的 HI[i] 位被清除。 中断服务程序应在处理其中断时清除各个通道位，否则将导致连续中断。 SDMA负责在执行相应的done指令时设置当前通道对应的HI[i]位。 |

#### 43.8.3 Channel Stop/Channel Status (SDMAARM_STOP_STAT)  

Address: 20E_C000h base + 8h offset = 20E_C008h  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| HE    | 这个 32 位寄存器提供对 ARM 平台启用位的访问。 每个通道都有一位。 该寄存器是 ARM 平台的“可写”寄存器。 当 ARM 平台向该寄存器的第 i 位写入 1 时，会清除 HE[i] 和 HSTART[i] 位。 读取该寄存器会产生 HE[i] 位的当前状态。 |

#### 43.8.4 Channel Start (SDMAARM_HSTART)  

Address: 20E_C000h base + Ch offset = 20E_C00Ch  

| field     | description                                                  |
| --------- | ------------------------------------------------------------ |
| HSTART_HE | HSTART_HE 寄存器为 32 位宽，每个通道一位。当一个位被写入 1 时，它启用相应的通道。使用该地址访问两个物理寄存器（HSTART 和 HE），这使 ARM 平台能够在第一次触发之前第二次触发通道 处理。<br> * 该寄存器是ARM 平台的“可写”寄存器。当相应的 HE[i] 位清零时，不能设置任何 HSTART[i] 位。<br> * 当 ARM 平台尝试通过写入 1 来设置 HSTART[i] 位（如果相应的 HE[i] 位清零），HSTART[i] 寄存器中的位将保持清零，而 HE[i] 位将被设置。<br> * 如果相应的HE[i] 位已经设置，HSTART[i] 位将被设置。下次 SDMA 通道 i 尝试通过 done 指令清除 HE[i] 位时，HSTART[i] 寄存器中的位将被清除，并且 HE[i] 位将采用 HSTART 的旧值[我咬。<br> * 读取该寄存器产生HSTART[i] 位的当前状态。这种机制使 ARM 平台能够为每个通道流水线化两个 HSTART 命令。 |

#### 43.8.5 Channel Event Override (SDMAARM_EVTOVR)  

Address: 20E_C000h base + 10h offset = 20E_C010h  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| EO    | 通道事件覆盖寄存器包含 32 个 EO[i] 位。 在该寄存器中设置一个位会导致 SDMA 在调度相应通道时忽略 DMA 请求。 |

#### 43.8.6 Channel BP Override (SDMAARM_DSPOVR)  

Address: 20E_C000h base + 14h offset = 20E_C014h  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| DO    | 该寄存器是保留的。 所有 DO 位都应设置为复位值 1。设置为 0 将阻止 SDMA 通道根据可运行通道评估中描述的条件启动。<br>0 reserved<br>1 reset value |

#### 43.8.7 Channel ARM platform Override (SDMAARM_HOSTOVR)  

Address: 20E_C000h base + 18h offset = 20E_C018h  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| HO    | 通道 ARM 平台覆盖寄存器包含 32 个 HO[i] 位。 在此寄存器中设置的位会导致 SDMA 在调度相应通道时忽略 ARM 平台启用位 (HE)。 |

#### 43.8.8 Channel Event Pending (SDMAARM_EVTPEND)  

Address: 20E_C000h base + 1Ch offset = 20E_C01Ch  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| EP    | 通道事件挂起寄存器包含 32 个 EP[i] 位。 读取该寄存器使 ARM 平台能够确定在接收到 DMA 请求后哪些通道处于待处理状态。<br> • 设置该寄存器中的某个位会导致 SDMA 重新评估调度，就像映射到该通道上的 DMA 请求已经发生一样。 这对于启动通道很有用，以便在等待第一个请求之前完成初始化。 调度器还可以根据接收到的 DMA 请求设置 EVTPEND 寄存器中的位。 <br>• EP[i] 位可以在运行通道i 脚本时通过done 指令清零。 这是一种“writeones”机制：写入“0”不会清除相应的位。 |

#### 43.8.9 Reset Register (SDMAARM_RESET)  

Address: 20E_C000h base + 24h offset = 20E_C024h  

| field         | description                                                  |
| ------------- | ------------------------------------------------------------ |
| 31–2 Reserved |                                                              |
| 1 RESCHED     | 设置时，该位强制 SDMA 重新调度，就好像脚本已执行完成指令一样。 这使 ARM 平台能够通过 STOP 寄存器清除其 HE[i] 位，然后通过 RESCHED 位强制重新调度，从而从通道上的失控脚本中恢复。 RESCHED 位在上下文切换开始时被清除。 |
| 0 RESET       | 置位时，该位使 SDMA 保持在软件复位中。 内部复位信号保持低电平 16 个周期； 当内部复位信号上升时，RESET 位自动清零。 |

#### 43.8.10 DMA Request Error Register (SDMAARM_EVTERR)  

Address: 20E_C000h base + 28h offset = 20E_C028h  

| field  | description                                                  |
| ------ | ------------------------------------------------------------ |
| CHNERR | 当检测到传入的 DMA 请求并触发已挂起或正在服务的通道时，SDMA 使用此寄存器向 ARM 平台发出警告。 这可能意味着该通道的数据溢出。 <br>• 如果在INTRMASK 寄存器中设置了相应的通道位，则会向ARM 平台发送中断。<br> • 这是调度程序的“写一”寄存器。 它只能设置标志。 当 ARM 平台读取寄存器时或在 SDMA 复位期间，这些标志被清除。 <br>• 当通过相应的输入引脚接收到触发通道i 的DMA 请求并且EP[i] 位已经置位时，CHNERR[i] 位被置位； 如果 ARM 平台尝试设置 EP[i] 位，则 EVTERR[i] 位不受影响，而 EP[i] 位已设置。 |

#### 43.8.11 Channel ARM platform Interrupt Mask (SDMAARM_INTRMASK)  

Address: 20E_C000h base + 2Ch offset = 20E_C02Ch  

| field  | description                                                  |
| ------ | ------------------------------------------------------------ |
| HIMASK | 中断屏蔽寄存器包含 32 个中断生成屏蔽位。 如果设置了 HIMASK[i] 位，则在通道 i 上检测到 DMA 请求错误（例如，设置 EVTERR[i]）时，将设置 HI[i] 位并向 ARM 平台发送中断。 |

#### 43.8.12 Schedule Status (SDMAARM_PSW)  

Address: 20E_C000h base + 30h offset = 20E_C030h  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–16 Reserved |                                                              |
| 15–13 NCP[2:0] | Next Channel Priority 给出下一个待处理的通道优先级。 当优先级为0时，表示没有挂起的通道，NCR值没有意义。<br>0 No running channel<br>1 Active channel priority |
| 12–8 NCR[4:0]  | 下一个通道寄存器指示具有最高优先级的下一个调度的未决通道的编号。 |
| 7–4 CCP[2:0]   | 当前通道优先级表示当前活动通道的优先级。 当优先级为0时，没有通道在运行：SDMA空闲，CCR值没有意义。 在 SDMA 完成通道运行并进入休眠状态的情况下，CCP 将指示前一个运行通道的优先级。<br>0 No running channel<br>1 Active channel priority |
| CCR[4:0]       | 当前通道寄存器指示 SDMA 正在执行的通道号。 SDMA。 在 SDMA 完成运行通道并进入休眠状态的情况下，CCR 将指示之前运行的通道。 |

#### 43.8.13 DMA Request Error Register (SDMAARM_EVTERRDBG)  

Address: 20E_C000h base + 34h offset = 20E_C034h  

| field  | description                                                  |
| ------ | ------------------------------------------------------------ |
| CHNERR | 该寄存器与 EVTERR 相同，只是读取它不会清除其内容。 该地址用于调试模式。 ARM 平台 OnCE 可以检查这个寄存器值而不修改它。 |

#### 43.8.14 Configuration Register (SDMAARM_CONFIG)  

Address: 20E_C000h base + 38h offset = 20E_C038h  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–13 Reserved |                                                              |
| 12 DSPDMA      | 该位的功能是保留的，应该配置为零。<br>0 reset value<br>1 reserved |
| 11 RTDOBS      | 指示是否使用实时调试引脚：默认情况下它们不会切换以降低功耗。<br>0 RTD pins disabled<br>1 RTD pins enabled |
| 10–5 Reserved  |                                                              |
| 4 ACR          | ARM 平台 DMA/SDMA 核心时钟比率。 选择 ARM 平台 DMA 接口（突发 DMA 和外设 DMA）与内部 SDMA 内核时钟之间的时钟比率。 频率选择由芯片时钟控制器单独确定。 该位必须与生成 SDMA 中使用的时钟的芯片时钟控制器的配置相匹配。<br>0 ARM 平台 DMA 接口频率等于核心频率的两倍<br>1 ARM平台DMA接口频率等于内核频率 |
| 3–2 Reserved   |                                                              |
| CSM            | 选择上下文切换模式。 ARM 平台具有读/写访问权限。 SDMA 无法修改该寄存器。 重置时的值为 3，默认选择动态上下文切换。 该寄存器可以随时修改，但新的上下文切换配置只会在下一个恢复阶段开始时考虑。<br/> 注意：复位后第一次调用 SDMA 的通道 0 引导加载脚本应使用静态上下文切换模式，以确保通道 0 的上下文 RAM 在通道保存阶段初始化。 通道 0 运行一次后，可以使用任何动态上下文模式。<br/>0 static<br/>1 dynamic low power<br/>2 dynamic with no loop<br/>3 dynamic |

#### 43.8.15 SDMA LOCK (SDMAARM_SDMA_LOCK)  

Address: 20E_C000h base + 3Ch offset = 20E_C03Ch  

| field              | description                                                  |
| ------------------ | ------------------------------------------------------------ |
| 31–2 Reserved      |                                                              |
| 1 SRESET_LOCK_ CLR | SRESET_LOCK_CLR 位确定 LOCK 位是否在由写入 RESET 寄存器触发的软件复位时被清除。 如果 LOCK=1，则无法更改该位。 SREST_LOCK_CLR 由清除 LOCK 位的条件清除。<br>0 软件复位不会清除 LOCK 位。<br>1 软件复位清除 LOCK 位。 |
| 0 LOCK             | LOCK 位用于限制通过 ROM 通道零脚本和通过 ARM 平台控制下的 OnCE 接口更新 SDMA 脚本内存的访问。<br>LOCK 位被设置：<br>• SDMA_LOCK、ONCE_ENB、CH0ADDR 和ILLINSTADDR 寄存器不能被写入。 可以读取这些寄存器，但忽略写入。 <br>• 在ROM 或RAM 之外执行的SDMA 软件可能会检查LOCK 寄存器锁定状态寄存器(SDMACORE_SDMA_LOCK) 中的LOCK 位，以确定是否允许某些操作，例如上传新脚本。 <br>一旦 LOCK 位设置为 1，只有复位才能清除它。 LOCK 位通过硬件复位清零。 仅当设置了 SRESET_LOCK_CLR 时，LOCK 才由软件复位清除。 <br>0 锁定解除。 <br>1 锁定启用。 |

#### 43.8.16 OnCE Enable (SDMAARM_ONCE_ENB)  

Address: 20E_C000h base + 40h offset = 20E_C040h  

| field         | description                                                  |
| ------------- | ------------------------------------------------------------ |
| 31–1 Reserved |                                                              |
| 0 ENB         | OnCE Enable 寄存器选择 OnCE 控制源： 清零 (0) 时，通过 JTAG 接口访问 OnCE 寄存器； 当设置为 (1) 时，ARM 平台可以通过如下所述的地址访问 OnCE 寄存器。 <br>• 复位后，通过JTAG 接口访问OnCE 寄存器。 <br>• 将 1 写入 ENB 使 ARM 平台能够像访问任何其他 SDMA 控制寄存器一样访问 ONCE_*。<br>• 清零(0) 时，不能写入所有ONCE_xxx 寄存器。 <br>如果设置了 SDMA_LOCK 寄存器中的 LOCK 位，则无法更改 ENB 的值。 |

#### 43.8.17 OnCE Data Register (SDMAARM_ONCE_DATA)  

Address: 20E_C000h base + 44h offset = 20E_C044h  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| DATA  | OnCE JTAG 控制器的数据寄存器。 有关此寄存器的信息，请参阅 OnCE 和实时调试。 |

#### 43.8.18 OnCE Instruction Register (SDMAARM_ONCE_INSTR)  

Address: 20E_C000h base + 48h offset = 20E_C048h  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–16 Reserved |                                                              |
| INSTR          | OnCE JTAG 控制器的指令寄存器。 有关此寄存器的信息，请参阅 OnCE 和实时调试。 |

#### 43.8.19 OnCE Status Register (SDMAARM_ONCE_STAT)  

Address: 20E_C000h base + 4Ch offset = 20E_C04Ch  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–16 Reserved |                                                              |
| 15–12 PST[3:0] | 处理器状态位反映 SDMA RISC 引擎的状态。其状态如下：<br> • “程序”状态是通常的指令执行周期。 <br>• 当数据总线（ld 或st）上的加载或存储期间存在等待状态时，插入“数据”状态。<br> • “流的变化”状态是任何指令的第二个周期，它打破了序列 指令（跳转和通道切换指令）。 <br>• 当错误导致硬件循环退出时，使用“循环中的流变化”状态。 <br>• “调试”状态意味着 SDMA 处于调试模式。 <br>• 当加载或存储功能单元总线（ldf 或stf）期间存在等待状态时，插入“功能单元”状态。<br> • 在“睡眠”模式下，没有脚本正在运行（这是 RISC 引擎空闲状态）。 “重置后”略有不同，因为触发通道时不会发生上下文恢复阶段：将执行位于地址 0 的脚本（启动操作）。 <br>• “in Sleep”状态与上述相同，只是它们没有任何对应的通道：它们在复位后进入调试模式时使用。原因是离开调试模式时需要返回到“Sleep after Reset”状态。<br>0 Program <br/>1 Data <br/>2 Change of Flow <br/>3 Change of Flow in Loop <br/>4 Debug <br/>5 Functional Unit <br/>6 Sleep <br/>7 Save <br/>8 Program in Sleep <br/>9 Data in Sleep <br/>10 Change of Flow in Sleep <br/>11 Change Flow in Loop in Sleep <br/>12 Debug in Sleep <br/>13 Functional Unit in Sleep <br/>14 Sleep after Reset <br/>15 Restore |
| 11 RCV         | 每次对实时缓冲区 (RTB) 进行写访问后，都会设置 RCV 位。 该位在执行 rbuffer 命令和 JTAG 复位后清零。 |
| 10 EDR         | 当 SDMA 在外部调试请求后进入调试模式时，会引发此标志。       |
| 9 ODR          | 当 SDMA 在 OnCE 调试请求后进入调试模式时，会引发此标志。     |
| 8 SWB          | 当 SDMA 在软件断点后进入调试模式时，会引发此标志。           |
| 7 MST          | 当从 ARM 平台外设接口控制 OnCE 时，会引发此标志。<br/>0 JTAG 接口控制 OnCE。 <br/>1 ARM 平台外设接口控制 OnCE。 |
| 6–3 Reserved   |                                                              |
| ECDR           | 事件单元调试请求。 如果调试请求来自事件单元，则进入调试模式的原因由 EDR 位给出。 如果 EDR 的所有三个位都被复位，则它不会生成任何调试请求。 如果单元确实生成了调试请求，则至少设置了一个 EDR 位（编码的含义如下所示）。 EDR 位的编码有助于更准确地找出生成调试请求的原因。 为 addra_cond、addrb_cond 和 data_cond 条件的特定组合生成来自事件单元的调试请求。 这些字段的值由 EDR 位给出。<br>0 1 matched addra_cond <br/>1 1 matched addrb_cond <br/>2 1 matched data_cond |

#### 43.8.20 OnCE Command Register (SDMAARM_ONCE_CMD)  

Address: 20E_C000h base + 50h offset = 20E_C050h  

| field         | description                                                  |
| ------------- | ------------------------------------------------------------ |
| 31–4 Reserved |                                                              |
| CMD           | 写入该寄存器将导致 OnCE 执行写入的命令。 需要时，在将命令写入该寄存器之前，应为 ONCE_DATA 和 ONCE_INSTR 寄存器加载正确的值。 有关 OnCE 命令及其用法的列表，请参阅 OnCE 和实时调试。<br>0 rstatus <br/>1 dmov <br/>2 exec_once <br/>3 run_core <br/>4 exec_core <br/>5 debug_rqst <br/>6 rbuffer |

#### 43.8.21 Illegal Instruction Trap Address (SDMAARM_ILLINSTADDR)  

Address: 20E_C000h base + 58h offset = 20E_C058h  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–14 Reserved |                                                              |
| ILLINSTADDR    | 非法指令陷阱地址是执行非法指令时 SDMA 跳转的地址。 复位后为 0x0001。 <br>如果设置了 SDMA_LOCK 寄存器中的 LOCK 位，则不能更改 ILLINSTADDR 的值。 |

#### 43.8.22 Channel 0 Boot Address (SDMAARM_CHN0ADDR)  

Address: 20E_C000h base + 5Ch offset = 20E_C05Ch  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–15 Reserved |                                                              |
| 14 SMSZ        | 第 14 位（暂存存储器大小）确定在每个通道上下文后暂存存储器是否必须可用。 复位后等于 0，即为每个通道定义了 24 个字的 RAM 空间。 所有这个区域都存储了通道上下文。 通过设置该位，为每个通道上下文保留 32 个字，这提供了八个额外的字，通道脚本可以使用这些字来存储任何类型的数据。 上下文切换机制永远不会删除这些单词。 如果设置了 SDMA_LOCK 寄存器中的 LOCK 位，则 SMSZ 的值不能更改。<br>0 24 words per context <br>1 32 words per context |
| CHN0ADDR       | 这个 14 位寄存器由 SDMA 的引导代码使用。 复位后，它指向 ROM 中的标准引导例程（通道 0 例程）。 通过更改此地址，您可以使用自己的例程执行引导序列。 引导代码的第一条指令获取该寄存器的内容（它也映射到 SDMA 内存空间）并跳转到给定地址。 复位值为 0x0050（十进制 80）。 如果设置了 SDMA_LOCK 寄存器中的 LOCK 位，则无法更改 CHN0ADDR 的值。 |

#### 43.8.23 DMA Requests (SDMAARM_EVT_MIRROR)  

| field  | description                                                  |
| ------ | ------------------------------------------------------------ |
| EVENTS | 该寄存器反映 SDMA 接收到的事件 31-0 的 DMA 请求。 ARM 平台和 SDMA 具有只读访问权限。 32 个 DMA 请求事件中的每一个都与一个位相关联。 在调试生成 DMA 请求的模块期间，此信息可能很有用。 EVT_MIRROR 寄存器在读取访问后被清除。 <br/>0 DMA 请求事件未挂起 <br/>1 个 DMA 请求事件挂起。 |

#### 43.8.24 DMA Requests 2 (SDMAARM_EVT_MIRROR2)  

Address: 20E_C000h base + 64h offset = 20E_C064h  

| field          | description                                                  |
| -------------- | ------------------------------------------------------------ |
| 31–16 Reserved |                                                              |
| EVENTS[47:32]  | 该寄存器反映了 SDMA 接收到的事件 47-32 的 DMA 请求。 ARM 平台和 SDMA 具有只读访问权限。 每个 DMA 请求事件都有一个位。 在调试生成 DMA 请求的模块期间，此信息可能很有用。 EVT_MIRROR2 寄存器在读取访问后被清除。<br>0 DMA 请求事件未挂起<br>1 DMA 请求事件未挂起 |

#### 43.8.25 Cross-Trigger Events Configuration Register 1 (SDMAARM_XTRIG_CONF1)  

Address: 20E_C000h base + 70h offset = 20E_C070h  

| field           | description                                                  |
| --------------- | ------------------------------------------------------------ |
| 31 Reserved     |                                                              |
| 30 CNF3         | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定事件线脉冲是由接收 DMA 请求还是由开始执行通道脚本生成的。 <br>0 通道 <br>1  DMA 请求 |
| 29–24 NUM3[5:0] | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |
| 23 Reserved     |                                                              |
| 22 CNF2         | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定是通过接收 DMA 请求还是通过启动通道脚本执行来生成事件线脉冲。<br>0 channel<br>1 DMA 请求 |
| 21–16 NUM2[5:0] | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |
| 15 Reserved     |                                                              |
| 14 CNF1         | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定是通过接收 DMA 请求还是通过启动通道脚本执行来生成事件线脉冲。<br/>0 channel<br/>1 DMA 请求 |
| 13–8 NUM1[5:0]  | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |
| 7 Reserved      |                                                              |
| 6 CNF0          | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定是通过接收 DMA 请求还是通过启动通道脚本执行来生成事件线脉冲。<br/>0 channel<br/>1 DMA 请求 |
| NUM0[5:0]       | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |

#### 43.8.26 Cross-Trigger Events Configuration Register 2 (SDMAARM_XTRIG_CONF2)  

Address: 20E_C000h base + 74h offset = 20E_C074h  

| field           | description                                                  |
| --------------- | ------------------------------------------------------------ |
| 31 Reserved     |                                                              |
| 30 CNF7         | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定事件线脉冲是由接收 DMA 请求还是由开始执行通道脚本生成的。 <br/>0 通道 <br/>1  DMA 请求 |
| 29–24 NUM7[5:0] | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |
| 23 Reserved     |                                                              |
| 22 CNF6         | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定事件线脉冲是由接收 DMA 请求还是由开始执行通道脚本生成的。 <br/>0 通道 <br/>1  DMA 请求 |
| 21–16 NUM6[5:0] | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |
| 15 Reserved     |                                                              |
| 14 CNF5         | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定事件线脉冲是由接收 DMA 请求还是由开始执行通道脚本生成的。 <br/>0 通道 <br/>1  DMA 请求 |
| 13–8 NUM5[5:0]  | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |
| 7 Reserved      |                                                              |
| 6 CNF4          | 连接到交叉触发器的 SDMA 事件行号 i 的配置。 它确定事件线脉冲是由接收 DMA 请求还是由开始执行通道脚本生成的。 <br/>0 通道 <br/>1  DMA 请求 |
| NUM4[5:0]       | 包含触发交叉触发事件行号 i 上的脉冲的 DMA 请求或通道的编号。 |



#### 43.8.27 Channel Priority Registers (SDMAARM_SDMA_CHNPRIn)  

43.8.27 Channel Priority Registers (SDMAARM_SDMA_CHNPRIn)  

| field         | description                                                  |
| ------------- | ------------------------------------------------------------ |
| 31–3 Reserved |                                                              |
| CHNPRIn       | 这包含通道号 n 的优先级。 有用的值在 1 到 7 之间； 0 由 SDMA 硬件保留，以确定何时没有挂起的通道。 复位值为 0，防止通道启动。 |

#### 43.8.28 Channel Enable RAM (SDMAARM_CHNENBLn)  

Address: 20E_C000h base + 200h offset + (4d × i), where i=0d to 47d  

| field | description                                                  |
| ----- | ------------------------------------------------------------ |
| ENBLn | This 32-bit value selects the channels that are triggered by the DMA request number n. If ENBLn[i] is set to 1, bit EP[i] will be set when the DMA request n is received. These 48 32-bit registers are physically located in a RAM, with no known reset value. It is thus essential for the ARM platform to program them before any DMA request is triggered to the SDMA, otherwise an unpredictable combination of channels may be started. |






## 第四十八章 SNVS 安全非易失性存储
### 48.1 概述
&emsp;&emsp;智能直接内存访问 (SDMA) 控制器提供极具竞争力的 DMA 功能以及基于软件的虚拟 DMA 灵活性。 它支持外围 I/O 设备和内部/外部存储器之间的数据传输。
&emsp;&emsp;SDMA 控制器通过在动态数据路由中卸载 Arm 内核来帮助最大限度地提高系统性能。 


## 第五十二章 Temperature Monitor 温度监测器
### 52.1 概述
&emsp;&emsp;温度传感器模块基于与温度相关的电压到时间的转换来实现温度传感/转换功能。 
&emsp;&emsp;该模块具有报警功能，如果温度高于两个高温阈值和低于一个低温阈值，可以发出独立的中断信号。这些温度阈值是可编程的，并指定为低、高和紧急温度。紧急阈值是一个特殊的可编程阈值，因为如果温度升高到该值以上并且在系统复位控制器中启用了温度紧急复位中断，则硬件将假定软件不再控制热情况并启动芯片复位。 
&emsp;&emsp;为了避免错误的紧急温度启动复位，在连续四个转换周期满足温度紧急条件之前，紧急警报不会触发。也可以对自重复模式进行编程，该模式基于可编程的延迟执行温度感测操作。 
&emsp;&emsp;由于高温和低温阈值是可编程的，因此它们形成了一个可根据应用需求量身定制的滑动温度支架。 例如，在启动时，软件可以将低温阈值设置为系统的最低温度代码，将高温阈值设置为系统的最高工作温度。
&emsp;&emsp;然后，系统可以使用该模块来监控片上温度，并在设置高温中断时采取适当的措施，例如节流内核频率。 一旦设置了高温中断，系统就可以将低温阈值编程为所需的冷却温度。 然后系统将切换到监测低温警报并等待其中断被设置。 通过这种方案，一旦设置了低温中断，软件就可以确保温度已经冷却到安全水平，并且可以重复该过程。 
&emsp;&emsp;如上图所示，温度传感器使用并假设带隙参考、480MHz PLL 和 32KHz RTC 模块已正确编程并完全稳定以进行正确操作。 
### 52.2 软件使用指南
&emsp;&emsp;在系统正常运行期间，软件可以使用温度传感器计数器的输出 (TEMP_CNT) 和熔断器温度校准数据来确定片上运行温度或将过温中断警报设置在几°C 以内。
&emsp;&emsp;根据校准，可通过设备上的保险丝获得两组温度和计数器值。 这些数据点将对应于下面曲线中的点 (N1, T1) 和 (N2, T2)。 
&emsp;&emsp;在一次温度测量周期之后，软件应结合使用校准点和 TEMPMON_TEMPSENSE0[TEMP_CNT] 位域中的温度编码值，使用以下公式计算设备的温度： 
$$T_{meas} = T_2 - (N_{meas} - N_2) * ((T_2 - T_1)/(N_1 - N_2))$$
&emsp;&emsp;同样，为了确定要写入 TEMPMON_TEMPSENSE0 寄存器中的警报计数器值，用于基于温度的中断，可以根据所需的温度触发器对应使用的 $N_{meas}$ 值求解上述等式。
&emsp;&emsp;OCOTP_ANA1 寄存器中提供了温度校准点保险丝值。 在产品测试过程中，每个部件的温度校准值都是单独融合的。 下表描述了该寄存器的字段。 
### 52.3 TEMPMON 寄存器定义
#### 52.3.1 Tempsensor Control Register 0
&emsp;&emsp;此寄存器定义了温度传感器的基本控制位，除了在 tempsensor 中定义的采样频率。
* 31-20 ALARM_VALUE 温度计数值（原始传感器的输出），此值可以产生警告中断。
* 19-8 TEMP_CNT 上次的温度计数值。
* 2 FINISHED 表明上次采样有效。每次监测开始之后，sensor应该清空此位
  * 0 INVALID 上次监测还未准备好
  * 1 VALID 上次监测有效
* 1 MEASURE_TEMP 开始监测过程。如果在 TEMPSENSE1 寄存器中监测频率是0，此结果是单次转换。
  * 0 STOP 不开始监测过程
  * 1 START 开始监测过程
* 0 POWER_DOWN 此位控制传感器的电源开关
  * 0 POWER UP
  * 1 POWER DOWN
#### 52.3.2 Tempsensor Control Register 1
&emsp;&emsp;该寄存器定义了温度传感器的自动重复时间。 
#### 52.3.3 Tempsensor Control Register 2
* 27-16 PANIC_ALARM_VALUE 
* 11-0 LOW_ALARM_VALUE

## imx_thermal.c文件分析









